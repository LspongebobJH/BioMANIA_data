{
    "ehrapy.preprocessing.soft_impute": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "The AnnData object to impute missing values for.",
                "optional_value": true
            },
            "var_names": {
                "type": "Optional[Iterable[str]]",
                "default": "None",
                "optional": true,
                "description": "A list of var names indicating which columns to impute (if None -> all columns).",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to return a copy or act in place.",
                "optional_value": false
            },
            "warning_threshold": {
                "type": "int",
                "default": "70",
                "optional": true,
                "description": "Threshold of percentage of missing values to display a warning for. Defaults to 30 .",
                "optional_value": false
            },
            "shrinkage_value": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "convergence_threshold": {
                "type": "float",
                "default": "0.001",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "max_iters": {
                "type": "int",
                "default": "100",
                "optional": true,
                "description": "Maximum number of SVD iterations. Defaults to 100.",
                "optional_value": false
            },
            "max_rank": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Perform a truncated SVD on each iteration with this value as its rank. Defaults to None.",
                "optional_value": false
            },
            "n_power_iterations": {
                "type": "int",
                "default": "1",
                "optional": true,
                "description": "Number of power iterations to perform with randomized SVD. Defaults to 1.",
                "optional_value": false
            },
            "init_fill_method": {
                "type": "str",
                "default": "zero",
                "optional": true,
                "description": "How to initialize missing values of data matrix, default is to fill them with zeros.",
                "optional_value": false
            },
            "min_value": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Smallest allowable value in the solution.",
                "optional_value": false
            },
            "max_value": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Largest allowable value in the solution.",
                "optional_value": false
            },
            "normalizer": {
                "type": "Optional[object]",
                "default": "None",
                "optional": true,
                "description": "Any object (such as BiScaler) with fit() and transform() methods.",
                "optional_value": true
            },
            "verbose": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Print debugging info. Defaults to False.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": ""
        },
        "Docstring": "Impute data using the SoftImpute.\n\nSee https://github.com/iskandr/fancyimpute/blob/master/fancyimpute/soft_impute.py\nMatrix completion by iterative soft thresholding of SVD decompositions.\n\nArgs:\n    adata: The AnnData object to impute missing values for.\n    var_names: A list of var names indicating which columns to impute (if None -> all columns).\n    copy: Whether to return a copy or act in place.\n    warning_threshold: Threshold of percentage of missing values to display a warning for. Defaults to 30 .\n    shrinkage_value : Value by which we shrink singular values on each iteration.\n                      If omitted then the default value will be the maximum singular value of the initialized matrix (zeros for missing values) divided by 50.\n    convergence_threshold : Minimum ration difference between iterations (as a fraction of the Frobenius norm of the current solution) before stopping.\n    max_iters: Maximum number of SVD iterations. Defaults to 100.\n    max_rank: Perform a truncated SVD on each iteration with this value as its rank. Defaults to None.\n    n_power_iterations: Number of power iterations to perform with randomized SVD. Defaults to 1.\n    init_fill_method: How to initialize missing values of data matrix, default is to fill them with zeros.\n    min_value: Smallest allowable value in the solution.\n    max_value: Largest allowable value in the solution.\n    normalizer: Any object (such as BiScaler) with fit() and transform() methods.\n    verbose: Print debugging info. Defaults to False.\n\nReturns:\n    The AnnData object with imputed missing values.\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.soft_impute(adata)",
        "description": "Impute data using the SoftImpute.See https://github.com/iskandr/fancyimpute/blob/master/fancyimpute/soft_impute.py\nMatrix completion by iterative soft thresholding of SVD decompositions.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.soft_impute(adata)",
        "api_type": "function",
        "api_calling": [
            "ehrapy.preprocessing.soft_impute(adata=$, var_names=@, copy=@, warning_threshold=@, shrinkage_value=@, convergence_threshold=@, max_iters=@, max_rank=@, n_power_iterations=@, init_fill_method=@, min_value=@, max_value=@, normalizer=$, verbose=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.preprocessing.winsorize": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "AnnData object to winsorize",
                "optional_value": true
            },
            "vars": {
                "type": "Union[str, list[str], set[str]]",
                "default": "None",
                "optional": true,
                "description": "The features to winsorize.",
                "optional_value": false
            },
            "obs_cols": {
                "type": "Union[str, list[str], set[str]]",
                "default": "None",
                "optional": true,
                "description": "Columns in obs with features to winsorize.",
                "optional_value": false
            },
            "limits": {
                "type": "list[float]",
                "default": "None",
                "optional": true,
                "description": "Tuple of the percentages to cut on each side of the array as floats between 0. and 1.\nDefaults to (0.01, 0.99)",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to return a copy or not",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": ""
        },
        "Docstring": "Returns a Winsorized version of the input array.\n\nThe implementation is based on https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.winsorize.html\n\nArgs:\n    adata: AnnData object to winsorize\n    vars: The features to winsorize.\n    obs_cols: Columns in obs with features to winsorize.\n    limits: Tuple of the percentages to cut on each side of the array as floats between 0. and 1.\n            Defaults to (0.01, 0.99)\n    copy: Whether to return a copy or not\n    **kwargs: Keywords arguments get passed to scipy.stats.mstats.winsorize\n\nReturns:\n    Winsorized AnnData object if copy is True.\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.winsorize(adata, ['bmi'])",
        "description": "Returns a Winsorized version of the input array.The implementation is based on https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.winsorize.html",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.winsorize(adata, ['bmi'])",
        "api_type": "function",
        "api_calling": [
            "ehrapy.preprocessing.winsorize(adata=$, vars=@, obs_cols=@, limits=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.plot.tsne": {
        "Parameters": {
            "adata": {
                "type": null,
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object object containing all observations.",
                "optional_value": true
            }
        },
        "Returns": {
            "type": "Optional[Union[Axes, list[Axes]]]",
            "description": ""
        },
        "Docstring": "Scatter plot in tSNE basis.\n\nArgs:\n    adata: :class:`~anndata.AnnData` object object containing all observations.\n    color: Keys for annotations of observations/patients or features, e.g., `'ann1'` or `['ann1', 'ann2']`.\n    feature_symbols: Column name in `.var` DataFrame that stores feature symbols. By default `var_names`\n                     refer to the index column of the `.var` DataFrame. Setting this option allows alternative names to be used.\n    use_raw: Use `.raw` attribute of `adata` for coloring with feature values. If `None`,\n             defaults to `True` if `layer` isn't provided and `adata.raw` is present.\n    layer: Name of the AnnData object layer that wants to be plotted. By default\n           adata.raw.X is plotted. If `use_raw=False` is set, then `adata.X` is plotted.\n           If `layer` is set to a valid layer name, then the layer is plotted. `layer` takes precedence over `use_raw`.\n    edges: Show edges.\n    edges_width: Width of edges.\n    edges_color: Color of edges. See :func:`~networkx.drawing.nx_pylab.draw_networkx_edges`.\n    neighbors_key: Where to look for neighbors connectivities.\n                   If not specified, this looks .obsp['connectivities'] for connectivities\n                   (default storage place for pp.neighbors). If specified, this looks at\n                   `.obsp[.uns[neighbors_key]['connectivities_key']]` for connectivities.\n    arrows: Show arrows (deprecated in favour of `scvelo.pl.velocity_embedding`).\n    arrows_kwds: Passed to :meth:`~matplotlib.axes.Axes.quiver`\n    sort_order: For continuous annotations used as color parameter, plot data points with higher values on top of others.\n    groups: Restrict to a few categories in categorical observation annotation.\n            The default is not to restrict to any groups.\n    components: For instance, `['1,2', '2,3']`. To plot all available components use `components='all'`.\n    projection: Projection of plot (default: `'2d'`).\n    legend_loc: Location of legend, either `'on data'`, `'right margin'` or a valid keyword for the `loc` parameter of :class:`~matplotlib.legend.Legend`.\n    legend_fontsize: Numeric size in pt or string describing the size. See :meth:`~matplotlib.text.Text.set_fontsize`.\n    legend_fontweight: Legend font weight. A numeric value in range 0-1000 or a string.\n                       Defaults to `'bold'` if `legend_loc == 'on data'`, otherwise to `'normal'`.\n                       See :meth:`~matplotlib.text.Text.set_fontweight`.\n    legend_fontoutline: Line width of the legend font outline in pt. Draws a white outline using the path effect :class:`~matplotlib.patheffects.withStroke`.\n    size: Point size. If `None`, is automatically computed as 120000 / n_features.\n          Can be a sequence containing the size for each observation. The order should be the same as in adata.obs.\n    color_map: Color map to use for continous variables. Can be a name or a\n               :class:`~matplotlib.colors.Colormap` instance (e.g. `\"magma`\", `\"viridis\"`\n               or `mpl.cm.cividis`), see :func:`~matplotlib.cm.get_cmap`.\n               If `None`, the value of `mpl.rcParams[\"image.cmap\"]` is used.\n               The default `color_map` can be set using :func:`~scanpy.set_figure_params`.\n    palette: Colors to use for plotting categorical annotation groups.\n             The palette can be a valid :class:`~matplotlib.colors.ListedColormap` name\n             (`'Set2'`, `'tab20'`, \u2026), a :class:`~cycler.Cycler` object, a dict mapping\n             categories to colors, or a sequence of colors. Colors must be valid to\n             matplotlib. (see :func:`~matplotlib.colors.is_color_like`).\n             If `None`, `mpl.rcParams[\"axes.prop_cycle\"]` is used unless the categorical\n             variable already has colors stored in `adata.uns[\"{var}_colors\"]`.\n             If provided, values of `adata.uns[\"{var}_colors\"]` will be set.\n    na_color: Color to use for null or masked values. Can be anything matplotlib accepts as a color.\n              Used for all points if `color=None`.\n    na_in_legend: If there are missing values, whether they get an entry in the legend.\n                  Currently only implemented for categorical legends.\n    frameon: Draw a frame around the scatter plot. Defaults to value set in :func:`~scanpy.set_figure_params` (default: True).\n    title: Provide title for panels either as string or list of strings, e.g. `['title1', 'title2', ...]`.\n    vmin: The value representing the lower limit of the color scale. Values smaller than vmin are plotted\n          with the same color as vmin. vmin can be a number, a string, a function or `None`. If\n          vmin is a string and has the format `pN`, this is interpreted as a vmin=percentile(N).\n          For example vmin='p1.5' is interpreted as the 1.5 percentile. If vmin is function, then\n          vmin is interpreted as the return value of the function over the list of values to plot.\n          For example to set vmin tp the mean of the values to plot, `def my_vmin(values): return\n          np.mean(values)` and then set `vmin=my_vmin`. If vmin is None (default) an automatic\n          minimum value is used as defined by matplotlib `scatter` function. When making multiple\n          plots, vmin can be a list of values, one for each plot. For example `vmin=[0.1, 'p1', None, my_vmin]`\n    vmax: The value representing the upper limit of the color scale. The format is the same as for `vmin`.\n    vcenter: The value representing the center of the color scale. Useful for diverging colormaps.\n             The format is the same as for `vmin`.\n             Example: sc.pl.umap(adata, color='TREM2', vcenter='p50', cmap='RdBu_r')\n    add_outline: If set to True, this will add a thin border around groups of dots. In some situations\n                 this can enhance the aesthetics of the resulting image\n    outline_color: Tuple with two valid color names used to adjust the add_outline. The first color is the\n                   border color (default: black), while the second color is a gap color between the\n                   border color and the scatter dot (default: white).\n    outline_width: Tuple with two width numbers used to adjust the outline. The first value is the width\n                   of the border color as a fraction of the scatter dot size (default: 0.3). The second value is\n                   width of the gap color (default: 0.05).\n    ncols: Number of panels per row.\n           wspace: Adjust the width of the space between multiple panels.\n           hspace: Adjust the height of the space between multiple panels.\n           return_fig: Return the matplotlib figure.\n    kwargs: Arguments to pass to :func:`matplotlib.pyplot.scatter`,\n            for instance: the maximum and minimum values (e.g. `vmin=-2, vmax=5`).\n    show: Whether to display the figure or return axis.\n    save: If `True` or a `str`, save the figure.\n          A string is appended to the default filename.\n          Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\n    ax: A matplotlib axes object. Only works if plotting a single component.\n\nReturns:\n    If `show==False` a :class:`~matplotlib.axes.Axes` or a list of it.\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.knn_impute(adata)\n    >>> ep.pp.log_norm(adata, offset=1)\n    >>> ep.pp.neighbors(adata)\n    >>> ep.tl.tsne(adata)\n    >>> ep.pl.tsne(adata)\n\n    .. image:: /_static/docstring_previews/tsne_1.png\n\n    >>> ep.pl.tsne(adata, color=[\"day_icu_intime\", \"service_unit\"], wspace=0.5, title=[\"Day of ICU admission\", \"Service unit\"])\n\n    .. image:: /_static/docstring_previews/tsne_2.png\n\n    >>> ep.tl.leiden(adata, resolution=0.5, key_added=\"leiden_0_5\")\n    >>> ep.pl.tsne(adata, color=[\"leiden_0_5\"], title=\"Leiden 0.5\")\n\n    .. image:: /_static/docstring_previews/tsne_3.png",
        "description": "Scatter plot in tSNE basis.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.knn_impute(adata)\n    >>> ep.pp.log_norm(adata, offset=1)\n    >>> ep.pp.neighbors(adata)\n    >>> ep.tl.tsne(adata)\n    >>> ep.pl.tsne(adata)\n\n    .. image:: /_static/docstring_previews/tsne_1.png\n\n    >>> ep.pl.tsne(adata, color=[\"day_icu_intime\", \"service_unit\"], wspace=0.5, title=[\"Day of ICU admission\", \"Service unit\"])\n\n    .. image:: /_static/docstring_previews/tsne_2.png\n\n    >>> ep.tl.leiden(adata, resolution=0.5, key_added=\"leiden_0_5\")\n    >>> ep.pl.tsne(adata, color=[\"leiden_0_5\"], title=\"Leiden 0.5\")\n\n    .. image:: /_static/docstring_previews/tsne_3.png",
        "api_type": "function",
        "api_calling": [
            "ehrapy.plot.tsne(adata=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.plot.clustermap": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object object containing all observations.",
                "optional_value": true
            },
            "obs_keys": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Categorical annotation to plot with a different color map. Currently, only a single key is supported.",
                "optional_value": false
            },
            "use_raw": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Whether to use `raw` attribute of `adata`. Defaults to `True` if `.raw` is present.",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Whether to display the figure or return axis.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[bool, str]]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Hierarchically-clustered heatmap.\n\nWraps :func:`seaborn.clustermap` for :class:`~anndata.AnnData`.\n\nArgs:\n    adata: :class:`~anndata.AnnData` object object containing all observations.\n    obs_keys: Categorical annotation to plot with a different color map. Currently, only a single key is supported.\n    use_raw: Whether to use `raw` attribute of `adata`. Defaults to `True` if `.raw` is present.\n    show: Whether to display the figure or return axis.\n    save: If `True` or a `str`, save the figure.\n          A string is appended to the default filename.\n          Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\n    ax: A matplotlib axes object. Only works if plotting a single component.\n    **kwds:\n        Keyword arguments passed to :func:`~seaborn.clustermap`.\n\nReturns:\n    If `show` is `False`, a :class:`~seaborn.ClusterGrid` object (see :func:`~seaborn.clustermap`).\n\nExample:\n    .. code-block:: python\n\n        import ehrapy as ep\n\n        adata = ep.dt.mimic_2(encoded=True)\n        ep.pp.knn_impute(adata)\n        ep.pp.log_norm(adata, offset=1)\n        ep.pp.neighbors(adata)\n        ep.tl.leiden(adata, resolution=0.5, key_added=\"leiden_0_5\")\n        ep.pl.clustermap(adata)\n\nPreview:\n    .. image:: /_static/docstring_previews/clustermap.png",
        "description": "Hierarchically-clustered heatmap.Wraps :func:`seaborn.clustermap` for :class:`~anndata.AnnData`.",
        "example": ".. code-block:: python\n\n        import ehrapy as ep\n\n        adata = ep.dt.mimic_2(encoded=True)\n        ep.pp.knn_impute(adata)\n        ep.pp.log_norm(adata, offset=1)\n        ep.pp.neighbors(adata)\n        ep.tl.leiden(adata, resolution=0.5, key_added=\"leiden_0_5\")\n        ep.pl.clustermap(adata)\n\nPreview:\n    .. image:: /_static/docstring_previews/clustermap.png",
        "api_type": "function",
        "api_calling": [
            "ehrapy.plot.clustermap(adata=$, obs_keys=@, use_raw=@, show=@, save=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.io.write": {
        "Parameters": {
            "filename": {
                "type": "Union[str, Path]",
                "default": null,
                "optional": false,
                "description": "File name or path to write the file to",
                "optional_value": false
            },
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "extension": {
                "type": "Union[str, bool]",
                "default": "None",
                "optional": true,
                "description": "File extension. One of 'h5ad', 'csv'. Defaults to None which infers the extension from the filename.",
                "optional_value": false
            },
            "compression": {
                "type": "Optional[Literal['gzip', 'lzf']]",
                "default": "gzip",
                "optional": true,
                "description": "Optional file compression. One of 'gzip', 'lzf'. Defaults to 'gzip'",
                "optional_value": true
            },
            "compression_opts": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "See http://docs.h5py.org/en/latest/high/dataset.html.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Write :class:`~anndata.AnnData` objects to file.\n\nIt is possbile to either write an :class:`~anndata.AnnData` object to a .csv file or a .h5ad file.\nThe .h5ad file can be used as a cache to save the current state of the object and to retrieve it faster once needed.\nThis preserves the object state at the time of writing. It is possible to write both, encoded and unencoded objects.\n\nArgs:\n    filename: File name or path to write the file to\n    adata: Annotated data matrix.\n    extension: File extension. One of 'h5ad', 'csv'. Defaults to None which infers the extension from the filename.\n    compression: Optional file compression. One of 'gzip', 'lzf'. Defaults to 'gzip'\n    compression_opts: See http://docs.h5py.org/en/latest/high/dataset.html.\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.io.write(\"mimic_2.h5ad\", adata)",
        "description": "Write :class:`~anndata.AnnData` objects to file.It is possbile to either write an :class:`~anndata.AnnData` object to a .csv file or a .h5ad file.\nThe .h5ad file can be used as a cache to save the current state of the object and to retrieve it faster once needed.\nThis preserves the object state at the time of writing. It is possible to write both, encoded and unencoded objects.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.io.write(\"mimic_2.h5ad\", adata)",
        "api_type": "function",
        "api_calling": [
            "ehrapy.io.write(filename=@, adata=$, extension=@, compression=$, compression_opts=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.tools.kmf": {
        "Parameters": {
            "durations": {
                "type": "Iterable",
                "default": null,
                "optional": false,
                "description": "length n -- duration (relative to subject's birth) the subject was alive for.",
                "optional_value": true
            },
            "event_observed": {
                "type": "Optional[Iterable]",
                "default": "None",
                "optional": true,
                "description": "True if the the death was observed, False if the event was lost (right-censored). Defaults to all True if event_observed==None.",
                "optional_value": true
            },
            "timeline": {
                "type": "Iterable",
                "default": "None",
                "optional": true,
                "description": "return the best estimate at the values in timelines (positively increasing)",
                "optional_value": true
            },
            "entry": {
                "type": "Optional[Iterable]",
                "default": "None",
                "optional": true,
                "description": "Relative time when a subject entered the study. This is useful for left-truncated (not left-censored) observations.\nIf None, all members of the population entered study when they were \"born\".",
                "optional_value": true
            },
            "label": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "A string to name the column of the estimate.",
                "optional_value": false
            },
            "alpha": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "The alpha value in the confidence intervals. Overrides the initializing alpha for this call to fit only.",
                "optional_value": false
            },
            "ci_labels": {
                "type": "tuple[str, str]",
                "default": "None",
                "optional": true,
                "description": "Add custom column names to the generated confidence intervals as a length-2 list: [<lower-bound name>, <upper-bound name>] (default: <label>_lower_<1-alpha/2>).",
                "optional_value": false
            },
            "weights": {
                "type": "Optional[Iterable]",
                "default": "None",
                "optional": true,
                "description": "If providing a weighted dataset. For example, instead of providing every subject\nas a single element of `durations` and `event_observed`, one could weigh subject differently.",
                "optional_value": true
            },
            "censoring": {
                "type": "Literal['right', 'left']",
                "default": "None",
                "optional": true,
                "description": "'right' for fitting the model to a right-censored dataset.\n'left' for fitting the model to a left-censored dataset (default: fit the model to a right-censored dataset).",
                "optional_value": true
            }
        },
        "Returns": {
            "type": "KaplanMeierFitter",
            "description": ""
        },
        "Docstring": "Fit the Kaplan-Meier estimate for the survival function.\n\nSee https://lifelines.readthedocs.io/en/latest/fitters/univariate/KaplanMeierFitter.html#module-lifelines.fitters.kaplan_meier_fitter\nClass for fitting the Kaplan-Meier estimate for the survival function.\n\nArgs:\n    durations: length n -- duration (relative to subject's birth) the subject was alive for.\n    event_observed: True if the the death was observed, False if the event was lost (right-censored). Defaults to all True if event_observed==None.\n    timeline: return the best estimate at the values in timelines (positively increasing)\n    entry: Relative time when a subject entered the study. This is useful for left-truncated (not left-censored) observations.\n     If None, all members of the population entered study when they were \"born\".\n    label: A string to name the column of the estimate.\n    alpha: The alpha value in the confidence intervals. Overrides the initializing alpha for this call to fit only.\n    ci_labels: Add custom column names to the generated confidence intervals as a length-2 list: [<lower-bound name>, <upper-bound name>] (default: <label>_lower_<1-alpha/2>).\n    weights: If providing a weighted dataset. For example, instead of providing every subject\n             as a single element of `durations` and `event_observed`, one could weigh subject differently.\n    censoring: 'right' for fitting the model to a right-censored dataset.\n               'left' for fitting the model to a left-censored dataset (default: fit the model to a right-censored dataset).\n\nReturns:\n    Fitted KaplanMeierFitter\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=False)\n    >>> # Because in MIMIC-II database, `censor_fl` is censored or death (binary: 0 = death, 1 = censored).\n    >>> # While in KaplanMeierFitter, `event_observed` is True if the the death was observed, False if the event was lost (right-censored).\n    >>> # So we need to flip `censor_fl` when pass `censor_fl` to KaplanMeierFitter\n    >>> adata[:, ['censor_flg']].X = np.where(adata[:, ['censor_flg']].X == 0, 1, 0)\n    >>> kmf = ep.tl.kmf(adata[:, ['mort_day_censored']].X, adata[:, ['censor_flg']].X)",
        "description": "Fit the Kaplan-Meier estimate for the survival function.See https://lifelines.readthedocs.io/en/latest/fitters/univariate/KaplanMeierFitter.html#module-lifelines.fitters.kaplan_meier_fitter\nClass for fitting the Kaplan-Meier estimate for the survival function.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=False)\n    >>> # Because in MIMIC-II database, `censor_fl` is censored or death (binary: 0 = death, 1 = censored).\n    >>> # While in KaplanMeierFitter, `event_observed` is True if the the death was observed, False if the event was lost (right-censored).\n    >>> # So we need to flip `censor_fl` when pass `censor_fl` to KaplanMeierFitter\n    >>> adata[:, ['censor_flg']].X = np.where(adata[:, ['censor_flg']].X == 0, 1, 0)\n    >>> kmf = ep.tl.kmf(adata[:, ['mort_day_censored']].X, adata[:, ['censor_flg']].X)",
        "api_type": "function",
        "api_calling": [
            "ehrapy.tools.kmf(durations=$, event_observed=$, timeline=$, entry=$, label=@, alpha=@, ci_labels=@, weights=$, censoring=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.data.mimic_2": {
        "Parameters": {
            "encoded": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to return an already encoded object",
                "optional_value": false
            },
            "columns_obs_only": {
                "type": "Optional[Union[dict[str, list[str]], list[str]]]",
                "default": "None",
                "optional": true,
                "description": "Columns to include in obs only and not X.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": ""
        },
        "Docstring": "Loads the MIMIC-II dataset.\n\nMore details: https://physionet.org/content/mimic2-iaccd/1.0/\n\nArgs:\n    encoded: Whether to return an already encoded object\n    columns_obs_only: Columns to include in obs only and not X.\n\nReturns:\n    :class:`~anndata.AnnData` object of the MIMIC-II dataset\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)",
        "description": "Loads the MIMIC-II dataset.More details: https://physionet.org/content/mimic2-iaccd/1.0/",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)",
        "api_type": "function",
        "api_calling": [
            "ehrapy.data.mimic_2(encoded=@, columns_obs_only=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.plot.causal_effect": {
        "Parameters": {
            "estimate": {
                "type": "CausalEstimate",
                "default": null,
                "optional": false,
                "description": "The causal effect estimate to plot.",
                "optional_value": true
            },
            "precision": {
                "type": "int",
                "default": "3",
                "optional": true,
                "description": "The number of decimal places to round the estimate to in the plot title.\nDefaults to 3.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "matplotlib.axes",
            "description": ""
        },
        "Docstring": "Plot the causal effect estimate.\n\nThis function plots the causal effect of treatment on outcome, assuming a\nlinear relationship between the two. It uses the data, treatment name,\noutcome name, and estimate object to determine the data to plot. It then\ncreates a plot with the treatment on the x-axis and the outcome on the\ny-axis. The observed data is plotted as gray dots, and the causal variation\nis plotted as a black line. The function then returns the plot.\n\nArgs:\n    estimate: The causal effect estimate to plot.\n    precision: The number of decimal places to round the estimate to in the plot title.\n               Defaults to 3.\n\nReturns:\n    matplotlib.axes.Axes: The matplotlib Axes object containing the plot.\n\nRaises:\n    TypeError: If the `estimate` parameter is not an instance of `dowhy.causal_estimator.CausalEstimate`.\n    ValueError: If the estimation method in `estimate` is not supported for this plot type.",
        "description": "Plot the causal effect estimate.This function plots the causal effect of treatment on outcome, assuming a\nlinear relationship between the two. It uses the data, treatment name,\noutcome name, and estimate object to determine the data to plot. It then\ncreates a plot with the treatment on the x-axis and the outcome on the\ny-axis. The observed data is plotted as gray dots, and the causal variation\nis plotted as a black line. The function then returns the plot.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "ehrapy.plot.causal_effect(estimate=$, precision=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.preprocessing.pca": {
        "Parameters": {
            "data": {
                "type": "Union[AnnData, ndarray, spmatrix]",
                "default": null,
                "optional": false,
                "description": "The (annotated) data matrix of shape `n_obs` \u00d7 `n_vars`. Rows correspond to observations and columns to features.",
                "optional_value": true
            },
            "n_comps": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Number of principal components to compute.\nDefaults to 50, or 1 - minimum dimension size of selected representation.",
                "optional_value": false
            },
            "zero_center": {
                "type": "Optional[bool]",
                "default": "True",
                "optional": true,
                "description": "If `True`, compute standard PCA from covariance matrix.\nIf `False`, omit zero-centering variables (uses :class:`~sklearn.decomposition.TruncatedSVD`), which allows to handle sparse input efficiently.\nPassing `None` decides automatically based on sparseness of the data.",
                "optional_value": false
            },
            "svd_solver": {
                "type": "str",
                "default": "arpack",
                "optional": true,
                "description": "SVD solver to use:\n* `'arpack'` (the default) for the ARPACK wrapper in SciPy (:func:`~scipy.sparse.linalg.svds`)\n\n* `'randomized'` for the randomized algorithm due to Halko (2009).\n\n* `'auto'` chooses automatically depending on the size of the problem.\n\n* `'lobpcg'` An alternative SciPy solver.\n\nEfficient computation of the principal components of a sparse matrix currently only works with the `'arpack`' or `'lobpcg'` solvers.",
                "optional_value": false
            },
            "random_state": {
                "type": "Optional[Union[int, RandomState]]",
                "default": "0",
                "optional": true,
                "description": "Change to use different initial states for the optimization. Defaults to 0 .",
                "optional_value": false
            },
            "return_info": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Only relevant when not passing an :class:`~anndata.AnnData`: see \u201c**Returns**\u201d.",
                "optional_value": false
            },
            "dtype": {
                "type": "str",
                "default": "float32",
                "optional": true,
                "description": "Numpy data type string to which to convert the result. Defaults to float32 .",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If an :class:`~anndata.AnnData` is passed, determines whether a copy is returned. Is ignored otherwise.",
                "optional_value": false
            },
            "chunked": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If `True`, perform an incremental PCA on segments of `chunk_size`.\nThe incremental PCA automatically zero centers and ignores settings of\n`random_seed` and `svd_solver`. If `False`, perform a full PCA.",
                "optional_value": false
            },
            "chunk_size": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Number of observations to include in each chunk. Required if `chunked=True` was passed.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Union[AnnData, ndarray, spmatrix]",
            "description": ""
        },
        "Docstring": "Computes a principal component analysis.\n\nComputes PCA coordinates, loadings and variance decomposition. Uses the implementation of *scikit-learn*.\n\nArgs:\n    data: The (annotated) data matrix of shape `n_obs` \u00d7 `n_vars`. Rows correspond to observations and columns to features.\n    n_comps: Number of principal components to compute.\n             Defaults to 50, or 1 - minimum dimension size of selected representation.\n    zero_center: If `True`, compute standard PCA from covariance matrix.\n                 If `False`, omit zero-centering variables (uses :class:`~sklearn.decomposition.TruncatedSVD`), which allows to handle sparse input efficiently.\n                 Passing `None` decides automatically based on sparseness of the data.\n    svd_solver: SVD solver to use:\n\n                * `'arpack'` (the default) for the ARPACK wrapper in SciPy (:func:`~scipy.sparse.linalg.svds`)\n\n                * `'randomized'` for the randomized algorithm due to Halko (2009).\n\n                * `'auto'` chooses automatically depending on the size of the problem.\n\n                * `'lobpcg'` An alternative SciPy solver.\n\n                Efficient computation of the principal components of a sparse matrix currently only works with the `'arpack`' or `'lobpcg'` solvers.\n    random_state: Change to use different initial states for the optimization. Defaults to 0 .\n    return_info: Only relevant when not passing an :class:`~anndata.AnnData`: see \u201c**Returns**\u201d.\n    dtype: Numpy data type string to which to convert the result. Defaults to float32 .\n    copy: If an :class:`~anndata.AnnData` is passed, determines whether a copy is returned. Is ignored otherwise.\n    chunked: If `True`, perform an incremental PCA on segments of `chunk_size`.\n              The incremental PCA automatically zero centers and ignores settings of\n              `random_seed` and `svd_solver`. If `False`, perform a full PCA.\n    chunk_size: Number of observations to include in each chunk. Required if `chunked=True` was passed.\n\nReturns:\n    :X_pca: :class:`~scipy.sparse.spmatrix`, :class:`~numpy.ndarray`\n\n    If `data` is array-like and `return_info=False` was passed, this function only returns `X_pca`...\n\n    adata : :class:`~anndata.AnnData`\n\n    \u2026otherwise if `copy=True` it returns or else adds fields to `adata`:\n\n    `.obsm['X_pca']`\n    PCA representation of data.\n\n    `.varm['PCs']`\n    The principal components containing the loadings.\n\n    `.uns['pca']['variance_ratio']`\n    Ratio of explained variance.\n\n    `.uns['pca']['variance']`\n    Explained variance, equivalent to the eigenvalues of the covariance matrix.",
        "description": "Computes a principal component analysis.Computes PCA coordinates, loadings and variance decomposition. Uses the implementation of *scikit-learn*.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "ehrapy.preprocessing.pca(data=$, n_comps=@, zero_center=@, svd_solver=@, random_state=@, return_info=@, dtype=@, copy=@, chunked=@, chunk_size=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.plot.rank_features_groups_matrixplot": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "groups": {
                "type": "Union[str, Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "List of group names.",
                "optional_value": false
            },
            "n_features": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Number of features to show. Is ignored if `feature_names` is passed.",
                "optional_value": false
            },
            "groupby": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Which key to group the features by.",
                "optional_value": false
            },
            "values_to_plot": {
                "type": "Optional[Literal['scores', 'logfoldchanges', 'pvals', 'pvals_adj', 'log10_pvals', 'log10_pvals_adj']]",
                "default": "None",
                "optional": true,
                "description": "Key to plot. One of 'scores', 'logfoldchanges', 'pvals', 'pvalds_adj',\n'log10_pvals', 'log10_pvalds_adj'.",
                "optional_value": true
            },
            "var_names": {
                "type": "Optional[Union[Sequence[str], Mapping[str, Sequence[str]]]]",
                "default": "None",
                "optional": true,
                "description": "Feature names.",
                "optional_value": false
            },
            "feature_symbols": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Key for field in `.var` that stores feature symbols if you do not want to\nuse `.var_names` displayed in the plot.",
                "optional_value": false
            },
            "min_logfoldchange": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Minimum log fold change to consider.",
                "optional_value": false
            },
            "key": {
                "type": "Optional[str]",
                "default": "rank_features_groups",
                "optional": true,
                "description": "The key of the calculated feature group rankings (default: 'rank_features_groups').",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Whether to show the plot.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Where to save the plot.",
                "optional_value": false
            },
            "return_fig": {
                "type": "Optional[bool]",
                "default": "False",
                "optional": true,
                "description": "Returns :class:`StackedViolin` object. Useful for fine-tuning the plot.\nTakes precedence over `show=False`.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Plot ranking of genes using matrixplot plot (see :func:`~ehrapy.pl.matrixplot`)\n\nArgs:\n    adata: Annotated data matrix.\n    groups: List of group names.\n    n_features: Number of features to show. Is ignored if `feature_names` is passed.\n    groupby: Which key to group the features by.\n    feature_symbols: Key for field in `.var` that stores feature symbols if you do not want to\n                     use `.var_names` displayed in the plot.\n    values_to_plot: Key to plot. One of 'scores', 'logfoldchanges', 'pvals', 'pvalds_adj',\n                    'log10_pvals', 'log10_pvalds_adj'.\n    var_names: Feature names.\n    min_logfoldchange: Minimum log fold change to consider.\n    key: The key of the calculated feature group rankings (default: 'rank_features_groups').\n    show: Whether to show the plot.\n    save: Where to save the plot.\n    return_fig: Returns :class:`StackedViolin` object. Useful for fine-tuning the plot.\n                Takes precedence over `show=False`.\n\nReturns:\n    If `return_fig` is `True`, returns a :class:`MatrixPlot` object,\n    else if `show` is false, return axes dict\n\nExample:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.knn_impute(adata)\n    >>> ep.pp.neighbors(adata)\n    >>> ep.tl.leiden(adata, resolution=0.5, key_added=\"leiden_0_5\")\n    >>> ep.tl.rank_features_groups(adata, groupby=\"leiden_0_5\")\n    >>> ep.pl.rank_features_groups_matrixplot(adata, key=\"rank_features_groups\", groupby=\"leiden_0_5\")\n\nPreview:\n    .. image:: /_static/docstring_previews/rank_features_groups_matrixplot.png",
        "description": "Plot ranking of genes using matrixplot plot (see :func:`~ehrapy.pl.matrixplot`)",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.knn_impute(adata)\n    >>> ep.pp.neighbors(adata)\n    >>> ep.tl.leiden(adata, resolution=0.5, key_added=\"leiden_0_5\")\n    >>> ep.tl.rank_features_groups(adata, groupby=\"leiden_0_5\")\n    >>> ep.pl.rank_features_groups_matrixplot(adata, key=\"rank_features_groups\", groupby=\"leiden_0_5\")\n\nPreview:\n    .. image:: /_static/docstring_previews/rank_features_groups_matrixplot.png",
        "api_type": "function",
        "api_calling": [
            "ehrapy.plot.rank_features_groups_matrixplot(adata=$, groups=@, n_features=@, groupby=@, values_to_plot=$, var_names=@, feature_symbols=@, min_logfoldchange=@, key=@, show=@, save=@, return_fig=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.data.heart_disease": {
        "Parameters": {
            "encoded": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to return an already encoded object.",
                "optional_value": false
            },
            "columns_obs_only": {
                "type": "Optional[Union[dict[str, list[str]], list[str]]]",
                "default": "None",
                "optional": true,
                "description": "Columns to include in obs only and not X.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": ""
        },
        "Docstring": "Loads the Heart Disease Data Set\n\nMore details: http://archive.ics.uci.edu/ml/datasets/Heart+Disease\nPreprocessing: https://github.com/theislab/ehrapy-datasets/blob/main/heart_disease/heart_disease.ipynb\n\nArgs:\n    encoded: Whether to return an already encoded object.\n    columns_obs_only: Columns to include in obs only and not X.\n\nReturns:\n    :class:`~anndata.AnnData` object of the Heart Disease Data Set\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.heart_disease(encoded=True)",
        "description": "Loads the Heart Disease Data SetMore details: http://archive.ics.uci.edu/ml/datasets/Heart+Disease\nPreprocessing: https://github.com/theislab/ehrapy-datasets/blob/main/heart_disease/heart_disease.ipynb",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.heart_disease(encoded=True)",
        "api_type": "function",
        "api_calling": [
            "ehrapy.data.heart_disease(encoded=@, columns_obs_only=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.preprocessing.mice_forest_impute": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "The AnnData object containing the data to impute.",
                "optional_value": true
            },
            "var_names": {
                "type": "Optional[Iterable[str]]",
                "default": "None",
                "optional": true,
                "description": "A list of variable names to impute. If None, impute all variables.",
                "optional_value": false
            },
            "warning_threshold": {
                "type": "int",
                "default": "70",
                "optional": true,
                "description": "Threshold of percentage of missing values to display a warning for.\nDefaults to 30.",
                "optional_value": false
            },
            "save_all_iterations": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to save all imputed values from all iterations or just the latest.\nSaving all iterations allows for additional plotting, but may take more memory. Defaults to True.",
                "optional_value": false
            },
            "random_state": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "The random state ensures script reproducibility.\nDefaults to None.",
                "optional_value": false
            },
            "inplace": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If True, modify the input AnnData object in-place and return None.\nIf False, return a copy of the modified AnnData object. Default is False.",
                "optional_value": false
            },
            "iterations": {
                "type": "int",
                "default": "5",
                "optional": true,
                "description": "The number of iterations to run. Defaults to 5.",
                "optional_value": false
            },
            "variable_parameters": {
                "type": "Optional[dict]",
                "default": "None",
                "optional": true,
                "description": "Model parameters can be specified by variable here.\nKeys should be variable names or indices, and values should be a dict of parameter which should apply to that variable only.\nDefaults to None.",
                "optional_value": false
            },
            "verbose": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to print information about the imputation process. Defaults to False.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to return a copy of the AnnData object or modify it in-place. Defaults to False.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": ""
        },
        "Docstring": "Impute data using the miceforest.\n\nSee https://github.com/AnotherSamWilson/miceforest\nFast, memory efficient Multiple Imputation by Chained Equations (MICE) with lightgbm.\n\nArgs:\n    adata: The AnnData object containing the data to impute.\n    var_names: A list of variable names to impute. If None, impute all variables.\n    warning_threshold: Threshold of percentage of missing values to display a warning for.\n                       Defaults to 30.\n    save_all_iterations: Whether to save all imputed values from all iterations or just the latest.\n                         Saving all iterations allows for additional plotting, but may take more memory. Defaults to True.\n    random_state: The random state ensures script reproducibility.\n                  Defaults to None.\n    inplace: If True, modify the input AnnData object in-place and return None.\n             If False, return a copy of the modified AnnData object. Default is False.\n    iterations: The number of iterations to run. Defaults to 5.\n    variable_parameters: Model parameters can be specified by variable here.\n                         Keys should be variable names or indices, and values should be a dict of parameter which should apply to that variable only.\n                         Defaults to None.\n    verbose: Whether to print information about the imputation process. Defaults to False.\n    copy: Whether to return a copy of the AnnData object or modify it in-place. Defaults to False.\n\nReturns:\n    The imputed AnnData object.\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.mice_forest_impute(adata)",
        "description": "Impute data using the miceforest.See https://github.com/AnotherSamWilson/miceforest\nFast, memory efficient Multiple Imputation by Chained Equations (MICE) with lightgbm.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.mice_forest_impute(adata)",
        "api_type": "function",
        "api_calling": [
            "ehrapy.preprocessing.mice_forest_impute(adata=$, var_names=@, warning_threshold=@, save_all_iterations=@, random_state=@, inplace=@, iterations=@, variable_parameters=@, verbose=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.plot.matrixplot": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "var_names": {
                "type": "Union[_VarNames, Mapping[str, _VarNames]]",
                "default": null,
                "optional": false,
                "description": "`var_names` should be a valid subset of `adata.var_names`.\nIf `var_names` is a mapping, then the key is used as label\nto group the values (see `var_group_labels`). The mapping values\nshould be sequences of valid `adata.var_names`. In this\ncase either coloring or 'brackets' are used for the grouping\nof var names depending on the plot. When `var_names` is a mapping,\nthen the `var_group_labels` and `var_group_positions` are set.",
                "optional_value": false
            },
            "groupby": {
                "type": "Union[str, Sequence[str]]",
                "default": null,
                "optional": false,
                "description": "The key of the observation grouping to consider.",
                "optional_value": false
            },
            "use_raw": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Use `raw` attribute of `adata` if present.",
                "optional_value": false
            },
            "log": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Plot on logarithmic axis.",
                "optional_value": false
            },
            "num_categories": {
                "type": "int",
                "default": "7",
                "optional": true,
                "description": "Only used if groupby observation is not categorical. This value\ndetermines the number of groups into which the groupby observation should be subdivided.",
                "optional_value": false
            },
            "figsize": {
                "type": "Optional[tuple[float, float]]",
                "default": "None",
                "optional": true,
                "description": "Figure size when `multi_panel=True`. Otherwise the `rcParam['figure.figsize]` value is used.\nFormat is (width, height)",
                "optional_value": false
            },
            "dendrogram": {
                "type": "Union[bool, str]",
                "default": "False",
                "optional": true,
                "description": "If True or a valid dendrogram key, a dendrogram based on the hierarchical\nclustering between the `groupby` categories is added.\nThe dendrogram information is computed using :func:`scanpy.tl.dendrogram`.\nIf `tl.dendrogram` has not been called previously the function is called with default parameters.",
                "optional_value": false
            },
            "title": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Title for the figure",
                "optional_value": false
            },
            "cmap": {
                "type": "Optional[str]",
                "default": "viridis",
                "optional": true,
                "description": "String denoting matplotlib color map.",
                "optional_value": false
            },
            "colorbar_title": {
                "type": "Optional[str]",
                "default": "Mean value\n in group",
                "optional": true,
                "description": "Title for the color bar. New line character (\\n) can be used.",
                "optional_value": false
            },
            "gene_symbols": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "var_group_positions": {
                "type": "Optional[Sequence[tuple[int, int]]]",
                "default": "None",
                "optional": true,
                "description": "Use this parameter to highlight groups of `var_names`.\nThis will draw a 'bracket' or a color block between the given start and end\npositions. If the parameter `var_group_labels` is set, the corresponding\nlabels are added on top/left. E.g. `var_group_positions=[(4,10)]`\nwill add a bracket between the fourth `var_name` and the tenth `var_name`.\nBy giving more positions, more brackets/color blocks are drawn.",
                "optional_value": false
            },
            "var_group_labels": {
                "type": "Optional[Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "Labels for each of the `var_group_positions` that want to be highlighted.",
                "optional_value": false
            },
            "var_group_rotation": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Label rotation degrees. By default, labels larger than 4 characters are rotated 90 degrees.",
                "optional_value": false
            },
            "layer": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Name of the AnnData object layer that wants to be plotted. By default adata.raw.X is plotted.\nIf `use_raw=False` is set, then `adata.X` is plotted. If `layer` is set to a valid layer name,\nthen the layer is plotted. `layer` takes precedence over `use_raw`.",
                "optional_value": false
            },
            "standard_scale": {
                "type": "Literal['var', 'group']",
                "default": "None",
                "optional": true,
                "description": "Whether or not to standardize the given dimension between 0 and 1, meaning for\neach variable or group, subtract the minimum and divide each by its maximum.",
                "optional_value": true
            },
            "values_df": {
                "type": "Optional[pd.DataFrame]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "swap_axes": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "By default, the x axis contains `var_names` (e.g. genes) and the y axis\nthe `groupby` categories. By setting `swap_axes` then x are the `groupby` categories and y the `var_names`.",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Whether to display the figure or return axis.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[str, bool]]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.",
                "optional_value": false
            },
            "ax": {
                "type": "Optional[_AxesSubplot]",
                "default": "None",
                "optional": true,
                "description": "A matplotlib axes object. Only works if plotting a single component.\nvmin: The value representing the lower limit of the color scale. Values smaller than vmin are plotted with the same color as vmin.",
                "optional_value": true
            },
            "return_fig": {
                "type": "Optional[bool]",
                "default": "False",
                "optional": true,
                "description": "Returns :class:`DotPlot` object. Useful for fine-tuning the plot. Takes precedence over `show=False`.",
                "optional_value": false
            },
            "vmin": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "vmax": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "The value representing the upper limit of the color scale. Values larger than vmax are plotted with the same color as vmax.",
                "optional_value": false
            },
            "vcenter": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "The value representing the center of the color scale. Useful for diverging colormaps.",
                "optional_value": false
            },
            "norm": {
                "type": "Optional[Normalize]",
                "default": "None",
                "optional": true,
                "description": "Custom color normalization object from matplotlib. See `https://matplotlib.org/stable/tutorials/colors/colormapnorms.html` for details.",
                "optional_value": true
            }
        },
        "Returns": {
            "type": "Optional[Union[MatrixPlot, dict]]",
            "description": ""
        },
        "Docstring": "Creates a heatmap of the mean count per group of each var_names.\n\nThis function provides a convenient interface to the :class:`~scanpy.pl.MatrixPlot`\nclass. If you need more flexibility, you should use :class:`~scanpy.pl.MatrixPlot` directly.\n\n\nArgs:\n    adata: Annotated data matrix.\n    var_names: `var_names` should be a valid subset of `adata.var_names`.\n               If `var_names` is a mapping, then the key is used as label\n               to group the values (see `var_group_labels`). The mapping values\n               should be sequences of valid `adata.var_names`. In this\n               case either coloring or 'brackets' are used for the grouping\n               of var names depending on the plot. When `var_names` is a mapping,\n               then the `var_group_labels` and `var_group_positions` are set.\n    groupby: The key of the observation grouping to consider.\n    use_raw: Use `raw` attribute of `adata` if present.\n    log: Plot on logarithmic axis.\n    num_categories: Only used if groupby observation is not categorical. This value\n                    determines the number of groups into which the groupby observation should be subdivided.\n    categories_order: Order in which to show the categories. Note: add_dendrogram or add_totals\n                      can change the categories order.\n    figsize: Figure size when `multi_panel=True`. Otherwise the `rcParam['figure.figsize]` value is used.\n             Format is (width, height)\n    dendrogram: If True or a valid dendrogram key, a dendrogram based on the hierarchical\n                clustering between the `groupby` categories is added.\n                The dendrogram information is computed using :func:`scanpy.tl.dendrogram`.\n                If `tl.dendrogram` has not been called previously the function is called with default parameters.\n    feature_symbols: Column name in `.var` DataFrame that stores feature symbols.\n                     By default `var_names` refer to the index column of the `.var` DataFrame.\n                     Setting this option allows alternative names to be used.\n    var_group_positions: Use this parameter to highlight groups of `var_names`.\n                         This will draw a 'bracket' or a color block between the given start and end\n                         positions. If the parameter `var_group_labels` is set, the corresponding\n                         labels are added on top/left. E.g. `var_group_positions=[(4,10)]`\n                         will add a bracket between the fourth `var_name` and the tenth `var_name`.\n                         By giving more positions, more brackets/color blocks are drawn.\n    var_group_labels: Labels for each of the `var_group_positions` that want to be highlighted.\n    var_group_rotation: Label rotation degrees. By default, labels larger than 4 characters are rotated 90 degrees.\n    layer: Name of the AnnData object layer that wants to be plotted. By default adata.raw.X is plotted.\n           If `use_raw=False` is set, then `adata.X` is plotted. If `layer` is set to a valid layer name,\n           then the layer is plotted. `layer` takes precedence over `use_raw`.\n    title: Title for the figure\n    colorbar_title: Title for the color bar. New line character (\\n) can be used.\n    cmap: String denoting matplotlib color map.\n    standard_scale: Whether or not to standardize the given dimension between 0 and 1, meaning for\n                    each variable or group, subtract the minimum and divide each by its maximum.\n    swap_axes: By default, the x axis contains `var_names` (e.g. genes) and the y axis\n         the `groupby` categories. By setting `swap_axes` then x are the `groupby` categories and y the `var_names`.\n    return_fig: Returns :class:`DotPlot` object. Useful for fine-tuning the plot. Takes precedence over `show=False`.\n    show: Whether to display the figure or return axis.\n    save: If `True` or a `str`, save the figure.\n          A string is appended to the default filename.\n          Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\n    ax: A matplotlib axes object. Only works if plotting a single component.\n            vmin: The value representing the lower limit of the color scale. Values smaller than vmin are plotted with the same color as vmin.\n    vmax: The value representing the upper limit of the color scale. Values larger than vmax are plotted with the same color as vmax.\n    vcenter: The value representing the center of the color scale. Useful for diverging colormaps.\n    norm: Custom color normalization object from matplotlib. See `https://matplotlib.org/stable/tutorials/colors/colormapnorms.html` for details.\n    kwds:\n        Are passed to :func:`matplotlib.pyplot.pcolor`.\n\nReturns:\n    If `return_fig` is `True`, returns a :class:`~scanpy.pl.MatrixPlot` object, else if `show` is false, return axes dict\n\nExample:\n    .. code-block:: python\n\n        import ehrapy as ep\n\n        adata = ep.dt.mimic_2(encoded=True)\n        ep.pp.knn_impute(adata)\n        ep.pp.log_norm(adata, offset=1)\n        ep.pp.neighbors(adata)\n        ep.tl.leiden(adata, resolution=0.5, key_added=\"leiden_0_5\")\n        ep.pl.matrixplot(\n            adata,\n            var_names=[\n                \"abg_count\",\n                \"wbc_first\",\n                \"hgb_first\",\n                \"platelet_first\",\n                \"sodium_first\",\n                \"potassium_first\",\n                \"tco2_first\",\n                \"chloride_first\",\n                \"bun_first\",\n                \"creatinine_first\",\n                \"po2_first\",\n                \"pco2_first\",\n                \"iv_day_1\",\n            ],\n            groupby=\"leiden_0_5\",\n        )\n\nPreview:\n    .. image:: /_static/docstring_previews/matrixplot.png",
        "description": "Creates a heatmap of the mean count per group of each var_names.This function provides a convenient interface to the :class:`~scanpy.pl.MatrixPlot`\nclass. If you need more flexibility, you should use :class:`~scanpy.pl.MatrixPlot` directly.",
        "example": ".. code-block:: python\n\n        import ehrapy as ep\n\n        adata = ep.dt.mimic_2(encoded=True)\n        ep.pp.knn_impute(adata)\n        ep.pp.log_norm(adata, offset=1)\n        ep.pp.neighbors(adata)\n        ep.tl.leiden(adata, resolution=0.5, key_added=\"leiden_0_5\")\n        ep.pl.matrixplot(\n            adata,\n            var_names=[\n                \"abg_count\",\n                \"wbc_first\",\n                \"hgb_first\",\n                \"platelet_first\",\n                \"sodium_first\",\n                \"potassium_first\",\n                \"tco2_first\",\n                \"chloride_first\",\n                \"bun_first\",\n                \"creatinine_first\",\n                \"po2_first\",\n                \"pco2_first\",\n                \"iv_day_1\",\n            ],\n            groupby=\"leiden_0_5\",\n        )\n\nPreview:\n    .. image:: /_static/docstring_previews/matrixplot.png",
        "api_type": "function",
        "api_calling": [
            "ehrapy.plot.matrixplot(adata=$, var_names=@, groupby=@, use_raw=@, log=@, num_categories=@, figsize=@, dendrogram=@, title=@, cmap=@, colorbar_title=@, gene_symbols=@, var_group_positions=@, var_group_labels=@, var_group_rotation=@, layer=@, standard_scale=$, values_df=$, swap_axes=@, show=@, save=@, ax=$, return_fig=@, vmin=@, vmax=@, vcenter=@, norm=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.plot.pca_overview": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object object containing all observations.",
                "optional_value": true
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Plot PCA results.\n\nThe parameters are the ones of the scatter plot. Call pca_ranking separately\nif you want to change the default settings.\n\nArgs:\n    adata: :class:`~anndata.AnnData` object object containing all observations.\n    sort_order: For continuous annotations used as color parameter, plot data points with higher values on top of others.\n    groups: Restrict to a few categories in categorical observation annotation.\n            The default is not to restrict to any groups.\n    components: For instance, `['1,2', '2,3']`. To plot all available components use `components='all'`.\n    projection: Projection of plot (default: `'2d'`).\n    legend_loc: Location of legend, either `'on data'`, `'right margin'` or a valid keyword for the `loc` parameter of :class:`~matplotlib.legend.Legend`.\n    legend_fontsize: Numeric size in pt or string describing the size. See :meth:`~matplotlib.text.Text.set_fontsize`.\n    legend_fontweight: Legend font weight. A numeric value in range 0-1000 or a string.\n                       Defaults to `'bold'` if `legend_loc == 'on data'`, otherwise to `'normal'`.\n                       See :meth:`~matplotlib.text.Text.set_fontweight`.\n    legend_fontoutline: Line width of the legend font outline in pt. Draws a white outline using the path effect :class:`~matplotlib.patheffects.withStroke`.\n    size: Point size. If `None`, is automatically computed as 120000 / n_features.\n          Can be a sequence containing the size for each observation. The order should be the same as in adata.obs.\n    color_map: Color map to use for continous variables. Can be a name or a\n               :class:`~matplotlib.colors.Colormap` instance (e.g. `\"magma`\", `\"viridis\"`\n               or `mpl.cm.cividis`), see :func:`~matplotlib.cm.get_cmap`.\n               If `None`, the value of `mpl.rcParams[\"image.cmap\"]` is used.\n               The default `color_map` can be set using :func:`~scanpy.set_figure_params`.\n    palette: Colors to use for plotting categorical annotation groups.\n             The palette can be a valid :class:`~matplotlib.colors.ListedColormap` name\n             (`'Set2'`, `'tab20'`, \u2026), a :class:`~cycler.Cycler` object, a dict mapping\n             categories to colors, or a sequence of colors. Colors must be valid to\n             matplotlib. (see :func:`~matplotlib.colors.is_color_like`).\n             If `None`, `mpl.rcParams[\"axes.prop_cycle\"]` is used unless the categorical\n             variable already has colors stored in `adata.uns[\"{var}_colors\"]`.\n             If provided, values of `adata.uns[\"{var}_colors\"]` will be set.\n    na_color: Color to use for null or masked values. Can be anything matplotlib accepts as a color.\n              Used for all points if `color=None`.\n    na_in_legend: If there are missing values, whether they get an entry in the legend.\n                  Currently only implemented for categorical legends.\n    frameon: Draw a frame around the scatter plot. Defaults to value set in :func:`~scanpy.set_figure_params` (default: True).\n    title: Provide title for panels either as string or list of strings, e.g. `['title1', 'title2', ...]`.\n    vmin: The value representing the lower limit of the color scale. Values smaller than vmin are plotted\n          with the same color as vmin. vmin can be a number, a string, a function or `None`. If\n          vmin is a string and has the format `pN`, this is interpreted as a vmin=percentile(N).\n          For example vmin='p1.5' is interpreted as the 1.5 percentile. If vmin is function, then\n          vmin is interpreted as the return value of the function over the list of values to plot.\n          For example to set vmin tp the mean of the values to plot, `def my_vmin(values): return\n          np.mean(values)` and then set `vmin=my_vmin`. If vmin is None (default) an automatic\n          minimum value is used as defined by matplotlib `scatter` function. When making multiple\n          plots, vmin can be a list of values, one for each plot. For example `vmin=[0.1, 'p1', None, my_vmin]`\n    vmax: The value representing the upper limit of the color scale. The format is the same as for `vmin`.\n    vcenter: The value representing the center of the color scale. Useful for diverging colormaps.\n             The format is the same as for `vmin`.\n             Example: sc.pl.umap(adata, color='TREM2', vcenter='p50', cmap='RdBu_r')\n    add_outline: If set to True, this will add a thin border around groups of dots. In some situations\n                 this can enhance the aesthetics of the resulting image\n    outline_color: Tuple with two valid color names used to adjust the add_outline. The first color is the\n                   border color (default: black), while the second color is a gap color between the\n                   border color and the scatter dot (default: white).\n    outline_width: Tuple with two width numbers used to adjust the outline. The first value is the width\n                   of the border color as a fraction of the scatter dot size (default: 0.3). The second value is\n                   width of the gap color (default: 0.05).\n    ncols: Number of panels per row.\n           wspace: Adjust the width of the space between multiple panels.\n           hspace: Adjust the height of the space between multiple panels.\n           return_fig: Return the matplotlib figure.\n    kwargs: Arguments to pass to :func:`matplotlib.pyplot.scatter`,\n            for instance: the maximum and minimum values (e.g. `vmin=-2, vmax=5`).\n    show: Whether to display the figure or return axis.\n    save: If `True` or a `str`, save the figure.\n          A string is appended to the default filename.\n          Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\n    ax: A matplotlib axes object. Only works if plotting a single component.\n    **params: Scatterplot parameters\n\nReturns:\n    If `show==False` a :class:`~matplotlib.axes.Axes` or a list of it.\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.knn_impute(adata)\n    >>> ep.pp.log_norm(adata, offset=1)\n    >>> ep.pp.neighbors(adata)\n    >>> ep.pp.pca(adata)\n    >>> ep.pl.pca_overview(adata, components='1,2,3', color=\"service_unit\")\n\nPreview:\n    .. image:: /_static/docstring_previews/pca_overview_1.png\n\n    .. image:: /_static/docstring_previews/pca_overview_2.png\n\n    .. image:: /_static/docstring_previews/pca_overview_3.png",
        "description": "Plot PCA results.The parameters are the ones of the scatter plot. Call pca_ranking separately\nif you want to change the default settings.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.knn_impute(adata)\n    >>> ep.pp.log_norm(adata, offset=1)\n    >>> ep.pp.neighbors(adata)\n    >>> ep.pp.pca(adata)\n    >>> ep.pl.pca_overview(adata, components='1,2,3', color=\"service_unit\")\n\nPreview:\n    .. image:: /_static/docstring_previews/pca_overview_1.png\n\n    .. image:: /_static/docstring_previews/pca_overview_2.png\n\n    .. image:: /_static/docstring_previews/pca_overview_3.png",
        "api_type": "function",
        "api_calling": [
            "ehrapy.plot.pca_overview(adata=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.data.parkinsons_telemonitoring": {
        "Parameters": {
            "encoded": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to return an already encoded object.",
                "optional_value": false
            },
            "columns_obs_only": {
                "type": "Optional[Union[dict[str, list[str]], list[str]]]",
                "default": "None",
                "optional": true,
                "description": "Columns to include in obs only and not X.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": ""
        },
        "Docstring": "Loads the Parkinsons Telemonitoring Data Set\n\nMore details: http://archive.ics.uci.edu/ml/datasets/Parkinsons+Telemonitoring\nPreprocessing: https://github.com/theislab/ehrapy-datasets/blob/main/parkinsons_telemonitoring/parkinsons_telemonitoring.ipynb\n\nArgs:\n    encoded: Whether to return an already encoded object.\n    columns_obs_only: Columns to include in obs only and not X.\n\nReturns:\n    :class:`~anndata.AnnData` object of the Parkinsons Telemonitoring Data Set\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.parkinsons_telemonitoring(encoded=True)",
        "description": "Loads the Parkinsons Telemonitoring Data SetMore details: http://archive.ics.uci.edu/ml/datasets/Parkinsons+Telemonitoring\nPreprocessing: https://github.com/theislab/ehrapy-datasets/blob/main/parkinsons_telemonitoring/parkinsons_telemonitoring.ipynb",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.parkinsons_telemonitoring(encoded=True)",
        "api_type": "function",
        "api_calling": [
            "ehrapy.data.parkinsons_telemonitoring(encoded=@, columns_obs_only=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.preprocessing.sqrt_norm": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object containing X to normalize values in.\nMust already be encoded using :func:`~ehrapy.preprocessing.encode`.",
                "optional_value": true
            },
            "vars": {
                "type": "Optional[Union[str, Sequence[str]]]",
                "default": "None",
                "optional": true,
                "description": "List of the names of the numeric variables to normalize.\nIf None all numeric variables will be normalized. Defaults to None .",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to return a copy or act in place. Defaults to False .",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[AnnData]",
            "description": ""
        },
        "Docstring": "Apply square root normalization.\n\nTake the square root of all values.\n\nArgs:\n    adata: :class:`~anndata.AnnData` object containing X to normalize values in.\n           Must already be encoded using :func:`~ehrapy.preprocessing.encode`.\n    vars: List of the names of the numeric variables to normalize.\n          If None all numeric variables will be normalized. Defaults to None .\n    copy: Whether to return a copy or act in place. Defaults to False .\n\nReturns:\n    :class:`~anndata.AnnData` object with normalized X.\n    Also stores a record of applied normalizations as a dictionary in adata.uns[\"normalization\"].\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> adata_norm = ep.pp.sqrt_norm(adata, copy=True)",
        "description": "Apply square root normalization.Take the square root of all values.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> adata_norm = ep.pp.sqrt_norm(adata, copy=True)",
        "api_type": "function",
        "api_calling": [
            "ehrapy.preprocessing.sqrt_norm(adata=$, vars=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.preprocessing.encode": {
        "Parameters": {
            "data": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "A :class:`~anndata.AnnData` object.",
                "optional_value": true
            },
            "autodetect": {
                "type": "Union[bool, dict]",
                "default": "False",
                "optional": true,
                "description": "Whether to autodetect categorical values that will be encoded.",
                "optional_value": false
            },
            "encodings": {
                "type": "Optional[Union[dict[str, dict[str, list[str]]], dict[str, list[str]], str]]",
                "default": "one-hot",
                "optional": true,
                "description": "Only needed if autodetect set to False.\nA dict containing the encoding mode and categorical name for the respective column\nor the specified encoding that will be applied to all columns.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": ""
        },
        "Docstring": "Encode categoricals of an :class:`~anndata.AnnData` object.\n\nCategorical values could be either passed via parameters or are autodetected on the fly.\nThe categorical values are also stored in obs and uns (for keeping the original, unencoded values).\nThe current encoding modes for each variable are also stored in uns (`var_to_encoding` key).\nVariable names in var are updated according to the encoding modes used. A variable name starting with `ehrapycat_`\nindicates an encoded column (or part of it).\n\nAutodetect mode:\n    This can be used for convenience and when there are many columns that need to be encoded.\n    Note that missing values do not influence the result.\n    By using this mode, every column that contains non-numerical values is encoded.\n    In addition, every binary column will be encoded too.\n    These are those columns which contain only 1's and 0's (could be either integers or floats).\n\nAvailable encodings are:\n    1. one-hot (https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html)\n    2. label (https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.LabelEncoder.html)\n    3. count (https://contrib.scikit-learn.org/category_encoders/count.html)\n    4. hash (https://contrib.scikit-learn.org/category_encoders/hashing.html)\n\nArgs:\n    data: A :class:`~anndata.AnnData` object.\n    autodetect: Whether to autodetect categorical values that will be encoded.\n    encodings: Only needed if autodetect set to False.\n               A dict containing the encoding mode and categorical name for the respective column\n               or the specified encoding that will be applied to all columns.\n\nReturns:\n    An :class:`~anndata.AnnData` object with the encoded values in X.\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2()\n    >>> # encode all autodetected (non numerical) columns using label encoding\n    >>> adata_encoded = ep.pp.encode(adata, autodetect=True)\n\n    >>> # Example using autodetect with non-default encoding mode:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2()\n    >>> # encode all auto-detected (non numerical) columns using one hot encoding\n    >>> adata_encoded = ep.pp.encode(adata, autodetect=True, encodings='one_hot_encoding')\n\n    >>> # Example using custom encodings per columns:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2()\n    >>> # encode col1 and col2 using label encoding and encode col3 using one hot encoding\n    >>> adata_encoded = ep.pp.encode(adata,\n    >>>                              autodetect=False,\n    >>>                              encodings={'label': ['col1', 'col2'], 'one-hot': ['col3']})",
        "description": "Encode categoricals of an :class:`~anndata.AnnData` object.Categorical values could be either passed via parameters or are autodetected on the fly.\nThe categorical values are also stored in obs and uns (for keeping the original, unencoded values).\nThe current encoding modes for each variable are also stored in uns (`var_to_encoding` key).\nVariable names in var are updated according to the encoding modes used. A variable name starting with `ehrapycat_`\nindicates an encoded column (or part of it).\n\nAutodetect mode:\n    This can be used for convenience and when there are many columns that need to be encoded.\n    Note that missing values do not influence the result.\n    By using this mode, every column that contains non-numerical values is encoded.\n    In addition, every binary column will be encoded too.\n    These are those columns which contain only 1's and 0's (could be either integers or floats).\n\nAvailable encodings are:\n    1. one-hot (https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html)\n    2. label (https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.LabelEncoder.html)\n    3. count (https://contrib.scikit-learn.org/category_encoders/count.html)\n    4. hash (https://contrib.scikit-learn.org/category_encoders/hashing.html)",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2()\n    >>> # encode all autodetected (non numerical) columns using label encoding\n    >>> adata_encoded = ep.pp.encode(adata, autodetect=True)\n\n    >>> # Example using autodetect with non-default encoding mode:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2()\n    >>> # encode all auto-detected (non numerical) columns using one hot encoding\n    >>> adata_encoded = ep.pp.encode(adata, autodetect=True, encodings='one_hot_encoding')\n\n    >>> # Example using custom encodings per columns:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2()\n    >>> # encode col1 and col2 using label encoding and encode col3 using one hot encoding\n    >>> adata_encoded = ep.pp.encode(adata,\n    >>>                              autodetect=False,\n    >>>                              encodings={'label': ['col1', 'col2'], 'one-hot': ['col3']})",
        "api_type": "function",
        "api_calling": [
            "ehrapy.preprocessing.encode(data=$, autodetect=@, encodings=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.tools.add_medcat_annotation_to_obs": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "AnnData object that holds the data to annotate.",
                "optional_value": true
            },
            "name": {
                "type": "Union[Iterable[str], str]",
                "default": null,
                "optional": false,
                "description": "Name of the entity to add as a column to obs.",
                "optional_value": false
            },
            "use_key": {
                "type": "str",
                "default": "medcat_annotations",
                "optional": true,
                "description": "Key to use for the annotated results.",
                "optional_value": false
            },
            "added_colname": {
                "type": "Optional[Union[Iterable[str], str]]",
                "default": "None",
                "optional": true,
                "description": "Name of the column to add to obs. If None, name will be used.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to copy adata or not.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[AnnData]",
            "description": ""
        },
        "Docstring": "Add info extracted from free text as a binary column to obs.\n\nIndicates whether the specific entity to color by has been found in that row or not.\n\n\nArgs:\n    adata: AnnData object that holds the data to annotate.\n    name: Name of the entity to add as a column to obs.\n    use_key: Key to use for the annotated results.\n    added_colname: Name of the column to add to obs. If None, name will be used.\n    copy: Whether to copy adata or not.\n\nReturns:\n    Returns `None` if `copy=False`, else returns an `AnnData` object. Sets the following fields;\n\n    `adata.obs[name | added_coname]` : :class:`pandas.DataFrame`\n        Added column(s) `to adata.obs`, indicating whether the specific entity to color by has been found in that row or not.",
        "description": "Add info extracted from free text as a binary column to obs.Indicates whether the specific entity to color by has been found in that row or not.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "ehrapy.tools.add_medcat_annotation_to_obs(adata=$, name=@, use_key=@, added_colname=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.tools.umap": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object object containing all observations.",
                "optional_value": true
            },
            "min_dist": {
                "type": "float",
                "default": "0.5",
                "optional": true,
                "description": "The effective minimum distance between embedded points. Smaller values\nwill result in a more clustered/clumped embedding where nearby points on\nthe manifold are drawn closer together, while larger values will result\non a more even dispersal of points. The value should be set relative to\nthe ``spread`` value, which determines the scale at which embedded\npoints will be spread out. The default of in the `umap-learn` package is 0.1.",
                "optional_value": false
            },
            "spread": {
                "type": "float",
                "default": "1.0",
                "optional": true,
                "description": "The effective scale of embedded points.\nIn combination with `min_dist` this determines how clustered/clumped the embedded points are.",
                "optional_value": false
            },
            "n_components": {
                "type": "int",
                "default": "2",
                "optional": true,
                "description": "The number of dimensions of the embedding.",
                "optional_value": false
            },
            "maxiter": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "The number of iterations (epochs) of the optimization. Called `n_epochs` in the original UMAP.",
                "optional_value": false
            },
            "alpha": {
                "type": "float",
                "default": "1.0",
                "optional": true,
                "description": "The initial learning rate for the embedding optimization.",
                "optional_value": false
            },
            "gamma": {
                "type": "float",
                "default": "1.0",
                "optional": true,
                "description": "Weighting applied to negative samples in low dimensional embedding optimization.\nValues higher than one will result in greater weight being given to negative samples.",
                "optional_value": false
            },
            "negative_sample_rate": {
                "type": "int",
                "default": "5",
                "optional": true,
                "description": "The number of negative edge/1-simplex samples to use per positive\nedge/1-simplex sample in optimizing the low dimensional embedding.",
                "optional_value": false
            },
            "init_pos": {
                "type": "Optional[Union[Literal[paga, spectral, random], ndarray]]",
                "default": "spectral",
                "optional": true,
                "description": "How to initialize the low dimensional embedding. Called `init` in the original UMAP. Options are:\n* Any key for `adata.obsm`.\n\n* 'paga': positions from :func:`~scanpy.pl.paga`.\n\n* 'spectral': use a spectral embedding of the graph.\n\n* 'random': assign initial embedding positions at random.\n\n* A numpy array of initial embedding positions.",
                "optional_value": true
            },
            "random_state": {
                "type": "Optional[Union[int, RandomState]]",
                "default": "0",
                "optional": true,
                "description": "Random state for the initialization.\n* If `int`, `random_state` is the seed used by the random number generator;\n\n* If `RandomState` or `Generator`, `random_state` is the random number generator;\n\n* If `None`, the random number generator is the `RandomState` instance used by `np.random`.",
                "optional_value": false
            },
            "a": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "More specific parameters controlling the embedding.\nIf `None` these values are set automatically as determined by `min_dist` and `spread`.",
                "optional_value": false
            },
            "b": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "More specific parameters controlling the embedding.\nIf `None` these values are set automatically as determined by `min_dist` and `spread`.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Return a copy instead of writing to adata.",
                "optional_value": false
            },
            "method": {
                "type": "Literal[umap, rapids]",
                "default": "umap",
                "optional": true,
                "description": "Use the original 'umap' implementation, or 'rapids' (experimental, GPU only)",
                "optional_value": true
            },
            "neighbors_key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "If not specified, umap looks .uns['neighbors'] for neighbors settings\nand .obsp['connectivities'] for connectivities (default storage places for pp.neighbors).\nIf specified, umap looks .uns[neighbors_key] for neighbors settings and\n.obsp[.uns[neighbors_key]['connectivities_key']] for connectivities.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[AnnData]",
            "description": ""
        },
        "Docstring": "Embed the neighborhood graph using UMAP [McInnes18]_.\n\nUMAP (Uniform Manifold Approximation and Projection) is a manifold learning\ntechnique suitable for visualizing high-dimensional data. Besides tending to\nbe faster than tSNE, it optimizes the embedding such that it best reflects\nthe topology of the data, which we represent throughout ehrapy using a\nneighborhood graph. tSNE, by contrast, optimizes the distribution of\nnearest-neighbor distances in the embedding such that these best match the\ndistribution of distances in the high-dimensional space. We use the\nimplementation of `umap-learn <https://github.com/lmcinnes/umap>`__\n[McInnes18]_. For a few comparisons of UMAP with tSNE, see this `preprint\n<https://doi.org/10.1101/298430>`__.\n\nArgs:\n    adata: :class:`~anndata.AnnData` object object containing all observations.\n    min_dist: The effective minimum distance between embedded points. Smaller values\n              will result in a more clustered/clumped embedding where nearby points on\n              the manifold are drawn closer together, while larger values will result\n              on a more even dispersal of points. The value should be set relative to\n              the ``spread`` value, which determines the scale at which embedded\n              points will be spread out. The default of in the `umap-learn` package is 0.1.\n    spread: The effective scale of embedded points.\n            In combination with `min_dist` this determines how clustered/clumped the embedded points are.\n    n_components: The number of dimensions of the embedding.\n    maxiter: The number of iterations (epochs) of the optimization. Called `n_epochs` in the original UMAP.\n    alpha: The initial learning rate for the embedding optimization.\n    gamma: Weighting applied to negative samples in low dimensional embedding optimization.\n           Values higher than one will result in greater weight being given to negative samples.\n    negative_sample_rate: The number of negative edge/1-simplex samples to use per positive\n                          edge/1-simplex sample in optimizing the low dimensional embedding.\n    init_pos: How to initialize the low dimensional embedding. Called `init` in the original UMAP. Options are:\n\n              * Any key for `adata.obsm`.\n\n              * 'paga': positions from :func:`~scanpy.pl.paga`.\n\n              * 'spectral': use a spectral embedding of the graph.\n\n              * 'random': assign initial embedding positions at random.\n\n              * A numpy array of initial embedding positions.\n    random_state: Random state for the initialization.\n\n                  * If `int`, `random_state` is the seed used by the random number generator;\n\n                  * If `RandomState` or `Generator`, `random_state` is the random number generator;\n\n                  * If `None`, the random number generator is the `RandomState` instance used by `np.random`.\n    a: More specific parameters controlling the embedding.\n       If `None` these values are set automatically as determined by `min_dist` and `spread`.\n    b: More specific parameters controlling the embedding.\n       If `None` these values are set automatically as determined by `min_dist` and `spread`.\n    copy: Return a copy instead of writing to adata.\n    method: Use the original 'umap' implementation, or 'rapids' (experimental, GPU only)\n    neighbors_key: If not specified, umap looks .uns['neighbors'] for neighbors settings\n                   and .obsp['connectivities'] for connectivities (default storage places for pp.neighbors).\n                   If specified, umap looks .uns[neighbors_key] for neighbors settings and\n                   .obsp[.uns[neighbors_key]['connectivities_key']] for connectivities.\n\nReturns:\n    Depending on `copy`, returns or updates `adata` with the following fields.\n\n    **X_umap** : `adata.obsm` field UMAP coordinates of data.",
        "description": "Embed the neighborhood graph using UMAP [McInnes18]_.UMAP (Uniform Manifold Approximation and Projection) is a manifold learning\ntechnique suitable for visualizing high-dimensional data. Besides tending to\nbe faster than tSNE, it optimizes the embedding such that it best reflects\nthe topology of the data, which we represent throughout ehrapy using a\nneighborhood graph. tSNE, by contrast, optimizes the distribution of\nnearest-neighbor distances in the embedding such that these best match the\ndistribution of distances in the high-dimensional space. We use the\nimplementation of `umap-learn <https://github.com/lmcinnes/umap>`__\n[McInnes18]_. For a few comparisons of UMAP with tSNE, see this `preprint\n<https://doi.org/10.1101/298430>`__.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "ehrapy.tools.umap(adata=$, min_dist=@, spread=@, n_components=@, maxiter=@, alpha=@, gamma=@, negative_sample_rate=@, init_pos=$, random_state=@, a=@, b=@, copy=@, method=$, neighbors_key=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.plot.ranking": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object object containing all observations.",
                "optional_value": true
            },
            "attr": {
                "type": "Literal['var', 'obs', 'uns', 'varm', 'obsm']",
                "default": null,
                "optional": false,
                "description": "The attribute of AnnData that contains the score.",
                "optional_value": true
            },
            "keys": {
                "type": "Union[str, Sequence[str]]",
                "default": null,
                "optional": false,
                "description": "The scores to look up an array from the attribute of adata.",
                "optional_value": false
            },
            "dictionary": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "Optional key dictionary.",
                "optional_value": true
            },
            "indices": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "Optional dictionary indices.",
                "optional_value": true
            },
            "labels": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "Optional labels.",
                "optional_value": true
            },
            "color": {
                "type": null,
                "default": "black",
                "optional": true,
                "description": "Optional primary color (default: black).",
                "optional_value": true
            },
            "n_points": {
                "type": null,
                "default": "30",
                "optional": true,
                "description": "Number of points (default: 30)..",
                "optional_value": true
            },
            "log": {
                "type": null,
                "default": "False",
                "optional": true,
                "description": "Whether logarithmic scale should be used.",
                "optional_value": true
            },
            "include_lowest": {
                "type": null,
                "default": "False",
                "optional": true,
                "description": "Whether to include the lowest points.",
                "optional_value": true
            },
            "show": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "Whether to show the plot.",
                "optional_value": true
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Plot rankings.\n\nSee, for example, how this is used in pl.pca_loadings.\n\nArgs:\n    adata: :class:`~anndata.AnnData` object object containing all observations.\n    attr: The attribute of AnnData that contains the score.\n    keys: The scores to look up an array from the attribute of adata.\n    dictionary: Optional key dictionary.\n    indices: Optional dictionary indices.\n    labels: Optional labels.\n    color: Optional primary color (default: black).\n    n_points: Number of points (default: 30)..\n    log: Whether logarithmic scale should be used.\n    include_lowest: Whether to include the lowest points.\n    show: Whether to show the plot.\n\nReturns:\n    Returns matplotlib gridspec with access to the axes.\n\nExample:\n    .. code-block:: python\n\n        import ehrapy as ep\n\n        adata = ep.dt.mimic_2(encoded=True)\n        ep.pp.knn_impute(adata)\n        ep.pp.log_norm(adata, offset=1)\n        ep.pp.neighbors(adata)\n        ep.pp.pca(adata)\n        TODO: ep.pl.ranking(adata)",
        "description": "Plot rankings.See, for example, how this is used in pl.pca_loadings.",
        "example": ".. code-block:: python\n\n        import ehrapy as ep\n\n        adata = ep.dt.mimic_2(encoded=True)\n        ep.pp.knn_impute(adata)\n        ep.pp.log_norm(adata, offset=1)\n        ep.pp.neighbors(adata)\n        ep.pp.pca(adata)\n        TODO: ep.pl.ranking(adata)",
        "api_type": "function",
        "api_calling": [
            "ehrapy.plot.ranking(adata=$, attr=$, keys=@, dictionary=$, indices=$, labels=$, color=$, n_points=$, log=$, include_lowest=$, show=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.tools.rank_features_groups": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "groupby": {
                "type": "str",
                "default": null,
                "optional": false,
                "description": "The key of the observations grouping to consider.",
                "optional_value": false
            },
            "groups": {
                "type": "Union[Literal['all'], Iterable[str]]",
                "default": "all",
                "optional": true,
                "description": "Subset of groups, e.g. [`'g1'`, `'g2'`, `'g3'`], to which comparison\nshall be restricted, or `'all'` (default), for all groups.",
                "optional_value": false
            },
            "reference": {
                "type": "str",
                "default": "rest",
                "optional": true,
                "description": "If `'rest'`, compare each group to the union of the rest of the group.\nIf a group identifier, compare with respect to this group.",
                "optional_value": false
            },
            "n_features": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "The number of features that appear in the returned tables. Defaults to all features.",
                "optional_value": false
            },
            "rankby_abs": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Rank genes by the absolute value of the score, not by the score.\nThe returned scores are never the absolute values.",
                "optional_value": false
            },
            "pts": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Compute the fraction of observations containing the features.",
                "optional_value": false
            },
            "key_added": {
                "type": "Optional[str]",
                "default": "rank_features_groups",
                "optional": true,
                "description": "The key in `adata.uns` information is saved to.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to return a copy of the AnnData object.",
                "optional_value": false
            },
            "num_cols_method": {
                "type": "_method_options._rank_features_groups_method",
                "default": "None",
                "optional": true,
                "description": "Statistical method to rank numerical features. The default method is `'t-test'`,\n`'t-test_overestim_var'` overestimates variance of each group,\n`'wilcoxon'` uses Wilcoxon rank-sum,\n`'logreg'` uses logistic regression.",
                "optional_value": true
            },
            "cat_cols_method": {
                "type": "_method_options._rank_features_groups_cat_method",
                "default": "g-test",
                "optional": true,
                "description": "Statistical method to calculate differences between categorical features. The default method is `'g-test'`,\n`'Chi-square'` tests goodness-of-fit test for categorical data,\n`'Freeman-Tukey'` tests comparing frequency distributions,\n`'Mod-log-likelihood'` maximum likelihood estimation,\n`'Neyman'` tests hypotheses using asymptotic theory,\n`'Cressie-Read'` is a generalized likelihood test,",
                "optional_value": true
            },
            "correction_method": {
                "type": "_method_options._correction_method",
                "default": "benjamini-hochberg",
                "optional": true,
                "description": "p-value correction method.\nUsed only for statistical tests (e.g. doesn't work for \"logreg\" `num_cols_method`)",
                "optional_value": true
            },
            "tie_correct": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Use tie correction for `'wilcoxon'` scores. Used only for `'wilcoxon'`.",
                "optional_value": false
            },
            "layer": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Key from `adata.layers` whose value will be used to perform tests on.",
                "optional_value": false
            },
            "field_to_rank": {
                "type": "Union[Literal['layer'], Literal['obs'], Literal['layer_and_obs']]",
                "default": "layer",
                "optional": true,
                "description": "Set to `layer` to rank variables in `adata.X` or `adata.layers[layer]` (default), `obs` to rank `adata.obs`, or `layer_and_obs` to rank both.\nLayer needs to be None if this is not 'layer'.",
                "optional_value": true
            },
            "columns_to_rank": {
                "type": "Union[dict[str, Iterable[str]], Literal['all']]",
                "default": "all",
                "optional": true,
                "description": "Subset of columns to rank. If 'all', all columns are used.\nIf a dictionary, it must have keys 'var_names' and/or 'obs_names' and values must be iterables of strings\nsuch as {'var_names': ['glucose'], 'obs_names': ['age', 'height']}.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Rank features for characterizing groups.\n\nExpects logarithmized data.\n\nArgs:\n    adata: Annotated data matrix.\n    groupby: The key of the observations grouping to consider.\n    groups: Subset of groups, e.g. [`'g1'`, `'g2'`, `'g3'`], to which comparison\n            shall be restricted, or `'all'` (default), for all groups.\n    reference: If `'rest'`, compare each group to the union of the rest of the group.\n               If a group identifier, compare with respect to this group.\n    n_features: The number of features that appear in the returned tables. Defaults to all features.\n    rankby_abs: Rank genes by the absolute value of the score, not by the score.\n                The returned scores are never the absolute values.\n    pts: Compute the fraction of observations containing the features.\n    key_added: The key in `adata.uns` information is saved to.\n    copy: Whether to return a copy of the AnnData object.\n    num_cols_method:  Statistical method to rank numerical features. The default method is `'t-test'`,\n                      `'t-test_overestim_var'` overestimates variance of each group,\n                      `'wilcoxon'` uses Wilcoxon rank-sum,\n                      `'logreg'` uses logistic regression.\n    cat_cols_method: Statistical method to calculate differences between categorical features. The default method is `'g-test'`,\n                         `'Chi-square'` tests goodness-of-fit test for categorical data,\n                         `'Freeman-Tukey'` tests comparing frequency distributions,\n                         `'Mod-log-likelihood'` maximum likelihood estimation,\n                         `'Neyman'` tests hypotheses using asymptotic theory,\n                         `'Cressie-Read'` is a generalized likelihood test,\n    correction_method:  p-value correction method.\n                        Used only for statistical tests (e.g. doesn't work for \"logreg\" `num_cols_method`)\n    tie_correct: Use tie correction for `'wilcoxon'` scores. Used only for `'wilcoxon'`.\n    layer: Key from `adata.layers` whose value will be used to perform tests on.\n    field_to_rank: Set to `layer` to rank variables in `adata.X` or `adata.layers[layer]` (default), `obs` to rank `adata.obs`, or `layer_and_obs` to rank both.\n                   Layer needs to be None if this is not 'layer'.\n    columns_to_rank: Subset of columns to rank. If 'all', all columns are used.\n                     If a dictionary, it must have keys 'var_names' and/or 'obs_names' and values must be iterables of strings\n                     such as {'var_names': ['glucose'], 'obs_names': ['age', 'height']}.\n    **kwds: Are passed to test methods. Currently this affects only parameters that\n            are passed to :class:`sklearn.linear_model.LogisticRegression`.\n            For instance, you can pass `penalty='l1'` to try to come up with a\n            minimal set of genes that are good predictors (sparse solution meaning few non-zero fitted coefficients).\n\nReturns:\n    *names* structured `np.ndarray` (`.uns['rank_features_groups']`)\n              Structured array to be indexed by group id storing the gene\n              names. Ordered according to scores.\n    *scores* structured `np.ndarray` (`.uns['rank_features_groups']`)\n              Structured array to be indexed by group id storing the z-score\n              underlying the computation of a p-value for each gene for each group.\n              Ordered according to scores.\n    *logfoldchanges* structured `np.ndarray` (`.uns['rank_features_groups']`)\n                      Structured array to be indexed by group id storing the log2\n                      fold change for each gene for each group. Ordered according to scores.\n                      Only provided if method is 't-test' like.\n                      Note: this is an approximation calculated from mean-log values.\n    *pvals* structured `np.ndarray` (`.uns['rank_features_groups']`) p-values.\n    *pvals_adj* structured `np.ndarray` (`.uns['rank_features_groups']`) Corrected p-values.\n    *pts*: `pandas.DataFrame` (`.uns['rank_features_groups']`)\n           Fraction of cells expressing the genes for each group.\n    *pts_rest* `pandas.DataFrame` (`.uns['rank_features_groups']`)\n                Only if `reference` is set to `'rest'`.\n                Fraction of observations from the union of the rest of each group containing the features.\n\n Examples:\n     >>> import ehrapy as ep\n     >>> adata = ep.dt.mimic_2(encoded=False)\n     >>> # want to move some metadata to the obs field\n     >>> ep.anndata.move_to_obs(adata, to_obs=[\"service_unit\", \"service_num\", \"age\", \"mort_day_censored\"])\n     >>> ep.tl.rank_features_groups(adata, \"service_unit\")\n     >>> ep.pl.rank_features_groups(adata)\n\n     >>> import ehrapy as ep\n     >>> adata = ep.dt.mimic_2(encoded=False)\n     >>> # want to move some metadata to the obs field\n     >>> ep.anndata.move_to_obs(adata, to_obs=[\"service_unit\", \"service_num\", \"age\", \"mort_day_censored\"])\n     >>> ep.tl.rank_features_groups(adata, \"service_unit\", field_to_rank=\"obs\", columns_to_rank={\"obs_names\": [\"age\", \"mort_day_censored\"]})\n     >>> ep.pl.rank_features_groups(adata)\n\n     >>> import ehrapy as ep\n     >>> adata = ep.dt.mimic_2(encoded=False)\n     >>> # want to move some metadata to the obs field\n     >>> ep.anndata.move_to_obs(adata, to_obs=[\"service_unit\", \"service_num\", \"age\", \"mort_day_censored\"])\n     >>> ep.tl.rank_features_groups(adata, \"service_unit\", field_to_rank=\"layer_and_obs\", columns_to_rank={\"var_names\": ['copd_flg', 'renal_flg'], \"obs_names\": [\"age\", \"mort_day_censored\"]})\n     >>> ep.pl.rank_features_groups(adata)",
        "description": "Rank features for characterizing groups.Expects logarithmized data.",
        "example": ">>> import ehrapy as ep\n     >>> adata = ep.dt.mimic_2(encoded=False)\n     >>> # want to move some metadata to the obs field\n     >>> ep.anndata.move_to_obs(adata, to_obs=[\"service_unit\", \"service_num\", \"age\", \"mort_day_censored\"])\n     >>> ep.tl.rank_features_groups(adata, \"service_unit\")\n     >>> ep.pl.rank_features_groups(adata)\n\n     >>> import ehrapy as ep\n     >>> adata = ep.dt.mimic_2(encoded=False)\n     >>> # want to move some metadata to the obs field\n     >>> ep.anndata.move_to_obs(adata, to_obs=[\"service_unit\", \"service_num\", \"age\", \"mort_day_censored\"])\n     >>> ep.tl.rank_features_groups(adata, \"service_unit\", field_to_rank=\"obs\", columns_to_rank={\"obs_names\": [\"age\", \"mort_day_censored\"]})\n     >>> ep.pl.rank_features_groups(adata)\n\n     >>> import ehrapy as ep\n     >>> adata = ep.dt.mimic_2(encoded=False)\n     >>> # want to move some metadata to the obs field\n     >>> ep.anndata.move_to_obs(adata, to_obs=[\"service_unit\", \"service_num\", \"age\", \"mort_day_censored\"])\n     >>> ep.tl.rank_features_groups(adata, \"service_unit\", field_to_rank=\"layer_and_obs\", columns_to_rank={\"var_names\": ['copd_flg', 'renal_flg'], \"obs_names\": [\"age\", \"mort_day_censored\"]})\n     >>> ep.pl.rank_features_groups(adata)",
        "api_type": "function",
        "api_calling": [
            "ehrapy.tools.rank_features_groups(adata=$, groupby=@, groups=@, reference=@, n_features=@, rankby_abs=@, pts=@, key_added=@, copy=@, num_cols_method=$, cat_cols_method=$, correction_method=$, tie_correct=@, layer=@, field_to_rank=$, columns_to_rank=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.plot.dpt_timeseries": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object object containing all observations.",
                "optional_value": true
            },
            "color_map": {
                "type": "Union[str, Colormap]",
                "default": "None",
                "optional": true,
                "description": "Matplotlib Colormap",
                "optional_value": false
            },
            "as_heatmap": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to render the plot a heatmap",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Whether to show the plot.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Whether to save the plot or a path to save the plot.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Heatmap of pseudotime series.\n\nArgs:\n    adata: :class:`~anndata.AnnData` object object containing all observations.\n    color_map: Matplotlib Colormap\n    as_heatmap: Whether to render the plot a heatmap\n    show: Whether to show the plot.\n    save: Whether to save the plot or a path to save the plot.\n\nExamples:\n    >>> import ehrapy as ep\n    >>> import numpy as np\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.knn_impute(adata)\n    >>> ep.pp.log_norm(adata, offset=1)\n    >>> ep.pp.neighbors(adata, method='gauss')\n    >>> ep.tl.leiden(adata, resolution=0.5, key_added=\"leiden_0_5\")\n    >>> ep.tl.diffmap(adata, n_comps=10)\n    >>> adata.uns['iroot'] = np.flatnonzero(adata.obs['leiden_0_5'] == '0')[0]\n    >>> ep.tl.dpt(adata, n_branchings=3)\n    >>> ep.pl.dpt_timeseries(adata)\n\nPreview:\n    .. image:: /_static/docstring_previews/dpt_timeseries.png",
        "description": "Heatmap of pseudotime series.",
        "example": ">>> import ehrapy as ep\n    >>> import numpy as np\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.knn_impute(adata)\n    >>> ep.pp.log_norm(adata, offset=1)\n    >>> ep.pp.neighbors(adata, method='gauss')\n    >>> ep.tl.leiden(adata, resolution=0.5, key_added=\"leiden_0_5\")\n    >>> ep.tl.diffmap(adata, n_comps=10)\n    >>> adata.uns['iroot'] = np.flatnonzero(adata.obs['leiden_0_5'] == '0')[0]\n    >>> ep.tl.dpt(adata, n_branchings=3)\n    >>> ep.pl.dpt_timeseries(adata)\n\nPreview:\n    .. image:: /_static/docstring_previews/dpt_timeseries.png",
        "api_type": "function",
        "api_calling": [
            "ehrapy.plot.dpt_timeseries(adata=$, color_map=@, as_heatmap=@, show=@, save=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.tools.leiden": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object object containing all observations.",
                "optional_value": true
            },
            "resolution": {
                "type": "float",
                "default": "1",
                "optional": true,
                "description": "A parameter value controlling the coarseness of the clustering. Higher values lead to more clusters.\nSet to `None` if overriding `partition_type` to one that doesn\u2019t accept a `resolution_parameter`.",
                "optional_value": false
            },
            "restrict_to": {
                "type": "Optional[tuple[str, Sequence[str]]]",
                "default": "None",
                "optional": true,
                "description": "Restrict the clustering to the categories within the key for sample\nannotation, tuple needs to contain `(obs_key, list_of_categories)`.",
                "optional_value": false
            },
            "random_state": {
                "type": "Optional[Union[int, RandomState]]",
                "default": "0",
                "optional": true,
                "description": "Random seed of the initialization of the optimization.",
                "optional_value": false
            },
            "key_added": {
                "type": "str",
                "default": "leiden",
                "optional": true,
                "description": "`adata.obs` key under which to add the cluster labels.",
                "optional_value": false
            },
            "adjacency": {
                "type": "Optional[spmatrix]",
                "default": "None",
                "optional": true,
                "description": "Sparse adjacency matrix of the graph, defaults to neighbors connectivities.",
                "optional_value": true
            },
            "directed": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to treat the graph as directed or undirected.",
                "optional_value": false
            },
            "use_weights": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "If `True`, edge weights from the graph are used in the computation\n(placing more emphasis on stronger edges).",
                "optional_value": false
            },
            "n_iterations": {
                "type": "int",
                "default": "-1",
                "optional": true,
                "description": "How many iterations of the Leiden clustering algorithm to perform.\nPositive values above 2 define the total number of iterations to perform,\n-1 has the algorithm run until it reaches its optimal clustering.",
                "optional_value": false
            },
            "partition_type": {
                "type": "Optional[type[MutableVertexPartition]]",
                "default": "None",
                "optional": true,
                "description": "Type of partition to use.\nDefaults to :class:`~leidenalg.RBConfigurationVertexPartition`.\nFor the available options, consult the documentation for\n:func:`~leidenalg.find_partition`.",
                "optional_value": true
            },
            "neighbors_key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Use neighbors connectivities as adjacency.\nIf not specified, leiden looks .obsp['connectivities'] for connectivities\n(default storage place for pp.neighbors).\nIf specified, leiden looks .obsp[.uns[neighbors_key]['connectivities_key']] for connectivities.",
                "optional_value": false
            },
            "obsp": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Use .obsp[obsp] as adjacency. You can't specify both `obsp` and `neighbors_key` at the same time.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to copy `adata` or modify it inplace.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[AnnData]",
            "description": ""
        },
        "Docstring": "Cluster observations into subgroups [Traag18]_.\n\nCluster observations using the Leiden algorithm [Traag18]_,\nan improved version of the Louvain algorithm [Blondel08]_.\nIt has been proposed for single-cell analysis by [Levine15]_.\nThis requires having ran :func:`~ehrapy.pp.neighbors` or :func:`~ehrapy.pp.bbknn` first.\n\nArgs:\n    adata: :class:`~anndata.AnnData` object object containing all observations.\n    resolution: A parameter value controlling the coarseness of the clustering. Higher values lead to more clusters.\n                Set to `None` if overriding `partition_type` to one that doesn\u2019t accept a `resolution_parameter`.\n    restrict_to: Restrict the clustering to the categories within the key for sample\n                 annotation, tuple needs to contain `(obs_key, list_of_categories)`.\n    random_state: Random seed of the initialization of the optimization.\n    key_added: `adata.obs` key under which to add the cluster labels.\n    adjacency: Sparse adjacency matrix of the graph, defaults to neighbors connectivities.\n    directed: Whether to treat the graph as directed or undirected.\n    use_weights: If `True`, edge weights from the graph are used in the computation\n                 (placing more emphasis on stronger edges).\n    n_iterations: How many iterations of the Leiden clustering algorithm to perform.\n                  Positive values above 2 define the total number of iterations to perform,\n                  -1 has the algorithm run until it reaches its optimal clustering.\n    partition_type: Type of partition to use.\n                    Defaults to :class:`~leidenalg.RBConfigurationVertexPartition`.\n                    For the available options, consult the documentation for\n                    :func:`~leidenalg.find_partition`.\n    neighbors_key: Use neighbors connectivities as adjacency.\n                   If not specified, leiden looks .obsp['connectivities'] for connectivities\n                   (default storage place for pp.neighbors).\n                   If specified, leiden looks .obsp[.uns[neighbors_key]['connectivities_key']] for connectivities.\n    obsp: Use .obsp[obsp] as adjacency. You can't specify both `obsp` and `neighbors_key` at the same time.\n    copy: Whether to copy `adata` or modify it inplace.\n    **partition_kwargs: Any further arguments to pass to `~leidenalg.find_partition`\n                        (which in turn passes arguments to the `partition_type`).\n\nReturns:\n    `adata.obs[key_added]`\n    Array of dim (number of samples) that stores the subgroup id (`'0'`, `'1'`, ...) for each cell.\n\n    `adata.uns['leiden']['params']`\n    A dict with the values for the parameters `resolution`, `random_state`, and `n_iterations`.",
        "description": "Cluster observations into subgroups [Traag18]_.Cluster observations using the Leiden algorithm [Traag18]_,\nan improved version of the Louvain algorithm [Blondel08]_.\nIt has been proposed for single-cell analysis by [Levine15]_.\nThis requires having ran :func:`~ehrapy.pp.neighbors` or :func:`~ehrapy.pp.bbknn` first.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "ehrapy.tools.leiden(adata=$, resolution=@, restrict_to=@, random_state=@, key_added=@, adjacency=$, directed=@, use_weights=@, n_iterations=@, partition_type=$, neighbors_key=@, obsp=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.plot.kmf": {
        "Parameters": {
            "kmfs": {
                "type": "Sequence[KaplanMeierFitter]",
                "default": "None",
                "optional": true,
                "description": "Iterables of fitted KaplanMeierFitter objects.",
                "optional_value": true
            },
            "ci_alpha": {
                "type": "Optional[list[float]]",
                "default": "None",
                "optional": true,
                "description": "The transparency level of the confidence interval. If more than one kmfs, this should be a list. Defaults to 0.3.",
                "optional_value": false
            },
            "ci_force_lines": {
                "type": "Optional[list[Boolean]]",
                "default": "None",
                "optional": true,
                "description": "Force the confidence intervals to be line plots (versus default shaded areas).\nIf more than one kmfs, this should be a list. Defaults to False .",
                "optional_value": false
            },
            "ci_show": {
                "type": "Optional[list[Boolean]]",
                "default": "None",
                "optional": true,
                "description": "Show confidence intervals. If more than one kmfs, this should be a list. Defaults to True .",
                "optional_value": false
            },
            "ci_legend": {
                "type": "Optional[list[Boolean]]",
                "default": "None",
                "optional": true,
                "description": "If ci_force_lines is True, this is a boolean flag to add the lines' labels to the legend.\nIf more than one kmfs, this should be a list. Defaults to False .",
                "optional_value": false
            },
            "at_risk_counts": {
                "type": "Optional[list[Boolean]]",
                "default": "None",
                "optional": true,
                "description": "Show group sizes at time points. If more than one kmfs, this should be a list. Defaults to False.",
                "optional_value": false
            },
            "color": {
                "type": "Optional[list[str]]",
                "default": "None",
                "optional": true,
                "description": "List of colors for each kmf. If more than one kmfs, this should be a list.",
                "optional_value": false
            },
            "grid": {
                "type": "Optional[Boolean]",
                "default": "False",
                "optional": true,
                "description": "If True, plot grid lines.",
                "optional_value": true
            },
            "xlim": {
                "type": "Optional[tuple[float, float]]",
                "default": "None",
                "optional": true,
                "description": "Set the x-axis view limits.",
                "optional_value": false
            },
            "ylim": {
                "type": "Optional[tuple[float, float]]",
                "default": "None",
                "optional": true,
                "description": "Set the y-axis view limits.",
                "optional_value": false
            },
            "xlabel": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "The x-axis label text.",
                "optional_value": false
            },
            "ylabel": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "The y-axis label text.",
                "optional_value": false
            },
            "figsize": {
                "type": "Optional[tuple[float, float]]",
                "default": "None",
                "optional": true,
                "description": "Width, height in inches. Defaults to None .",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Show the plot, do not return axis.",
                "optional_value": false
            },
            "title": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Set the title of the plot.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Plots a pretty figure of the Fitted KaplanMeierFitter model\n\nSee https://lifelines.readthedocs.io/en/latest/fitters/univariate/KaplanMeierFitter.html\n\nArgs:\n    kmfs: Iterables of fitted KaplanMeierFitter objects.\n    ci_alpha: The transparency level of the confidence interval. If more than one kmfs, this should be a list. Defaults to 0.3.\n    ci_force_lines: Force the confidence intervals to be line plots (versus default shaded areas).\n                    If more than one kmfs, this should be a list. Defaults to False .\n    ci_show: Show confidence intervals. If more than one kmfs, this should be a list. Defaults to True .\n    ci_legend: If ci_force_lines is True, this is a boolean flag to add the lines' labels to the legend.\n               If more than one kmfs, this should be a list. Defaults to False .\n    at_risk_counts: Show group sizes at time points. If more than one kmfs, this should be a list. Defaults to False.\n    color: List of colors for each kmf. If more than one kmfs, this should be a list.\n    grid: If True, plot grid lines.\n    xlim: Set the x-axis view limits.\n    ylim: Set the y-axis view limits.\n    xlabel: The x-axis label text.\n    ylabel: The y-axis label text.\n    figsize: Width, height in inches. Defaults to None .\n    show: Show the plot, do not return axis.\n    title: Set the title of the plot.\n\nExamples:\n    >>> import ehrapy as ep\n    >>> import numpy as np\n    >>> adata = ep.dt.mimic_2(encoded=False)\n\n    # Because in MIMIC-II database, `censor_fl` is censored or death (binary: 0 = death, 1 = censored).\n    # While in KaplanMeierFitter, `event_observed` is True if the the death was observed, False if the event was lost (right-censored).\n    # So we need to flip `censor_fl` when pass `censor_fl` to KaplanMeierFitter\n\n    >>> adata[:, ['censor_flg']].X = np.where(adata[:, ['censor_flg']].X == 0, 1, 0)\n    >>> kmf = ep.tl.kmf(adata[:, ['mort_day_censored']].X, adata[:, ['censor_flg']].X)\n    >>> ep.pl.kmf([kmf], color=['r'], xlim=[0, 700], ylim=[0, 1], xlabel=\"Days\", ylabel=\"Proportion Survived\", show=True)\n\n    .. image:: /_static/docstring_previews/kmf_plot_1.png\n\n    >>> T = adata[:, ['mort_day_censored']].X\n    >>> E = adata[:, ['censor_flg']].X\n    >>> groups = adata[:, ['service_unit']].X\n    >>> ix1 = (groups == 'FICU')\n    >>> ix2 = (groups == 'MICU')\n    >>> ix3 = (groups == 'SICU')\n    >>> kmf_1 = ep.tl.kmf(T[ix1], E[ix1], label='FICU')\n    >>> kmf_2 = ep.tl.kmf(T[ix2], E[ix2], label='MICU')\n    >>> kmf_3 = ep.tl.kmf(T[ix3], E[ix3], label='SICU')\n    >>> ep.pl.kmf([kmf_1, kmf_2, kmf_3], ci_show=[False,False,False], color=['k','r', 'g'],\n    >>>           xlim=[0, 750], ylim=[0, 1], xlabel=\"Days\", ylabel=\"Proportion Survived\")\n\n    .. image:: /_static/docstring_previews/kmf_plot_2.png",
        "description": "Plots a pretty figure of the Fitted KaplanMeierFitter modelSee https://lifelines.readthedocs.io/en/latest/fitters/univariate/KaplanMeierFitter.html",
        "example": ">>> import ehrapy as ep\n    >>> import numpy as np\n    >>> adata = ep.dt.mimic_2(encoded=False)\n\n    # Because in MIMIC-II database, `censor_fl` is censored or death (binary: 0 = death, 1 = censored).\n    # While in KaplanMeierFitter, `event_observed` is True if the the death was observed, False if the event was lost (right-censored).\n    # So we need to flip `censor_fl` when pass `censor_fl` to KaplanMeierFitter\n\n    >>> adata[:, ['censor_flg']].X = np.where(adata[:, ['censor_flg']].X == 0, 1, 0)\n    >>> kmf = ep.tl.kmf(adata[:, ['mort_day_censored']].X, adata[:, ['censor_flg']].X)\n    >>> ep.pl.kmf([kmf], color=['r'], xlim=[0, 700], ylim=[0, 1], xlabel=\"Days\", ylabel=\"Proportion Survived\", show=True)\n\n    .. image:: /_static/docstring_previews/kmf_plot_1.png\n\n    >>> T = adata[:, ['mort_day_censored']].X\n    >>> E = adata[:, ['censor_flg']].X\n    >>> groups = adata[:, ['service_unit']].X\n    >>> ix1 = (groups == 'FICU')\n    >>> ix2 = (groups == 'MICU')\n    >>> ix3 = (groups == 'SICU')\n    >>> kmf_1 = ep.tl.kmf(T[ix1], E[ix1], label='FICU')\n    >>> kmf_2 = ep.tl.kmf(T[ix2], E[ix2], label='MICU')\n    >>> kmf_3 = ep.tl.kmf(T[ix3], E[ix3], label='SICU')\n    >>> ep.pl.kmf([kmf_1, kmf_2, kmf_3], ci_show=[False,False,False], color=['k','r', 'g'],\n    >>>           xlim=[0, 750], ylim=[0, 1], xlabel=\"Days\", ylabel=\"Proportion Survived\")\n\n    .. image:: /_static/docstring_previews/kmf_plot_2.png",
        "api_type": "function",
        "api_calling": [
            "ehrapy.plot.kmf(kmfs=$, ci_alpha=@, ci_force_lines=@, ci_show=@, ci_legend=@, at_risk_counts=@, color=@, grid=$, xlim=@, ylim=@, xlabel=@, ylabel=@, figsize=@, show=@, title=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.anndata.df_to_anndata": {
        "Parameters": {
            "df": {
                "type": "pd.DataFrame",
                "default": null,
                "optional": false,
                "description": "The pandas dataframe to be transformed",
                "optional_value": true
            },
            "columns_obs_only": {
                "type": "Optional[list[str]]",
                "default": "None",
                "optional": true,
                "description": "An optional list of column names that should belong to obs only and not X",
                "optional_value": false
            },
            "index_column": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "The index column of obs. This can be either a column name (or its numerical index in the dataframe) or the index of the dataframe",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": ""
        },
        "Docstring": "Transform a given pandas dataframe into an AnnData object.\n\nNote that columns containing boolean values (either 0/1 or T(t)rue/F(f)alse)\nwill be stored as boolean columns whereas the other non numerical columns will be stored as categorical values.\n\nArgs:\n    df: The pandas dataframe to be transformed\n    columns_obs_only: An optional list of column names that should belong to obs only and not X\n    index_column: The index column of obs. This can be either a column name (or its numerical index in the dataframe) or the index of the dataframe\n\nReturns:\n    An AnnData object created from the given pandas dataframe\n\nExamples:\n    >>> import ehrapy as ep\n    >>> import pandas as pd\n    >>> df = pd.DataFrame(\n    ...     {\n    ...         \"patient_id\": [\"0\", \"1\", \"2\", \"3\", \"4\"],\n    ...         \"age\": [65, 72, 58, 78, 82],\n    ...         \"sex\": [\"M\", \"F\", \"F\", \"M\", \"F\"],\n    ...     }\n    ... )\n    >>> adata = ep.df_to_anndata(df, index_column=\"patient_id\")",
        "description": "Transform a given pandas dataframe into an AnnData object.Note that columns containing boolean values (either 0/1 or T(t)rue/F(f)alse)\nwill be stored as boolean columns whereas the other non numerical columns will be stored as categorical values.",
        "example": ">>> import ehrapy as ep\n    >>> import pandas as pd\n    >>> df = pd.DataFrame(\n    ...     {\n    ...         \"patient_id\": [\"0\", \"1\", \"2\", \"3\", \"4\"],\n    ...         \"age\": [65, 72, 58, 78, 82],\n    ...         \"sex\": [\"M\", \"F\", \"F\", \"M\", \"F\"],\n    ...     }\n    ... )\n    >>> adata = ep.df_to_anndata(df, index_column=\"patient_id\")",
        "api_type": "function",
        "api_calling": [
            "ehrapy.anndata.df_to_anndata(df=$, columns_obs_only=@, index_column=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.plot.pca_loadings": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object object containing all observations.",
                "optional_value": true
            },
            "components": {
                "type": "Optional[Union[str, Sequence[int]]]",
                "default": "None",
                "optional": true,
                "description": "For example, ``'1,2,3'`` means ``[1, 2, 3]``, first, second, third principal component.",
                "optional_value": false
            },
            "include_lowest": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to show the features with both highest and lowest loadings.",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Show the plot, do not return axis.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[str, bool]]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure. A string is appended to the default filename.\nInfer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Rank features according to contributions to PCs.\n\nArgs:\n    adata: :class:`~anndata.AnnData` object object containing all observations.\n    components: For example, ``'1,2,3'`` means ``[1, 2, 3]``, first, second, third principal component.\n    include_lowest: Whether to show the features with both highest and lowest loadings.\n    show: Show the plot, do not return axis.\n    save: If `True` or a `str`, save the figure. A string is appended to the default filename.\n          Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\n\nReturns:\n    If `show==False` a :class:`~matplotlib.axes.Axes` or a list of it.\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.knn_impute(adata)\n    >>> ep.pp.log_norm(adata, offset=1)\n    >>> ep.pp.neighbors(adata)\n    >>> ep.pp.pca(adata)\n    >>> ep.pl.pca_loadings(adata, components='1,2,3')\n\nPreview:\n    .. image:: /_static/docstring_previews/pca_loadings.png",
        "description": "Rank features according to contributions to PCs.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.knn_impute(adata)\n    >>> ep.pp.log_norm(adata, offset=1)\n    >>> ep.pp.neighbors(adata)\n    >>> ep.pp.pca(adata)\n    >>> ep.pl.pca_loadings(adata, components='1,2,3')\n\nPreview:\n    .. image:: /_static/docstring_previews/pca_loadings.png",
        "api_type": "function",
        "api_calling": [
            "ehrapy.plot.pca_loadings(adata=$, components=@, include_lowest=@, show=@, save=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.plot.umap": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object object containing all observations.",
                "optional_value": true
            }
        },
        "Returns": {
            "type": "Optional[Union[Axes, list[Axes]]]",
            "description": ""
        },
        "Docstring": "Scatter plot in UMAP basis.\n\nArgs:\n    adata: :class:`~anndata.AnnData` object object containing all observations.\n    color: Keys for annotations of observations/patients or features, e.g., `'ann1'` or `['ann1', 'ann2']`.\n    feature_symbols: Column name in `.var` DataFrame that stores feature symbols. By default `var_names`\n                     refer to the index column of the `.var` DataFrame. Setting this option allows alternative names to be used.\n    use_raw: Use `.raw` attribute of `adata` for coloring with feature values. If `None`,\n             defaults to `True` if `layer` isn't provided and `adata.raw` is present.\n    layer: Name of the AnnData object layer that wants to be plotted. By default\n           adata.raw.X is plotted. If `use_raw=False` is set, then `adata.X` is plotted.\n           If `layer` is set to a valid layer name, then the layer is plotted. `layer` takes precedence over `use_raw`.\n    edges: Show edges.\n    edges_width: Width of edges.\n    edges_color: Color of edges. See :func:`~networkx.drawing.nx_pylab.draw_networkx_edges`.\n    neighbors_key: Where to look for neighbors connectivities.\n                   If not specified, this looks .obsp['connectivities'] for connectivities\n                   (default storage place for pp.neighbors). If specified, this looks at\n                   `.obsp[.uns[neighbors_key]['connectivities_key']]` for connectivities.\n    arrows: Show arrows (deprecated in favour of `scvelo.pl.velocity_embedding`).\n    arrows_kwds: Passed to :meth:`~matplotlib.axes.Axes.quiver`\n    sort_order: For continuous annotations used as color parameter, plot data points with higher values on top of others.\n    groups: Restrict to a few categories in categorical observation annotation.\n            The default is not to restrict to any groups.\n    components: For instance, `['1,2', '2,3']`. To plot all available components use `components='all'`.\n    projection: Projection of plot (default: `'2d'`).\n    legend_loc: Location of legend, either `'on data'`, `'right margin'` or a valid keyword for the `loc` parameter of :class:`~matplotlib.legend.Legend`.\n    legend_fontsize: Numeric size in pt or string describing the size. See :meth:`~matplotlib.text.Text.set_fontsize`.\n    legend_fontweight: Legend font weight. A numeric value in range 0-1000 or a string.\n                       Defaults to `'bold'` if `legend_loc == 'on data'`, otherwise to `'normal'`.\n                       See :meth:`~matplotlib.text.Text.set_fontweight`.\n    legend_fontoutline: Line width of the legend font outline in pt. Draws a white outline using the path effect :class:`~matplotlib.patheffects.withStroke`.\n    size: Point size. If `None`, is automatically computed as 120000 / n_features.\n          Can be a sequence containing the size for each observation. The order should be the same as in adata.obs.\n    color_map: Color map to use for continous variables. Can be a name or a\n               :class:`~matplotlib.colors.Colormap` instance (e.g. `\"magma`\", `\"viridis\"`\n               or `mpl.cm.cividis`), see :func:`~matplotlib.cm.get_cmap`.\n               If `None`, the value of `mpl.rcParams[\"image.cmap\"]` is used.\n               The default `color_map` can be set using :func:`~scanpy.set_figure_params`.\n    palette: Colors to use for plotting categorical annotation groups.\n             The palette can be a valid :class:`~matplotlib.colors.ListedColormap` name\n             (`'Set2'`, `'tab20'`, \u2026), a :class:`~cycler.Cycler` object, a dict mapping\n             categories to colors, or a sequence of colors. Colors must be valid to\n             matplotlib. (see :func:`~matplotlib.colors.is_color_like`).\n             If `None`, `mpl.rcParams[\"axes.prop_cycle\"]` is used unless the categorical\n             variable already has colors stored in `adata.uns[\"{var}_colors\"]`.\n             If provided, values of `adata.uns[\"{var}_colors\"]` will be set.\n    na_color: Color to use for null or masked values. Can be anything matplotlib accepts as a color.\n              Used for all points if `color=None`.\n    na_in_legend: If there are missing values, whether they get an entry in the legend.\n                  Currently only implemented for categorical legends.\n    frameon: Draw a frame around the scatter plot. Defaults to value set in :func:`~scanpy.set_figure_params` (default: True).\n    title: Provide title for panels either as string or list of strings, e.g. `['title1', 'title2', ...]`.\n    vmin: The value representing the lower limit of the color scale. Values smaller than vmin are plotted\n          with the same color as vmin. vmin can be a number, a string, a function or `None`. If\n          vmin is a string and has the format `pN`, this is interpreted as a vmin=percentile(N).\n          For example vmin='p1.5' is interpreted as the 1.5 percentile. If vmin is function, then\n          vmin is interpreted as the return value of the function over the list of values to plot.\n          For example to set vmin tp the mean of the values to plot, `def my_vmin(values): return\n          np.mean(values)` and then set `vmin=my_vmin`. If vmin is None (default) an automatic\n          minimum value is used as defined by matplotlib `scatter` function. When making multiple\n          plots, vmin can be a list of values, one for each plot. For example `vmin=[0.1, 'p1', None, my_vmin]`\n    vmax: The value representing the upper limit of the color scale. The format is the same as for `vmin`.\n    vcenter: The value representing the center of the color scale. Useful for diverging colormaps.\n             The format is the same as for `vmin`.\n             Example: sc.pl.umap(adata, color='TREM2', vcenter='p50', cmap='RdBu_r')\n    add_outline: If set to True, this will add a thin border around groups of dots. In some situations\n                 this can enhance the aesthetics of the resulting image\n    outline_color: Tuple with two valid color names used to adjust the add_outline. The first color is the\n                   border color (default: black), while the second color is a gap color between the\n                   border color and the scatter dot (default: white).\n    outline_width: Tuple with two width numbers used to adjust the outline. The first value is the width\n                   of the border color as a fraction of the scatter dot size (default: 0.3). The second value is\n                   width of the gap color (default: 0.05).\n    ncols: Number of panels per row.\n           wspace: Adjust the width of the space between multiple panels.\n           hspace: Adjust the height of the space between multiple panels.\n           return_fig: Return the matplotlib figure.\n    kwargs: Arguments to pass to :func:`matplotlib.pyplot.scatter`,\n            for instance: the maximum and minimum values (e.g. `vmin=-2, vmax=5`).\n    show: Whether to display the figure or return axis.\n    save: If `True` or a `str`, save the figure.\n          A string is appended to the default filename.\n          Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\n    ax: A matplotlib axes object. Only works if plotting a single component.\n\nReturns:\n    If `show==False` a :class:`~matplotlib.axes.Axes` or a list of it.\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.knn_impute(adata)\n    >>> ep.pp.log_norm(adata, offset=1)\n    >>> ep.pp.neighbors(adata)\n    >>> ep.tl.umap(adata)\n    >>> ep.pl.umap(adata)\n\n    .. image:: /_static/docstring_previews/umap_1.png\n\n    >>> ep.pl.umap(adata, color=[\"day_icu_intime\", \"service_unit\"], wspace=0.5, title=[\"Day of ICU admission\", \"Service unit\"])\n\n    .. image:: /_static/docstring_previews/umap_2.png\n\n    >>> ep.tl.leiden(adata, resolution=0.5, key_added=\"leiden_0_5\")\n    >>> ep.pl.umap(adata, color=[\"leiden_0_5\"], title=\"Leiden 0.5\")\n\n    .. image:: /_static/docstring_previews/umap_3.png",
        "description": "Scatter plot in UMAP basis.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.knn_impute(adata)\n    >>> ep.pp.log_norm(adata, offset=1)\n    >>> ep.pp.neighbors(adata)\n    >>> ep.tl.umap(adata)\n    >>> ep.pl.umap(adata)\n\n    .. image:: /_static/docstring_previews/umap_1.png\n\n    >>> ep.pl.umap(adata, color=[\"day_icu_intime\", \"service_unit\"], wspace=0.5, title=[\"Day of ICU admission\", \"Service unit\"])\n\n    .. image:: /_static/docstring_previews/umap_2.png\n\n    >>> ep.tl.leiden(adata, resolution=0.5, key_added=\"leiden_0_5\")\n    >>> ep.pl.umap(adata, color=[\"leiden_0_5\"], title=\"Leiden 0.5\")\n\n    .. image:: /_static/docstring_previews/umap_3.png",
        "api_type": "function",
        "api_calling": [
            "ehrapy.plot.umap(adata=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.settings": {
        "Parameters": {},
        "Returns": {
            "type": "ehrapy._settings.EhrapyConfig",
            "description": null
        },
        "Value": "N_PCS = 50\nautosave = False\nautoshow = True\ncache_compression = 'lzf'\ncachedir = PosixPath('ehrapy_cache')\ncategories_to_ignore = ['N/A', 'dontknow', 'no_gate', '?']\ndatasetdir = PosixPath('/home/z6dong/BioChat/refer/src/BioMANIA/src/ehrapy_data')\nfigdir = PosixPath('figures')\nfile_format_data = 'h5ad'\nfile_format_figs = 'pdf'\nlogfile = <_io.TextIOWrapper name='<stderr>' mode='w' encoding='utf-8'>\nlogpath = None\nmax_memory = 15\nn_jobs = 1\nplot_suffix = ''\nset_figure_params = <bound method EhrapyConfig.set_figure_params of <ehrapy._settings.EhrapyConfig object at 0x7f9c0645d1b0>>\nverbosity = <Verbosity.warn: 1>\nwritedir = PosixPath('ehrapy_write')",
        "Docstring": "Configuration manager for ehrapy.\n\n    Strongly adapted from Scanpy.\n    ",
        "description": "Configuration manager for ehrapy.Strongly adapted from Scanpy.",
        "example": "",
        "api_type": "method",
        "api_calling": [
            "ehrapy.settings()"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.tools.ingest": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object object containing all observations.",
                "optional_value": true
            },
            "adata_ref": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "The annotated data matrix of shape `n_obs` \u00d7 `n_vars`. Rows correspond to observations and columns to features.\nVariables (`n_vars` and `var_names`) of `adata_ref` should be the same as in `adata`.\nThis is the dataset with labels and embeddings which need to be mapped to `adata`.",
                "optional_value": true
            },
            "obs": {
                "type": "Optional[Union[str, Iterable[str]]]",
                "default": "None",
                "optional": true,
                "description": "Labels' keys in `adata_ref.obs` which need to be mapped to `adata.obs` (inferred for observation of `adata`).",
                "optional_value": false
            },
            "embedding_method": {
                "type": "Union[str, Iterable[str]]",
                "default": "('umap', 'pca')",
                "optional": true,
                "description": "Embeddings in `adata_ref` which need to be mapped to `adata`. The only supported values are 'umap' and 'pca'.",
                "optional_value": false
            },
            "labeling_method": {
                "type": "str",
                "default": "knn",
                "optional": true,
                "description": "The method to map labels in `adata_ref.obs` to `adata.obs`. The only supported value is 'knn'.",
                "optional_value": false
            },
            "neighbors_key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "If not specified, ingest looks adata_ref.uns['neighbors'] for neighbors settings and adata_ref.obsp['distances'] for\ndistances (default storage places for pp.neighbors). If specified, ingest looks adata_ref.uns[neighbors_key] for\nneighbors settings and adata_ref.obsp[adata_ref.uns[neighbors_key]['distances_key']] for distances.",
                "optional_value": false
            },
            "inplace": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Only works if `return_joint=False`.\nAdd labels and embeddings to the passed `adata` (if `True`) or return a copy of `adata` with mapped embeddings and labels.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[AnnData]",
            "description": ""
        },
        "Docstring": "Map labels and embeddings from reference data to new data.\n\nIntegrates embeddings and annotations of an `adata` with a reference dataset\n`adata_ref` through projecting on a PCA (or alternate model) that has been fitted on the reference data.\nThe function uses a knn classifier for mapping labels and the UMAP package [McInnes18]_ for mapping the embeddings.\n\n.. note::\n    We refer to this *asymmetric* dataset integration as *ingesting*\n    annotations from reference data to new data. This is different from\n    learning a joint representation that integrates both datasets in an\n    unbiased way, as CCA (e.g. in Seurat) or a conditional VAE (e.g. in\n    scVI) would do.\n\nYou need to run :func:`~ehrapy.pp.neighbors` on `adata_ref` before passing it.\n\nArgs:\n    adata: :class:`~anndata.AnnData` object object containing all observations.\n    adata_ref: The annotated data matrix of shape `n_obs` \u00d7 `n_vars`. Rows correspond to observations and columns to features.\n               Variables (`n_vars` and `var_names`) of `adata_ref` should be the same as in `adata`.\n               This is the dataset with labels and embeddings which need to be mapped to `adata`.\n    obs: Labels' keys in `adata_ref.obs` which need to be mapped to `adata.obs` (inferred for observation of `adata`).\n    embedding_method: Embeddings in `adata_ref` which need to be mapped to `adata`. The only supported values are 'umap' and 'pca'.\n    labeling_method: The method to map labels in `adata_ref.obs` to `adata.obs`. The only supported value is 'knn'.\n    neighbors_key: If not specified, ingest looks adata_ref.uns['neighbors'] for neighbors settings and adata_ref.obsp['distances'] for\n                   distances (default storage places for pp.neighbors). If specified, ingest looks adata_ref.uns[neighbors_key] for\n                   neighbors settings and adata_ref.obsp[adata_ref.uns[neighbors_key]['distances_key']] for distances.\n    inplace: Only works if `return_joint=False`.\n             Add labels and embeddings to the passed `adata` (if `True`) or return a copy of `adata` with mapped embeddings and labels.\n    **kwargs: Further keyword arguments for the Neighbor calculation\n\nReturns:\n    * if `inplace=False` returns a copy of `adata` with mapped embeddings and labels in `obsm` and `obs` correspondingly\n    * if `inplace=True` returns `None` and updates `adata.obsm` and `adata.obs` with mapped embeddings and labels\n\nExamples:\n    >>> import ehrapy as ep\n    >>> ep.pp.neighbors(adata_ref)\n    >>> ep.tl.umap(adata_ref)\n    >>> ep.tl.ingest(adata, adata_ref, obs=\"service_unit\")",
        "description": "Map labels and embeddings from reference data to new data.Integrates embeddings and annotations of an `adata` with a reference dataset\n`adata_ref` through projecting on a PCA (or alternate model) that has been fitted on the reference data.\nThe function uses a knn classifier for mapping labels and the UMAP package [McInnes18]_ for mapping the embeddings.\n\n.. note::\n    We refer to this *asymmetric* dataset integration as *ingesting*\n    annotations from reference data to new data. This is different from\n    learning a joint representation that integrates both datasets in an\n    unbiased way, as CCA (e.g. in Seurat) or a conditional VAE (e.g. in\n    scVI) would do.\n\nYou need to run :func:`~ehrapy.pp.neighbors` on `adata_ref` before passing it.",
        "example": ">>> import ehrapy as ep\n    >>> ep.pp.neighbors(adata_ref)\n    >>> ep.tl.umap(adata_ref)\n    >>> ep.tl.ingest(adata, adata_ref, obs=\"service_unit\")",
        "api_type": "function",
        "api_calling": [
            "ehrapy.tools.ingest(adata=$, adata_ref=$, obs=@, embedding_method=@, labeling_method=@, neighbors_key=@, inplace=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.tools.embedding_density": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object object containing all observations.",
                "optional_value": true
            },
            "basis": {
                "type": "str",
                "default": "umap",
                "optional": true,
                "description": "The embedding over which the density will be calculated. This embedded\nrepresentation should be found in `adata.obsm['X_[basis]']``.",
                "optional_value": false
            },
            "groupby": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Keys for categorical observation/cell annotation for which densities\nare calculated per category. Columns with up to ten categories are accepted.",
                "optional_value": false
            },
            "key_added": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Name of the `.obs` covariate that will be added with the density estimates.",
                "optional_value": false
            },
            "components": {
                "type": "Union[str, Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "The embedding dimensions over which the density should be calculated.\nThis is limited to two components.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "",
            "description": ""
        },
        "Docstring": "Calculate the density of observation in an embedding (per condition).\nGaussian kernel density estimation is used to calculate the density of\nobservations in an embedded space. This can be performed per category over a\ncategorical observation annotation. The cell density can be plotted using the\n`sc.pl.embedding_density()` function.\nNote that density values are scaled to be between 0 and 1. Thus, the\ndensity value at each cell is only comparable to other densities in\nthe same condition category.\n\nArgs:\n    adata: :class:`~anndata.AnnData` object object containing all observations.\n    basis: The embedding over which the density will be calculated. This embedded\n           representation should be found in `adata.obsm['X_[basis]']``.\n    groupby: Keys for categorical observation/cell annotation for which densities\n             are calculated per category. Columns with up to ten categories are accepted.\n    key_added: Name of the `.obs` covariate that will be added with the density estimates.\n    components: The embedding dimensions over which the density should be calculated.\n                This is limited to two components.\n\nReturns:\n    Updates `adata.obs` with an additional field specified by the `key_added`\n    parameter. This parameter defaults to `[basis]_density_[groupby]`, where\n    where `[basis]` is one of `umap`, `diffmap`, `pca`, `tsne`, or `draw_graph_fa`\n    and `[groupby]` denotes the parameter input.\n    Updates `adata.uns` with an additional field `[key_added]_params`.\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.data.mimic_2(encoded=True)\n    >>> ep.tl.umap(adata)\n    >>> ep.tl.embedding_density(adata, basis='umap', groupby='phase')\n    >>> ep.pl.embedding_density(adata, basis='umap', key='umap_density_phase', group='G1')",
        "description": "Calculate the density of observation in an embedding (per condition).Gaussian kernel density estimation is used to calculate the density of\nobservations in an embedded space. This can be performed per category over a\ncategorical observation annotation. The cell density can be plotted using the\n`sc.pl.embedding_density()` function.\nNote that density values are scaled to be between 0 and 1. Thus, the\ndensity value at each cell is only comparable to other densities in\nthe same condition category.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.data.mimic_2(encoded=True)\n    >>> ep.tl.umap(adata)\n    >>> ep.tl.embedding_density(adata, basis='umap', groupby='phase')\n    >>> ep.pl.embedding_density(adata, basis='umap', key='umap_density_phase', group='G1')",
        "api_type": "function",
        "api_calling": [
            "ehrapy.tools.embedding_density(adata=$, basis=@, groupby=@, key_added=@, components=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.tools.dpt": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object object containing all observations.",
                "optional_value": true
            },
            "n_dcs": {
                "type": "int",
                "default": "10",
                "optional": true,
                "description": "The number of diffusion components to use.",
                "optional_value": false
            },
            "n_branchings": {
                "type": "int",
                "default": "0",
                "optional": true,
                "description": "Number of branchings to detect.",
                "optional_value": false
            },
            "min_group_size": {
                "type": "float",
                "default": "0.01",
                "optional": true,
                "description": "During recursive splitting of branches ('dpt groups') for `n_branchings`\n> 1, do not consider groups that contain less than `min_group_size` data\npoints. If a float, `min_group_size` refers to a fraction of the total number of data points.",
                "optional_value": false
            },
            "allow_kendall_tau_shift": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "If a very small branch is detected upon splitting, shift away from\nmaximum correlation in Kendall tau criterion of [Haghverdi16]_ to stabilize the splitting.",
                "optional_value": false
            },
            "neighbors_key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "If not specified, dpt looks `.uns['neighbors']` for neighbors settings\nand `.obsp['connectivities']`, `.obsp['distances']` for connectivities and\ndistances respectively (default storage places for pp.neighbors).\nIf specified, dpt looks .uns[neighbors_key] for neighbors settings and\n`.obsp[.uns[neighbors_key]['connectivities_key']]`,\n`.obsp[.uns[neighbors_key]['distances_key']]` for connectivities and distances respectively.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Copy instance before computation and return a copy. Otherwise, perform computation in place and return `None`.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[AnnData]",
            "description": ""
        },
        "Docstring": "Infer progression of observations through geodesic distance along the graph [Haghverdi16]_ [Wolf19]_.\n\nReconstruct the progression of a biological process from snapshot\ndata. `Diffusion Pseudotime` has been introduced by [Haghverdi16]_ and\nimplemented within Scanpy [Wolf18]_. Here, we use a further developed\nversion, which is able to deal with disconnected graphs [Wolf19]_ and can\nbe run in a `hierarchical` mode by setting the parameter `n_branchings>1`.\nWe recommend, however, to only use :func:`~ehrapy.tl.dpt` for computing pseudotime (`n_branchings=0`) and\nto detect branchings via :func:`~scanpy.tl.paga`. For pseudotime, you need\nto annotate your data with a root cell. For instance `adata.uns['iroot'] = np.flatnonzero(adata.obs['cell_types'] == 'Stem')[0]`\nThis requires to run :func:`~ehrapy.pp.neighbors`, first. In order to\nreproduce the original implementation of DPT, use `method=='gauss'` in\nthis. Using the default `method=='umap'` only leads to minor quantitative differences, though.\n\nArgs:\n    adata: :class:`~anndata.AnnData` object object containing all observations.\n    n_dcs: The number of diffusion components to use.\n    n_branchings: Number of branchings to detect.\n    min_group_size: During recursive splitting of branches ('dpt groups') for `n_branchings`\n                    > 1, do not consider groups that contain less than `min_group_size` data\n                    points. If a float, `min_group_size` refers to a fraction of the total number of data points.\n    allow_kendall_tau_shift: If a very small branch is detected upon splitting, shift away from\n                             maximum correlation in Kendall tau criterion of [Haghverdi16]_ to stabilize the splitting.\n    neighbors_key: If not specified, dpt looks `.uns['neighbors']` for neighbors settings\n                   and `.obsp['connectivities']`, `.obsp['distances']` for connectivities and\n                   distances respectively (default storage places for pp.neighbors).\n                   If specified, dpt looks .uns[neighbors_key] for neighbors settings and\n                   `.obsp[.uns[neighbors_key]['connectivities_key']]`,\n                   `.obsp[.uns[neighbors_key]['distances_key']]` for connectivities and distances respectively.\n    copy: Copy instance before computation and return a copy. Otherwise, perform computation in place and return `None`.\n\nReturns:\n    Depending on `copy`, returns or updates `adata` with the following fields.\n    If `n_branchings==0`, no field `dpt_groups` will be written.\n\n    * `dpt_pseudotime` : :class:`pandas.Series` (`adata.obs`, dtype `float`)\n      Array of dim (number of samples) that stores the pseudotime of each\n      observation, that is, the DPT distance with respect to the root observation.\n    * `dpt_groups` : :class:`pandas.Series` (`adata.obs`, dtype `category`)\n      Array of dim (number of samples) that stores the subgroup id ('0', '1', ...) for each observation.",
        "description": "Infer progression of observations through geodesic distance along the graph [Haghverdi16]_ [Wolf19]_.Reconstruct the progression of a biological process from snapshot\ndata. `Diffusion Pseudotime` has been introduced by [Haghverdi16]_ and\nimplemented within Scanpy [Wolf18]_. Here, we use a further developed\nversion, which is able to deal with disconnected graphs [Wolf19]_ and can\nbe run in a `hierarchical` mode by setting the parameter `n_branchings>1`.\nWe recommend, however, to only use :func:`~ehrapy.tl.dpt` for computing pseudotime (`n_branchings=0`) and\nto detect branchings via :func:`~scanpy.tl.paga`. For pseudotime, you need\nto annotate your data with a root cell. For instance `adata.uns['iroot'] = np.flatnonzero(adata.obs['cell_types'] == 'Stem')[0]`\nThis requires to run :func:`~ehrapy.pp.neighbors`, first. In order to\nreproduce the original implementation of DPT, use `method=='gauss'` in\nthis. Using the default `method=='umap'` only leads to minor quantitative differences, though.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "ehrapy.tools.dpt(adata=$, n_dcs=@, n_branchings=@, min_group_size=@, allow_kendall_tau_shift=@, neighbors_key=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.io.read_fhir": {
        "Parameters": {
            "dataset_path": {
                "type": "str",
                "default": null,
                "optional": false,
                "description": "Path to one or multiple FHIR files.",
                "optional_value": false
            },
            "format": {
                "type": "Literal['json', 'ndjson']",
                "default": "json",
                "optional": true,
                "description": "The file format of the FHIR data. One of 'json' or 'ndjson'. Defaults to 'json'.",
                "optional_value": true
            },
            "columns_obs_only": {
                "type": "Optional[list[str]]",
                "default": "None",
                "optional": true,
                "description": "These columns will be added to obs only and not X.",
                "optional_value": false
            },
            "columns_x_only": {
                "type": "Optional[list[str]]",
                "default": "None",
                "optional": true,
                "description": "These columns will be added to X only and all remaining columns to obs.\nNote that datetime columns will always be added to .obs though.",
                "optional_value": false
            },
            "return_df": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to return one or several Pandas DataFrames.",
                "optional_value": false
            },
            "cache": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to write to cache when reading or not. Defaults to False.",
                "optional_value": false
            },
            "backup_url": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "URL to download the data file(s) from if not yet existing.",
                "optional_value": false
            },
            "index_column": {
                "type": "Optional[Union[str, int]]",
                "default": "None",
                "optional": true,
                "description": "The index column for the generated object. Usually the patient or visit ID.",
                "optional_value": false
            },
            "download_dataset_name": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Name of the file or directory in case the dataset is downloaded",
                "optional_value": false
            },
            "archive_format": {
                "type": "Literal['zip', 'tar', 'tar.gz', 'tgz']",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            }
        },
        "Returns": {
            "type": "Union[pd.DataFrame, AnnData]",
            "description": ""
        },
        "Docstring": "Reads one or multiple FHIR files using fhiry.\n\nUses https://github.com/dermatologist/fhiry to read the FHIR file into a Pandas DataFrame\nwhich is subsequently transformed into an AnnData object.\n\nBe aware that FHIR data can be nested and return lists or dictionaries as values.\nIn such cases, one can either:\n1. Transform the data into an awkward array and flatten it when needed.\n2. Extract values from all lists and dictionaries to store single values in the fields.\n3. Remove all lists and dictionaries. Only do this if the information is not relevant to you.\n\nArgs:\n    dataset_path: Path to one or multiple FHIR files.\n    format: The file format of the FHIR data. One of 'json' or 'ndjson'. Defaults to 'json'.\n    columns_obs_only: These columns will be added to obs only and not X.\n    columns_x_only: These columns will be added to X only and all remaining columns to obs.\n                    Note that datetime columns will always be added to .obs though.\n    return_df: Whether to return one or several Pandas DataFrames.\n    cache: Whether to write to cache when reading or not. Defaults to False.\n    download_dataset_name: Name of the file or directory in case the dataset is downloaded\n    index_column: The index column for the generated object. Usually the patient or visit ID.\n    backup_url: URL to download the data file(s) from if not yet existing.\n\nReturns:\n    A Pandas DataFrame or AnnData object of the read in FHIR file(s).\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.io.read_fhir(\"/path/to/fhir/resources\")\n\n    Be aware that most FHIR datasets have nested data that might need to be removed.\n    In such cases consider working with DataFrames.\n    >>> df = ep.io.read_fhir(\"/path/to/fhir/resources\", return_df=True)\n    >>> df.drop(columns=[col for col in df.columns if any(isinstance(x, (list, dict)) for x in df[col].dropna())], inplace=True)\n    >>> df.drop(columns=df.columns[df.isna().all()], inplace=True)",
        "description": "Reads one or multiple FHIR files using fhiry.Uses https://github.com/dermatologist/fhiry to read the FHIR file into a Pandas DataFrame\nwhich is subsequently transformed into an AnnData object.\n\nBe aware that FHIR data can be nested and return lists or dictionaries as values.\nIn such cases, one can either:\n1. Transform the data into an awkward array and flatten it when needed.\n2. Extract values from all lists and dictionaries to store single values in the fields.\n3. Remove all lists and dictionaries. Only do this if the information is not relevant to you.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.io.read_fhir(\"/path/to/fhir/resources\")\n\n    Be aware that most FHIR datasets have nested data that might need to be removed.\n    In such cases consider working with DataFrames.\n    >>> df = ep.io.read_fhir(\"/path/to/fhir/resources\", return_df=True)\n    >>> df.drop(columns=[col for col in df.columns if any(isinstance(x, (list, dict)) for x in df[col].dropna())], inplace=True)\n    >>> df.drop(columns=df.columns[df.isna().all()], inplace=True)",
        "api_type": "function",
        "api_calling": [
            "ehrapy.io.read_fhir(dataset_path=@, format=$, columns_obs_only=@, columns_x_only=@, return_df=@, cache=@, backup_url=@, index_column=@, download_dataset_name=@, archive_format=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.preprocessing.clip_quantile": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "The AnnData object",
                "optional_value": true
            },
            "limits": {
                "type": "list[float]",
                "default": null,
                "optional": false,
                "description": "Interval, values outside of which are clipped to the interval edges",
                "optional_value": false
            },
            "vars": {
                "type": "Union[str, list[str], set[str]]",
                "default": "None",
                "optional": true,
                "description": "Columns in var with features to clip",
                "optional_value": false
            },
            "obs_cols": {
                "type": "Union[str, list[str], set[str]]",
                "default": "None",
                "optional": true,
                "description": "Columns in obs with features to clip",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to return a copy of AnnData or not",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": ""
        },
        "Docstring": "Clips (limits) features.\n\nGiven an interval, values outside the interval are clipped to the interval edges.\n\nThe implementation is based on https://numpy.org/doc/stable/reference/generated/numpy.clip.html\n\nArgs:\n    adata: The AnnData object\n    vars: Columns in var with features to clip\n    obs_cols: Columns in obs with features to clip\n    limits: Interval, values outside of which are clipped to the interval edges\n    copy: Whether to return a copy of AnnData or not\n\nReturns:\n    A copy of original AnnData object with clipped features.\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.clip_quantile(adata, ['bmi'])",
        "description": "Clips (limits) features.Given an interval, values outside the interval are clipped to the interval edges.\n\nThe implementation is based on https://numpy.org/doc/stable/reference/generated/numpy.clip.html",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.clip_quantile(adata, ['bmi'])",
        "api_type": "function",
        "api_calling": [
            "ehrapy.preprocessing.clip_quantile(adata=$, limits=@, vars=@, obs_cols=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.preprocessing.summarize_measurements": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "AnnData object containing measurements that",
                "optional_value": true
            },
            "layer": {
                "type": "str",
                "default": "None",
                "optional": true,
                "description": "Layer to calculate the expanded measurements for. Defaults to None (use X).",
                "optional_value": false
            },
            "var_names": {
                "type": "Optional[Iterable[str]]",
                "default": "None",
                "optional": true,
                "description": "For which measurements to determine the expanded measurements for. Defaults to None (all numerical measurements).",
                "optional_value": false
            },
            "statistics": {
                "type": "Iterable[str]",
                "default": "None",
                "optional": true,
                "description": "Which expanded measurements to calculate.\nPossible values are 'min', 'max', 'mean'\nDefaults to None (calculate minimum, maximum and mean).",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": ""
        },
        "Docstring": "Summarizes numerical measurements into minimum, maximum and average values.\n\nArgs:\n    adata: AnnData object containing measurements that\n    layer: Layer to calculate the expanded measurements for. Defaults to None (use X).\n    var_names: For which measurements to determine the expanded measurements for. Defaults to None (all numerical measurements).\n    statistics: Which expanded measurements to calculate.\n                Possible values are 'min', 'max', 'mean'\n                Defaults to None (calculate minimum, maximum and mean).\n\nReturns:\n    A new AnnData object with expanded X containing the specified statistics as additional columns replacing the original values.",
        "description": "Summarizes numerical measurements into minimum, maximum and average values.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "ehrapy.preprocessing.summarize_measurements(adata=$, layer=@, var_names=@, statistics=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.tools.tsne": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object object containing all observations.",
                "optional_value": true
            },
            "n_pcs": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Use this many PCs. If `n_pcs==0` use `.X` if `use_rep is None`.",
                "optional_value": false
            },
            "use_rep": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Use the indicated representation. `'X'` or any key for `.obsm` is valid.\nIf `None`, the representation is chosen automatically:\nFor `.n_vars` < 50, `.X` is used, otherwise 'X_pca' is used.\nIf 'X_pca' is not present, it\u2019s computed with default parameters.",
                "optional_value": false
            },
            "perplexity": {
                "type": "Union[float, int]",
                "default": "30",
                "optional": true,
                "description": "The perplexity is related to the number of nearest neighbors that\nis used in other manifold learning algorithms. Larger datasets usually require a larger perplexity.\nConsider selecting a value between 5 and 50. The choice is not extremely critical since t-SNE\nis quite insensitive to this parameter.",
                "optional_value": false
            },
            "early_exaggeration": {
                "type": "Union[float, int]",
                "default": "12",
                "optional": true,
                "description": "Controls how tight natural clusters in the original space are in the\nembedded space and how much space will be between them. For larger\nvalues, the space between natural clusters will be larger in the\nembedded space. Again, the choice of this parameter is not very\ncritical. If the cost function increases during initial optimization,\nthe early exaggeration factor or the learning rate might be too high.",
                "optional_value": false
            },
            "learning_rate": {
                "type": "Union[float, int]",
                "default": "1000",
                "optional": true,
                "description": "Note that the R-package \"Rtsne\" uses a default of 200.\nThe learning rate can be a critical parameter. It should be\nbetween 100 and 1000. If the cost function increases during initial\noptimization, the early exaggeration factor or the learning rate\nmight be too high. If the cost function gets stuck in a bad local\nminimum increasing the learning rate helps sometimes.",
                "optional_value": false
            },
            "random_state": {
                "type": "Optional[Union[int, RandomState]]",
                "default": "0",
                "optional": true,
                "description": "Change this to use different intial states for the optimization.\nIf `None`, the initial state is not reproducible.",
                "optional_value": false
            },
            "n_jobs": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Number of jobs for parallel computation.\n`None` means using :attr:`scanpy._settings.ScanpyConfig.n_jobs`.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Return a copy instead of writing to `adata`.",
                "optional_value": false
            },
            "metric": {
                "type": "str",
                "default": "euclidean",
                "optional": true,
                "description": "Distance metric calculate neighbors on.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[AnnData]",
            "description": ""
        },
        "Docstring": "Calculates t-SNE [Maaten08]_ [Amir13]_ [Pedregosa11]_.\n\nt-distributed stochastic neighborhood embedding (tSNE) [Maaten08]_ has been\nproposed for visualizing complex by [Amir13]_. Here, by default, we use the implementation of *scikit-learn* [Pedregosa11]_.\n\nArgs:\n    adata: :class:`~anndata.AnnData` object object containing all observations.\n    n_pcs: Use this many PCs. If `n_pcs==0` use `.X` if `use_rep is None`.\n    use_rep: Use the indicated representation. `'X'` or any key for `.obsm` is valid.\n             If `None`, the representation is chosen automatically:\n             For `.n_vars` < 50, `.X` is used, otherwise 'X_pca' is used.\n             If 'X_pca' is not present, it\u2019s computed with default parameters.\n    perplexity: The perplexity is related to the number of nearest neighbors that\n                is used in other manifold learning algorithms. Larger datasets usually require a larger perplexity.\n                Consider selecting a value between 5 and 50. The choice is not extremely critical since t-SNE\n                is quite insensitive to this parameter.\n    early_exaggeration: Controls how tight natural clusters in the original space are in the\n                        embedded space and how much space will be between them. For larger\n                        values, the space between natural clusters will be larger in the\n                        embedded space. Again, the choice of this parameter is not very\n                        critical. If the cost function increases during initial optimization,\n                        the early exaggeration factor or the learning rate might be too high.\n    learning_rate: Note that the R-package \"Rtsne\" uses a default of 200.\n                   The learning rate can be a critical parameter. It should be\n                   between 100 and 1000. If the cost function increases during initial\n                   optimization, the early exaggeration factor or the learning rate\n                   might be too high. If the cost function gets stuck in a bad local\n                   minimum increasing the learning rate helps sometimes.\n    random_state: Change this to use different intial states for the optimization.\n                  If `None`, the initial state is not reproducible.\n    n_jobs: Number of jobs for parallel computation.\n            `None` means using :attr:`scanpy._settings.ScanpyConfig.n_jobs`.\n    copy: Return a copy instead of writing to `adata`.\n    metric: Distance metric calculate neighbors on.\n\nReturns:\n    Depending on `copy`, returns or updates `adata` with the following fields.\n\n    **X_tsne** : `np.ndarray` (`adata.obs`, dtype `float`) tSNE coordinates of data.",
        "description": "Calculates t-SNE [Maaten08]_ [Amir13]_ [Pedregosa11]_.t-distributed stochastic neighborhood embedding (tSNE) [Maaten08]_ has been\nproposed for visualizing complex by [Amir13]_. Here, by default, we use the implementation of *scikit-learn* [Pedregosa11]_.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "ehrapy.tools.tsne(adata=$, n_pcs=@, use_rep=@, perplexity=@, early_exaggeration=@, learning_rate=@, random_state=@, n_jobs=@, copy=@, metric=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.data.parkinsons": {
        "Parameters": {
            "encoded": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to return an already encoded object.",
                "optional_value": false
            },
            "columns_obs_only": {
                "type": "Optional[Union[dict[str, list[str]], list[str]]]",
                "default": "None",
                "optional": true,
                "description": "Columns to include in obs only and not X.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": ""
        },
        "Docstring": "Loads the Parkinsons Data Set\n\nMore details: http://archive.ics.uci.edu/ml/datasets/Parkinsons\nPreprocessing: https://github.com/theislab/ehrapy-datasets/blob/main/parkinsons/parkinsons.ipynb\n\nArgs:\n    encoded: Whether to return an already encoded object.\n    columns_obs_only: Columns to include in obs only and not X.\n\nReturns:\n    :class:`~anndata.AnnData` object of the Parkinsons Data Set\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.parkinsons(columns_obs_only=['name'], encoded=True)",
        "description": "Loads the Parkinsons Data SetMore details: http://archive.ics.uci.edu/ml/datasets/Parkinsons\nPreprocessing: https://github.com/theislab/ehrapy-datasets/blob/main/parkinsons/parkinsons.ipynb",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.parkinsons(columns_obs_only=['name'], encoded=True)",
        "api_type": "function",
        "api_calling": [
            "ehrapy.data.parkinsons(encoded=@, columns_obs_only=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.preprocessing.scale_norm": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object containing X to normalize values in. Must already be encoded using :func:`~ehrapy.preprocessing.encode`.",
                "optional_value": true
            },
            "vars": {
                "type": "Optional[Union[str, Sequence[str]]]",
                "default": "None",
                "optional": true,
                "description": "List of the names of the numeric variables to normalize.\nIf None all numeric variables will be normalized. Defaults to None .",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to return a copy or act in place . Defaults to False .",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[AnnData]",
            "description": ""
        },
        "Docstring": "Apply scaling normalization.\n\nFunctionality is provided by :func:`~sklearn.preprocessing.scale`, see https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.scale.html for details.\n\nArgs:\n    adata: :class:`~anndata.AnnData` object containing X to normalize values in. Must already be encoded using :func:`~ehrapy.preprocessing.encode`.\n    vars: List of the names of the numeric variables to normalize.\n          If None all numeric variables will be normalized. Defaults to None .\n    copy: Whether to return a copy or act in place . Defaults to False .\n    **kwargs: Additional arguments passed to :func:`~sklearn.preprocessing.scale`\n\nReturns:\n    :class:`~anndata.AnnData` object with normalized X. Also stores a record of applied normalizations as a dictionary in adata.uns[\"normalization\"].\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> adata_norm = ep.pp.scale_norm(adata, copy=True)",
        "description": "Apply scaling normalization.Functionality is provided by :func:`~sklearn.preprocessing.scale`, see https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.scale.html for details.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> adata_norm = ep.pp.scale_norm(adata, copy=True)",
        "api_type": "function",
        "api_calling": [
            "ehrapy.preprocessing.scale_norm(adata=$, vars=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.preprocessing.combat": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object object containing all observations.",
                "optional_value": true
            },
            "key": {
                "type": "str",
                "default": "batch",
                "optional": true,
                "description": "Key to a categorical annotation from :attr:`~anndata.AnnData.obs` that will be used for batch effect removal.",
                "optional_value": false
            },
            "covariates": {
                "type": "Optional[Collection[str]]",
                "default": "None",
                "optional": true,
                "description": "Additional covariates besides the batch variable such as adjustment variables or biological condition.\nThis parameter refers to the design matrix `X` in Equation 2.1 in [Johnson07]_ and to the `mod` argument in\nthe original combat function in the sva R package.\nNote that not including covariates may introduce bias or lead to the removal of signal in unbalanced designs.",
                "optional_value": false
            },
            "inplace": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to replace adata.X or to return the corrected data",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[Union[AnnData, ndarray]]",
            "description": ""
        },
        "Docstring": "ComBat function for batch effect correction [Johnson07]_ [Leek12]_ [Pedersen12]_.\n\nCorrects for batch effects by fitting linear models, gains statistical power via an EB framework where information is borrowed across features.\nThis uses the implementation `combat.py`_ [Pedersen12]_.\n\n.. _combat.py: https://github.com/brentp/combat.py\n\nArgs:\n    adata: :class:`~anndata.AnnData` object object containing all observations.\n    key: Key to a categorical annotation from :attr:`~anndata.AnnData.obs` that will be used for batch effect removal.\n    covariates: Additional covariates besides the batch variable such as adjustment variables or biological condition.\n                This parameter refers to the design matrix `X` in Equation 2.1 in [Johnson07]_ and to the `mod` argument in\n                the original combat function in the sva R package.\n                Note that not including covariates may introduce bias or lead to the removal of signal in unbalanced designs.\n    inplace: Whether to replace adata.X or to return the corrected data\n\nReturns:\n    Depending on the value of `inplace`, either returns the corrected matrix or modifies `adata.X`.",
        "description": "ComBat function for batch effect correction [Johnson07]_ [Leek12]_ [Pedersen12]_.Corrects for batch effects by fitting linear models, gains statistical power via an EB framework where information is borrowed across features.\nThis uses the implementation `combat.py`_ [Pedersen12]_.\n\n.. _combat.py: https://github.com/brentp/combat.py",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "ehrapy.preprocessing.combat(adata=$, key=@, covariates=@, inplace=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.plot.stacked_violin": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "var_names": {
                "type": "Union[_VarNames, Mapping[str, _VarNames]]",
                "default": null,
                "optional": false,
                "description": "`var_names` should be a valid subset of `adata.var_names`.\nIf `var_names` is a mapping, then the key is used as label\nto group the values (see `var_group_labels`). The mapping values\nshould be sequences of valid `adata.var_names`. In this\ncase either coloring or 'brackets' are used for the grouping\nof var names depending on the plot. When `var_names` is a mapping,\nthen the `var_group_labels` and `var_group_positions` are set.",
                "optional_value": false
            },
            "groupby": {
                "type": "Union[str, Sequence[str]]",
                "default": null,
                "optional": false,
                "description": "The key of the observation grouping to consider.",
                "optional_value": false
            },
            "log": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Plot on logarithmic axis.",
                "optional_value": false
            },
            "use_raw": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Use `raw` attribute of `adata` if present.",
                "optional_value": false
            },
            "num_categories": {
                "type": "int",
                "default": "7",
                "optional": true,
                "description": "Only used if groupby observation is not categorical. This value\ndetermines the number of groups into which the groupby observation should be subdivided.",
                "optional_value": false
            },
            "title": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Title for the figure",
                "optional_value": false
            },
            "colorbar_title": {
                "type": "Optional[str]",
                "default": "Median value\n in group",
                "optional": true,
                "description": "Title for the color bar. New line character (\\n) can be used.",
                "optional_value": false
            },
            "figsize": {
                "type": "Optional[tuple[float, float]]",
                "default": "None",
                "optional": true,
                "description": "Figure size when `multi_panel=True`. Otherwise the `rcParam['figure.figsize]` value is used.\nFormat is (width, height)",
                "optional_value": false
            },
            "dendrogram": {
                "type": "Union[bool, str]",
                "default": "False",
                "optional": true,
                "description": "If True or a valid dendrogram key, a dendrogram based on the hierarchical\nclustering between the `groupby` categories is added.\nThe dendrogram information is computed using :func:`scanpy.tl.dendrogram`.\nIf `tl.dendrogram` has not been called previously the function is called with default parameters.",
                "optional_value": false
            },
            "gene_symbols": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "var_group_positions": {
                "type": "Optional[Sequence[tuple[int, int]]]",
                "default": "None",
                "optional": true,
                "description": "Use this parameter to highlight groups of `var_names`.\nThis will draw a 'bracket' or a color block between the given start and end\npositions. If the parameter `var_group_labels` is set, the corresponding\nlabels are added on top/left. E.g. `var_group_positions=[(4,10)]`\nwill add a bracket between the fourth `var_name` and the tenth `var_name`.\nBy giving more positions, more brackets/color blocks are drawn.",
                "optional_value": false
            },
            "var_group_labels": {
                "type": "Optional[Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "Labels for each of the `var_group_positions` that want to be highlighted.",
                "optional_value": false
            },
            "standard_scale": {
                "type": "Optional[Literal['var', 'obs']]",
                "default": "None",
                "optional": true,
                "description": "Whether or not to standardize the given dimension between 0 and 1, meaning for\neach variable or group, subtract the minimum and divide each by its maximum.",
                "optional_value": true
            },
            "var_group_rotation": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Label rotation degrees. By default, labels larger than 4 characters are rotated 90 degrees.",
                "optional_value": false
            },
            "layer": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Name of the AnnData object layer that wants to be plotted. By default adata.raw.X is plotted.\nIf `use_raw=False` is set, then `adata.X` is plotted. If `layer` is set to a valid layer name,\nthen the layer is plotted. `layer` takes precedence over `use_raw`.",
                "optional_value": false
            },
            "stripplot": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Add a stripplot on top of the violin plot. See :func:`~seaborn.stripplot`.",
                "optional_value": false
            },
            "jitter": {
                "type": "Union[float, bool]",
                "default": "False",
                "optional": true,
                "description": "Add jitter to the stripplot (only when stripplot is True) See :func:`~seaborn.stripplot`.",
                "optional_value": false
            },
            "size": {
                "type": "int",
                "default": "1",
                "optional": true,
                "description": "Size of the jitter points.",
                "optional_value": false
            },
            "scale": {
                "type": "Literal['area', 'count', 'width']",
                "default": "width",
                "optional": true,
                "description": "The method used to scale the width of each violin.\nIf 'width' (the default), each violin will have the same width.\nIf 'area', each violin will have the same area.\nIf 'count', a violin\u2019s width corresponds to the number of observations.",
                "optional_value": true
            },
            "yticklabels": {
                "type": "Optional[bool]",
                "default": "False",
                "optional": true,
                "description": "Set to true to view the y tick labels",
                "optional_value": false
            },
            "order": {
                "type": "Optional[Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "Order in which to show the categories. Note: if `dendrogram=True`\nthe categories order will be given by the dendrogram and `order` will be ignored.",
                "optional_value": false
            },
            "swap_axes": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "By default, the x axis contains `var_names` (e.g. genes) and the y axis\nthe `groupby` categories. By setting `swap_axes` then x are the `groupby` categories and y the `var_names`.",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Whether to display the figure or return axis.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[bool, str]]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.",
                "optional_value": false
            },
            "return_fig": {
                "type": "Optional[bool]",
                "default": "False",
                "optional": true,
                "description": "Returns :class:`DotPlot` object. Useful for fine-tuning the plot. Takes precedence over `show=False`.",
                "optional_value": false
            },
            "row_palette": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Be default, median values are mapped to the violin color using a\ncolor map (see `cmap` argument). Alternatively, a 'row_palette` can\nbe given to color each violin plot row using a different colors.\nThe value should be a valid seaborn or matplotlib palette name (see :func:`~seaborn.color_palette`).\nAlternatively, a single color name or hex value can be passed, e.g. `'red'` or `'#cc33ff'`.",
                "optional_value": false
            },
            "cmap": {
                "type": "Optional[str]",
                "default": "Blues",
                "optional": true,
                "description": "String denoting matplotlib color map.",
                "optional_value": false
            },
            "ax": {
                "type": "Optional[_AxesSubplot]",
                "default": "None",
                "optional": true,
                "description": "A matplotlib axes object. Only works if plotting a single component.\nvmin: The value representing the lower limit of the color scale. Values smaller than vmin are plotted with the same color as vmin.",
                "optional_value": true
            },
            "vmin": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "vmax": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "The value representing the upper limit of the color scale. Values larger than vmax are plotted with the same color as vmax.",
                "optional_value": false
            },
            "vcenter": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "The value representing the center of the color scale. Useful for diverging colormaps.",
                "optional_value": false
            },
            "norm": {
                "type": "Optional[Normalize]",
                "default": "None",
                "optional": true,
                "description": "Custom color normalization object from matplotlib. See `https://matplotlib.org/stable/tutorials/colors/colormapnorms.html` for details.",
                "optional_value": true
            }
        },
        "Returns": {
            "type": "Optional[Union[StackedViolin, dict]]",
            "description": ""
        },
        "Docstring": "Stacked violin plots.\n\nMakes a compact image composed of individual violin plots (from :func:`~seaborn.violinplot`) stacked on top of each other.\n\nThis function provides a convenient interface to the :class:`~scanpy.pl.StackedViolin` class.\nIf you need more flexibility, you should use :class:`~scanpy.pl.StackedViolin` directly.\n\n\nArgs:\n    adata: Annotated data matrix.\n    var_names: `var_names` should be a valid subset of `adata.var_names`.\n               If `var_names` is a mapping, then the key is used as label\n               to group the values (see `var_group_labels`). The mapping values\n               should be sequences of valid `adata.var_names`. In this\n               case either coloring or 'brackets' are used for the grouping\n               of var names depending on the plot. When `var_names` is a mapping,\n               then the `var_group_labels` and `var_group_positions` are set.\n    groupby: The key of the observation grouping to consider.\n    use_raw: Use `raw` attribute of `adata` if present.\n    log: Plot on logarithmic axis.\n    num_categories: Only used if groupby observation is not categorical. This value\n                    determines the number of groups into which the groupby observation should be subdivided.\n    categories_order: Order in which to show the categories. Note: add_dendrogram or add_totals\n                      can change the categories order.\n    figsize: Figure size when `multi_panel=True`. Otherwise the `rcParam['figure.figsize]` value is used.\n             Format is (width, height)\n    dendrogram: If True or a valid dendrogram key, a dendrogram based on the hierarchical\n                clustering between the `groupby` categories is added.\n                The dendrogram information is computed using :func:`scanpy.tl.dendrogram`.\n                If `tl.dendrogram` has not been called previously the function is called with default parameters.\n    feature_symbols: Column name in `.var` DataFrame that stores feature symbols.\n                     By default `var_names` refer to the index column of the `.var` DataFrame.\n                     Setting this option allows alternative names to be used.\n    var_group_positions: Use this parameter to highlight groups of `var_names`.\n                         This will draw a 'bracket' or a color block between the given start and end\n                         positions. If the parameter `var_group_labels` is set, the corresponding\n                         labels are added on top/left. E.g. `var_group_positions=[(4,10)]`\n                         will add a bracket between the fourth `var_name` and the tenth `var_name`.\n                         By giving more positions, more brackets/color blocks are drawn.\n    var_group_labels: Labels for each of the `var_group_positions` that want to be highlighted.\n    var_group_rotation: Label rotation degrees. By default, labels larger than 4 characters are rotated 90 degrees.\n    layer: Name of the AnnData object layer that wants to be plotted. By default adata.raw.X is plotted.\n           If `use_raw=False` is set, then `adata.X` is plotted. If `layer` is set to a valid layer name,\n           then the layer is plotted. `layer` takes precedence over `use_raw`.\n    title: Title for the figure\n    colorbar_title: Title for the color bar. New line character (\\n) can be used.\n    cmap: String denoting matplotlib color map.\n    standard_scale: Whether or not to standardize the given dimension between 0 and 1, meaning for\n                    each variable or group, subtract the minimum and divide each by its maximum.\n    swap_axes: By default, the x axis contains `var_names` (e.g. genes) and the y axis\n         the `groupby` categories. By setting `swap_axes` then x are the `groupby` categories and y the `var_names`.\n    return_fig: Returns :class:`DotPlot` object. Useful for fine-tuning the plot. Takes precedence over `show=False`.\n    stripplot: Add a stripplot on top of the violin plot. See :func:`~seaborn.stripplot`.\n    jitter: Add jitter to the stripplot (only when stripplot is True) See :func:`~seaborn.stripplot`.\n    size: Size of the jitter points.\n    yticklabels: Set to true to view the y tick labels\n    order: Order in which to show the categories. Note: if `dendrogram=True`\n           the categories order will be given by the dendrogram and `order` will be ignored.\n    scale: The method used to scale the width of each violin.\n           If 'width' (the default), each violin will have the same width.\n           If 'area', each violin will have the same area.\n           If 'count', a violin\u2019s width corresponds to the number of observations.\n    row_palette: Be default, median values are mapped to the violin color using a\n                 color map (see `cmap` argument). Alternatively, a 'row_palette` can\n                 be given to color each violin plot row using a different colors.\n                 The value should be a valid seaborn or matplotlib palette name (see :func:`~seaborn.color_palette`).\n                 Alternatively, a single color name or hex value can be passed, e.g. `'red'` or `'#cc33ff'`.\n    show: Whether to display the figure or return axis.\n    save: If `True` or a `str`, save the figure.\n          A string is appended to the default filename.\n          Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\n    ax: A matplotlib axes object. Only works if plotting a single component.\n            vmin: The value representing the lower limit of the color scale. Values smaller than vmin are plotted with the same color as vmin.\n    vmax: The value representing the upper limit of the color scale. Values larger than vmax are plotted with the same color as vmax.\n    vcenter: The value representing the center of the color scale. Useful for diverging colormaps.\n    norm: Custom color normalization object from matplotlib. See `https://matplotlib.org/stable/tutorials/colors/colormapnorms.html` for details.\n    kwds:\n        Are passed to :func:`~seaborn.violinplot`.\n\nReturns:\n    If `return_fig` is `True`, returns a :class:`~scanpy.pl.StackedViolin` object, else if `show` is false, return axes dict\n\nExample:\n    .. code-block:: python\n\n        import ehrapy as ep\n\n        adata = ep.dt.mimic_2(encoded=True)\n        ep.pp.knn_impute(adata)\n        ep.pp.log_norm(adata, offset=1)\n        ep.pp.neighbors(adata)\n        ep.tl.leiden(adata, resolution=0.5, key_added=\"leiden_0_5\")\n        ep.pl.stacked_violin(\n            adata,\n            var_names=[\n                \"icu_los_day\",\n                \"hospital_los_day\",\n                \"age\",\n                \"gender_num\",\n                \"weight_first\",\n                \"bmi\",\n                \"sapsi_first\",\n                \"sofa_first\",\n                \"service_num\",\n                \"day_icu_intime_num\",\n                \"hour_icu_intime\",\n            ],\n            groupby=\"leiden_0_5\",\n        )\n\nPreview:\n    .. image:: /_static/docstring_previews/stacked_violin.png",
        "description": "Stacked violin plots.Makes a compact image composed of individual violin plots (from :func:`~seaborn.violinplot`) stacked on top of each other.\n\nThis function provides a convenient interface to the :class:`~scanpy.pl.StackedViolin` class.\nIf you need more flexibility, you should use :class:`~scanpy.pl.StackedViolin` directly.",
        "example": ".. code-block:: python\n\n        import ehrapy as ep\n\n        adata = ep.dt.mimic_2(encoded=True)\n        ep.pp.knn_impute(adata)\n        ep.pp.log_norm(adata, offset=1)\n        ep.pp.neighbors(adata)\n        ep.tl.leiden(adata, resolution=0.5, key_added=\"leiden_0_5\")\n        ep.pl.stacked_violin(\n            adata,\n            var_names=[\n                \"icu_los_day\",\n                \"hospital_los_day\",\n                \"age\",\n                \"gender_num\",\n                \"weight_first\",\n                \"bmi\",\n                \"sapsi_first\",\n                \"sofa_first\",\n                \"service_num\",\n                \"day_icu_intime_num\",\n                \"hour_icu_intime\",\n            ],\n            groupby=\"leiden_0_5\",\n        )\n\nPreview:\n    .. image:: /_static/docstring_previews/stacked_violin.png",
        "api_type": "function",
        "api_calling": [
            "ehrapy.plot.stacked_violin(adata=$, var_names=@, groupby=@, log=@, use_raw=@, num_categories=@, title=@, colorbar_title=@, figsize=@, dendrogram=@, gene_symbols=@, var_group_positions=@, var_group_labels=@, standard_scale=$, var_group_rotation=@, layer=@, stripplot=@, jitter=@, size=@, scale=$, yticklabels=@, order=@, swap_axes=@, show=@, save=@, return_fig=@, row_palette=@, cmap=@, ax=$, vmin=@, vmax=@, vcenter=@, norm=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.plot.pca_variance_ratio": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object object containing all observations.",
                "optional_value": true
            },
            "n_pcs": {
                "type": "int",
                "default": "30",
                "optional": true,
                "description": "Number of PCs to show.",
                "optional_value": false
            },
            "log": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Plot on logarithmic scale..",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Show the plot, do not return axis.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[bool, str]]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Plot the variance ratio.\n\nArgs:\n    adata: :class:`~anndata.AnnData` object object containing all observations.\n    n_pcs: Number of PCs to show.\n    log: Plot on logarithmic scale..\n    show: Show the plot, do not return axis.\n    save: If `True` or a `str`, save the figure.\n          A string is appended to the default filename.\n          Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\n\nReturns:\n    If `show==False` a :class:`~matplotlib.axes.Axes` or a list of it.\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.knn_impute(adata)\n    >>> ep.pp.log_norm(adata, offset=1)\n    >>> ep.pp.neighbors(adata)\n    >>> ep.pp.pca(adata)\n    >>> ep.pl.pca_variance_ratio(adata, n_pcs=8)\n\nPreview:\n    .. image:: /_static/docstring_previews/pca_variance_ratio.png",
        "description": "Plot the variance ratio.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.knn_impute(adata)\n    >>> ep.pp.log_norm(adata, offset=1)\n    >>> ep.pp.neighbors(adata)\n    >>> ep.pp.pca(adata)\n    >>> ep.pl.pca_variance_ratio(adata, n_pcs=8)\n\nPreview:\n    .. image:: /_static/docstring_previews/pca_variance_ratio.png",
        "api_type": "function",
        "api_calling": [
            "ehrapy.plot.pca_variance_ratio(adata=$, n_pcs=@, log=@, show=@, save=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.anndata.move_to_obs": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "The AnnData object",
                "optional_value": true
            },
            "to_obs": {
                "type": "Union[list[str], str]",
                "default": null,
                "optional": false,
                "description": "The columns to move to obs",
                "optional_value": false
            },
            "copy_obs": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "The values are copied to obs (and therefore kept in X) instead of moved completely",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": ""
        },
        "Docstring": "Move inplace or copy features from X to obs.\n\nNote that columns containing boolean values (either 0/1 or True(true)/False(false))\nwill be stored as boolean columns whereas the other non numerical columns will be stored as categorical.\n\nArgs:\n    adata: The AnnData object\n    to_obs: The columns to move to obs\n    copy_obs: The values are copied to obs (and therefore kept in X) instead of moved completely\n\nReturns:\n    The original AnnData object with moved or copied columns from X to obs\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.ad.move_to_obs(adata, ['age'], copy_obs=False)",
        "description": "Move inplace or copy features from X to obs.Note that columns containing boolean values (either 0/1 or True(true)/False(false))\nwill be stored as boolean columns whereas the other non numerical columns will be stored as categorical.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.ad.move_to_obs(adata, ['age'], copy_obs=False)",
        "api_type": "function",
        "api_calling": [
            "ehrapy.anndata.move_to_obs(adata=$, to_obs=@, copy_obs=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.preprocessing.quantile_norm": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object containing X to normalize values in. Must already be encoded using ~ehrapy.preprocessing.encode.encode.",
                "optional_value": true
            },
            "vars": {
                "type": "Optional[Union[str, Sequence[str]]]",
                "default": "None",
                "optional": true,
                "description": "List of the names of the numeric variables to normalize.\nIf None all numeric variables will be normalized. Defaults to None .",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to return a copy or act in place. Defaults to False .",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[AnnData]",
            "description": ""
        },
        "Docstring": "Apply quantile normalization.\n\nFunctionality is provided by :func:`~sklearn.preprocessing.quantile_transform`,\nsee https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.quantile_transform.html for details.\n\nArgs:\n    adata: :class:`~anndata.AnnData` object containing X to normalize values in. Must already be encoded using ~ehrapy.preprocessing.encode.encode.\n    vars: List of the names of the numeric variables to normalize.\n          If None all numeric variables will be normalized. Defaults to None .\n    copy: Whether to return a copy or act in place. Defaults to False .\n    **kwargs: Additional arguments passed to :func:`~sklearn.preprocessing.quantile_transform`\n\nReturns:\n    :class:`~anndata.AnnData` object with normalized X.\n    Also stores a record of applied normalizations as a dictionary in adata.uns[\"normalization\"].\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> adata_norm = ep.pp.quantile_norm(adata, copy=True)",
        "description": "Apply quantile normalization.Functionality is provided by :func:`~sklearn.preprocessing.quantile_transform`,\nsee https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.quantile_transform.html for details.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> adata_norm = ep.pp.quantile_norm(adata, copy=True)",
        "api_type": "function",
        "api_calling": [
            "ehrapy.preprocessing.quantile_norm(adata=$, vars=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.data.diabetes_130": {
        "Parameters": {
            "encoded": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to return an already encoded object",
                "optional_value": false
            },
            "columns_obs_only": {
                "type": "Optional[Union[dict[str, list[str]], list[str]]]",
                "default": "None",
                "optional": true,
                "description": "Columns to include in obs only and not X.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": ""
        },
        "Docstring": "Loads the diabetes-130 dataset\n\nMore details: http://archive.ics.uci.edu/ml/datasets/Diabetes+130-US+hospitals+for+years+1999-2008\nPreprocessing: https://github.com/theislab/ehrapy-datasets/tree/main/diabetes_130/diabetes_130.ipynb\n\nArgs:\n    encoded: Whether to return an already encoded object\n    columns_obs_only: Columns to include in obs only and not X.\n\nReturns:\n    :class:`~anndata.AnnData` object of the Diabetes 130 dataset\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.diabetes_130(encoded=True)",
        "description": "Loads the diabetes-130 datasetMore details: http://archive.ics.uci.edu/ml/datasets/Diabetes+130-US+hospitals+for+years+1999-2008\nPreprocessing: https://github.com/theislab/ehrapy-datasets/tree/main/diabetes_130/diabetes_130.ipynb",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.diabetes_130(encoded=True)",
        "api_type": "function",
        "api_calling": [
            "ehrapy.data.diabetes_130(encoded=@, columns_obs_only=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.tools.dendrogram": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object object containing all observations.",
                "optional_value": true
            },
            "groupby": {
                "type": "str",
                "default": null,
                "optional": false,
                "description": "Key to group by",
                "optional_value": false
            },
            "n_pcs": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Use this many PCs. If `n_pcs==0` use `.X` if `use_rep is None`.",
                "optional_value": false
            },
            "use_rep": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Use the indicated representation. `'X'` or any key for `.obsm` is valid.\nIf `None`, the representation is chosen automatically:\nFor `.n_vars` < 50, `.X` is used, otherwise 'X_pca' is used.\nIf 'X_pca' is not present, it\u2019s computed with default parameters.",
                "optional_value": false
            },
            "var_names": {
                "type": "Optional[Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "List of var_names to use for computing the hierarchical clustering.\nIf `var_names` is given, then `use_rep` and `n_pcs` is ignored.",
                "optional_value": false
            },
            "cor_method": {
                "type": "str",
                "default": "pearson",
                "optional": true,
                "description": "correlation method to use.\nOptions are 'pearson', 'kendall', and 'spearman'",
                "optional_value": false
            },
            "linkage_method": {
                "type": "str",
                "default": "complete",
                "optional": true,
                "description": "linkage method to use. See :func:`scipy.cluster.hierarchy.linkage` for more information.",
                "optional_value": false
            },
            "optimal_ordering": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Same as the optimal_ordering argument of :func:`scipy.cluster.hierarchy.linkage`\nwhich reorders the linkage matrix so that the distance between successive leaves is minimal.",
                "optional_value": false
            },
            "key_added": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "By default, the dendrogram information is added to\n`.uns[f'dendrogram_{{groupby}}']`.\nNotice that the `groupby` information is added to the dendrogram.",
                "optional_value": false
            },
            "inplace": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "If `True`, adds dendrogram information to `adata.uns[key_added]`,\nelse this function returns the information.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[Dict[str, Any]]",
            "description": ""
        },
        "Docstring": "Computes a hierarchical clustering for the given `groupby` categories.\n\nBy default, the PCA representation is used unless `.X` has less than 50 variables.\nAlternatively, a list of `var_names` (e.g. genes) can be given.\nAverage values of either `var_names` or components are used to compute a correlation matrix.\n\nThe hierarchical clustering can be visualized using\n:func:`ehrapy.pl.dendrogram` or multiple other visualizations that can\ninclude a dendrogram: :func:`~ehrapy.pl.matrixplot`,\n:func:`~ehrapy.pl.heatmap`, :func:`~ehrapy.pl.dotplot`,\nand :func:`~ehrapy.pl.stacked_violin`.\n\n.. note::\n    The computation of the hierarchical clustering is based on predefined\n    groups and not per observation. The correlation matrix is computed using by\n    default pearson but other methods are available.\n\nArgs:\n    adata: :class:`~anndata.AnnData` object object containing all observations.\n    groupby: Key to group by\n    n_pcs: Use this many PCs. If `n_pcs==0` use `.X` if `use_rep is None`.\n    use_rep: Use the indicated representation. `'X'` or any key for `.obsm` is valid.\n             If `None`, the representation is chosen automatically:\n             For `.n_vars` < 50, `.X` is used, otherwise 'X_pca' is used.\n             If 'X_pca' is not present, it\u2019s computed with default parameters.\n    var_names: List of var_names to use for computing the hierarchical clustering.\n               If `var_names` is given, then `use_rep` and `n_pcs` is ignored.\n    cor_method: correlation method to use.\n                Options are 'pearson', 'kendall', and 'spearman'\n    linkage_method: linkage method to use. See :func:`scipy.cluster.hierarchy.linkage` for more information.\n    optimal_ordering: Same as the optimal_ordering argument of :func:`scipy.cluster.hierarchy.linkage`\n                      which reorders the linkage matrix so that the distance between successive leaves is minimal.\n    key_added: By default, the dendrogram information is added to\n               `.uns[f'dendrogram_{{groupby}}']`.\n               Notice that the `groupby` information is added to the dendrogram.\n    inplace: If `True`, adds dendrogram information to `adata.uns[key_added]`,\n             else this function returns the information.\nReturns:\n    If `inplace=False`, returns dendrogram information, else `adata.uns[key_added]` is updated with it.\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.data.mimic_2(encoded=True)\n    >>> ep.tl.dendrogram(adata, groupby='service_unit')\n    >>> ep.pl.dendrogram(adata)",
        "description": "Computes a hierarchical clustering for the given `groupby` categories.By default, the PCA representation is used unless `.X` has less than 50 variables.\nAlternatively, a list of `var_names` (e.g. genes) can be given.\nAverage values of either `var_names` or components are used to compute a correlation matrix.\n\nThe hierarchical clustering can be visualized using\n:func:`ehrapy.pl.dendrogram` or multiple other visualizations that can\ninclude a dendrogram: :func:`~ehrapy.pl.matrixplot`,\n:func:`~ehrapy.pl.heatmap`, :func:`~ehrapy.pl.dotplot`,\nand :func:`~ehrapy.pl.stacked_violin`.\n\n.. note::\n    The computation of the hierarchical clustering is based on predefined\n    groups and not per observation. The correlation matrix is computed using by\n    default pearson but other methods are available.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.data.mimic_2(encoded=True)\n    >>> ep.tl.dendrogram(adata, groupby='service_unit')\n    >>> ep.pl.dendrogram(adata)",
        "api_type": "function",
        "api_calling": [
            "ehrapy.tools.dendrogram(adata=$, groupby=@, n_pcs=@, use_rep=@, var_names=@, cor_method=@, linkage_method=@, optimal_ordering=@, key_added=@, inplace=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.tools.test_kmf_logrank": {
        "Parameters": {
            "kmf_A": {
                "type": "KaplanMeierFitter",
                "default": null,
                "optional": false,
                "description": "The first KaplanMeierFitter object containing the durations and events.",
                "optional_value": true
            },
            "kmf_B": {
                "type": "KaplanMeierFitter",
                "default": null,
                "optional": false,
                "description": "The second KaplanMeierFitter object containing the durations and events.",
                "optional_value": true
            },
            "t_0": {
                "type": "Optional[float]",
                "default": "-1",
                "optional": true,
                "description": "The final time period under observation, and subjects who experience the event after this time are set to be censored.\nSpecify -1 to use all time. Defaults to -1.",
                "optional_value": false
            },
            "weightings": {
                "type": "Optional[Literal['wilcoxon', 'tarone-ware', 'peto', 'fleming-harrington']]",
                "default": "None",
                "optional": true,
                "description": "Apply a weighted logrank test: options are \"wilcoxon\" for Wilcoxon (also known as Breslow), \"tarone-ware\"\nfor Tarone-Ware, \"peto\" for Peto test and \"fleming-harrington\" for Fleming-Harrington test.\nThese are useful for testing for early or late differences in the survival curve. For the Fleming-Harrington\ntest, keyword arguments p and q must also be provided with non-negative values.",
                "optional_value": true
            }
        },
        "Returns": {
            "type": "StatisticalResult",
            "description": ""
        },
        "Docstring": "Calculates the p-value for the logrank test comparing the survival functions of two groups.\n\nSee https://lifelines.readthedocs.io/en/latest/lifelines.statistics.html\n\nMeasures and reports on whether two intensity processes are different.\nThat is, given two event series, determines whether the data generating processes are statistically different.\nThe test-statistic is chi-squared under the null hypothesis.\n\nArgs:\n    kmf_A: The first KaplanMeierFitter object containing the durations and events.\n    kmf_B: The second KaplanMeierFitter object containing the durations and events.\n    t_0: The final time period under observation, and subjects who experience the event after this time are set to be censored.\n         Specify -1 to use all time. Defaults to -1.\n    weightings: Apply a weighted logrank test: options are \"wilcoxon\" for Wilcoxon (also known as Breslow), \"tarone-ware\"\n                for Tarone-Ware, \"peto\" for Peto test and \"fleming-harrington\" for Fleming-Harrington test.\n                These are useful for testing for early or late differences in the survival curve. For the Fleming-Harrington\n                test, keyword arguments p and q must also be provided with non-negative values.\n\nReturns:\n    The p-value for the logrank test comparing the survival functions of the two groups.",
        "description": "Calculates the p-value for the logrank test comparing the survival functions of two groups.See https://lifelines.readthedocs.io/en/latest/lifelines.statistics.html\n\nMeasures and reports on whether two intensity processes are different.\nThat is, given two event series, determines whether the data generating processes are statistically different.\nThe test-statistic is chi-squared under the null hypothesis.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "ehrapy.tools.test_kmf_logrank(kmf_A=$, kmf_B=$, t_0=@, weightings=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.data.heart_failure": {
        "Parameters": {
            "encoded": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to return an already encoded object",
                "optional_value": false
            },
            "columns_obs_only": {
                "type": "Optional[Union[dict[str, list[str]], list[str]]]",
                "default": "None",
                "optional": true,
                "description": "Columns to include in obs only and not X.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": ""
        },
        "Docstring": "Loads the heart failure dataset.\n\nMore details: http://archive.ics.uci.edu/ml/datasets/Heart+failure+clinical+records\nPreprocessing: https://github.com/theislab/ehrapy-datasets/tree/main/heart_failure\nThis dataset only contains numericals and therefore does not need any encoding.\n\nArgs:\n    encoded: Whether to return an already encoded object\n    columns_obs_only: Columns to include in obs only and not X.\n\nReturns:\n    :class:`~anndata.AnnData` object of the heart failure dataset\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.heart_failure(encoded=True)",
        "description": "Loads the heart failure dataset.More details: http://archive.ics.uci.edu/ml/datasets/Heart+failure+clinical+records\nPreprocessing: https://github.com/theislab/ehrapy-datasets/tree/main/heart_failure\nThis dataset only contains numericals and therefore does not need any encoding.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.heart_failure(encoded=True)",
        "api_type": "function",
        "api_calling": [
            "ehrapy.data.heart_failure(encoded=@, columns_obs_only=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.plot.tracksplot": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "var_names": {
                "type": "Union[_VarNames, Mapping[str, _VarNames]]",
                "default": null,
                "optional": false,
                "description": "`var_names` should be a valid subset of `adata.var_names`.\nIf `var_names` is a mapping, then the key is used as label\nto group the values (see `var_group_labels`). The mapping values\nshould be sequences of valid `adata.var_names`. In this\ncase either coloring or 'brackets' are used for the grouping\nof var names depending on the plot. When `var_names` is a mapping,\nthen the `var_group_labels` and `var_group_positions` are set.",
                "optional_value": false
            },
            "groupby": {
                "type": "str",
                "default": null,
                "optional": false,
                "description": "The key of the observation grouping to consider.",
                "optional_value": false
            },
            "use_raw": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Use `raw` attribute of `adata` if present.",
                "optional_value": false
            },
            "log": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Plot on logarithmic axis.",
                "optional_value": false
            },
            "dendrogram": {
                "type": "Union[bool, str]",
                "default": "False",
                "optional": true,
                "description": "If True or a valid dendrogram key, a dendrogram based on the hierarchical\nclustering between the `groupby` categories is added.\nThe dendrogram information is computed using :func:`scanpy.tl.dendrogram`.\nIf `tl.dendrogram` has not been called previously the function is called with default parameters.",
                "optional_value": false
            },
            "feature_symbols": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Column name in `.var` DataFrame that stores feature symbols.\nBy default `var_names` refer to the index column of the `.var` DataFrame.\nSetting this option allows alternative names to be used.",
                "optional_value": false
            },
            "var_group_positions": {
                "type": "Optional[Sequence[tuple[int, int]]]",
                "default": "None",
                "optional": true,
                "description": "Use this parameter to highlight groups of `var_names`.\nThis will draw a 'bracket' or a color block between the given start and end\npositions. If the parameter `var_group_labels` is set, the corresponding\nlabels are added on top/left. E.g. `var_group_positions=[(4,10)]`\nwill add a bracket between the fourth `var_name` and the tenth `var_name`.\nBy giving more positions, more brackets/color blocks are drawn.",
                "optional_value": false
            },
            "var_group_labels": {
                "type": "Optional[Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "Labels for each of the `var_group_positions` that want to be highlighted.",
                "optional_value": false
            },
            "layer": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Name of the AnnData object layer that wants to be plotted. By default adata.raw.X is plotted.\nIf `use_raw=False` is set, then `adata.X` is plotted. If `layer` is set to a valid layer name,\nthen the layer is plotted. `layer` takes precedence over `use_raw`.",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Whether to display the figure or return axis.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[str, bool]]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.",
                "optional_value": false
            },
            "figsize": {
                "type": "Optional[tuple[float, float]]",
                "default": "None",
                "optional": true,
                "description": "Figure size when `multi_panel=True`. Otherwise the `rcParam['figure.figsize]` value is used.\nFormat is (width, height)",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[dict[str, list]]",
            "description": ""
        },
        "Docstring": "Plots a filled line plot.\n\nIn this type of plot each var_name is plotted as a filled line plot where the\ny values correspond to the var_name values and x is each of the observations. Best results\nare obtained when using raw counts that are not log.\n`groupby` is required to sort and order the values using the respective group and should be a categorical value.\n\nArgs:\n    adata: Annotated data matrix.\n    var_names: `var_names` should be a valid subset of `adata.var_names`.\n               If `var_names` is a mapping, then the key is used as label\n               to group the values (see `var_group_labels`). The mapping values\n               should be sequences of valid `adata.var_names`. In this\n               case either coloring or 'brackets' are used for the grouping\n               of var names depending on the plot. When `var_names` is a mapping,\n               then the `var_group_labels` and `var_group_positions` are set.\n    groupby: The key of the observation grouping to consider.\n    use_raw: Use `raw` attribute of `adata` if present.\n    log: Plot on logarithmic axis.\n    num_categories: Only used if groupby observation is not categorical. This value\n                    determines the number of groups into which the groupby observation should be subdivided.\n    categories_order: Order in which to show the categories. Note: add_dendrogram or add_totals\n                      can change the categories order.\n    figsize: Figure size when `multi_panel=True`. Otherwise the `rcParam['figure.figsize]` value is used.\n             Format is (width, height)\n    dendrogram: If True or a valid dendrogram key, a dendrogram based on the hierarchical\n                clustering between the `groupby` categories is added.\n                The dendrogram information is computed using :func:`scanpy.tl.dendrogram`.\n                If `tl.dendrogram` has not been called previously the function is called with default parameters.\n    feature_symbols: Column name in `.var` DataFrame that stores feature symbols.\n                     By default `var_names` refer to the index column of the `.var` DataFrame.\n                     Setting this option allows alternative names to be used.\n    var_group_positions: Use this parameter to highlight groups of `var_names`.\n                         This will draw a 'bracket' or a color block between the given start and end\n                         positions. If the parameter `var_group_labels` is set, the corresponding\n                         labels are added on top/left. E.g. `var_group_positions=[(4,10)]`\n                         will add a bracket between the fourth `var_name` and the tenth `var_name`.\n                         By giving more positions, more brackets/color blocks are drawn.\n    var_group_labels: Labels for each of the `var_group_positions` that want to be highlighted.\n    var_group_rotation: Label rotation degrees. By default, labels larger than 4 characters are rotated 90 degrees.\n    layer: Name of the AnnData object layer that wants to be plotted. By default adata.raw.X is plotted.\n           If `use_raw=False` is set, then `adata.X` is plotted. If `layer` is set to a valid layer name,\n           then the layer is plotted. `layer` takes precedence over `use_raw`.\n    show: Whether to display the figure or return axis.\n    save: If `True` or a `str`, save the figure.\n          A string is appended to the default filename.\n          Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\n    ax: A matplotlib axes object. Only works if plotting a single component.\n    **kwds:\n        Are passed to :func:`~seaborn.heatmap`.\n\nReturns:\n    A list of :class:`~matplotlib.axes.Axes`.\n\nExample:\n    .. code-block:: python\n\n        import ehrapy as ep\n\n        adata = ep.dt.mimic_2(encoded=True)\n        ep.pp.knn_impute(adata)\n        ep.pp.neighbors(adata)\n        ep.tl.leiden(adata, resolution=0.5, key_added=\"leiden_0_5\")\n        ep.pl.tracksplot(\n            adata,\n            var_names=[\n                \"age\",\n                \"gender_num\",\n                \"weight_first\",\n                \"bmi\",\n                \"sapsi_first\",\n                \"sofa_first\",\n                \"service_num\",\n                \"day_icu_intime_num\",\n                \"hour_icu_intime\",\n            ],\n            groupby=\"leiden_0_5\",\n        )\n\nPreview:\n    .. image:: /_static/docstring_previews/tracksplot.png",
        "description": "Plots a filled line plot.In this type of plot each var_name is plotted as a filled line plot where the\ny values correspond to the var_name values and x is each of the observations. Best results\nare obtained when using raw counts that are not log.\n`groupby` is required to sort and order the values using the respective group and should be a categorical value.",
        "example": ".. code-block:: python\n\n        import ehrapy as ep\n\n        adata = ep.dt.mimic_2(encoded=True)\n        ep.pp.knn_impute(adata)\n        ep.pp.neighbors(adata)\n        ep.tl.leiden(adata, resolution=0.5, key_added=\"leiden_0_5\")\n        ep.pl.tracksplot(\n            adata,\n            var_names=[\n                \"age\",\n                \"gender_num\",\n                \"weight_first\",\n                \"bmi\",\n                \"sapsi_first\",\n                \"sofa_first\",\n                \"service_num\",\n                \"day_icu_intime_num\",\n                \"hour_icu_intime\",\n            ],\n            groupby=\"leiden_0_5\",\n        )\n\nPreview:\n    .. image:: /_static/docstring_previews/tracksplot.png",
        "api_type": "function",
        "api_calling": [
            "ehrapy.plot.tracksplot(adata=$, var_names=@, groupby=@, use_raw=@, log=@, dendrogram=@, feature_symbols=@, var_group_positions=@, var_group_labels=@, layer=@, show=@, save=@, figsize=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.preprocessing.nuclear_norm_minimization_impute": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "The AnnData object to apply NuclearNormMinimization on.",
                "optional_value": true
            },
            "var_names": {
                "type": "Optional[Iterable[str]]",
                "default": "None",
                "optional": true,
                "description": "Var names indicating which columns to impute (if None -> all columns).",
                "optional_value": false
            },
            "warning_threshold": {
                "type": "int",
                "default": "70",
                "optional": true,
                "description": "Threshold of percentage of missing values to display a warning for. Defaults to 30.",
                "optional_value": false
            },
            "require_symmetric_solution": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to add a symmetry constraint to the convex problem. Defaults to False.",
                "optional_value": false
            },
            "min_value": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Smallest possible imputed value. Defaults to None (no minimum value constraint).",
                "optional_value": false
            },
            "max_value": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Largest possible imputed value. Defaults to None (no maximum value constraint).",
                "optional_value": false
            },
            "error_tolerance": {
                "type": "float",
                "default": "0.0001",
                "optional": true,
                "description": "Degree of error allowed on reconstructed values. Defaults to 0.0001.",
                "optional_value": false
            },
            "max_iters": {
                "type": "int",
                "default": "50000",
                "optional": true,
                "description": "Maximum number of iterations for the convex solver. Defaults to 50000.",
                "optional_value": false
            },
            "verbose": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to print debug information. Defaults to False.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to return a copy of the AnnData object or act in place. Defaults to False (act in place).",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": ""
        },
        "Docstring": "Impute data using the NuclearNormMinimization.\n\nSee https://github.com/iskandr/fancyimpute/blob/master/fancyimpute/nuclear_norm_minimization.py\nSimple implementation of \"Exact Matrix Completion via Convex Optimization\" by Emmanuel Candes and Benjamin Recht using cvxpy.\n\nArgs:\n    adata: The AnnData object to apply NuclearNormMinimization on.\n    var_names: Var names indicating which columns to impute (if None -> all columns).\n    warning_threshold: Threshold of percentage of missing values to display a warning for. Defaults to 30.\n    require_symmetric_solution: Whether to add a symmetry constraint to the convex problem. Defaults to False.\n    min_value: Smallest possible imputed value. Defaults to None (no minimum value constraint).\n    max_value: Largest possible imputed value. Defaults to None (no maximum value constraint).\n    error_tolerance: Degree of error allowed on reconstructed values. Defaults to 0.0001.\n    max_iters: Maximum number of iterations for the convex solver. Defaults to 50000.\n    verbose: Whether to print debug information. Defaults to False.\n    copy: Whether to return a copy of the AnnData object or act in place. Defaults to False (act in place).\n\nReturns:\n    The imputed AnnData object.\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.nuclear_norm_minimization_impute(adata)",
        "description": "Impute data using the NuclearNormMinimization.See https://github.com/iskandr/fancyimpute/blob/master/fancyimpute/nuclear_norm_minimization.py\nSimple implementation of \"Exact Matrix Completion via Convex Optimization\" by Emmanuel Candes and Benjamin Recht using cvxpy.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.nuclear_norm_minimization_impute(adata)",
        "api_type": "function",
        "api_calling": [
            "ehrapy.preprocessing.nuclear_norm_minimization_impute(adata=$, var_names=@, warning_threshold=@, require_symmetric_solution=@, min_value=@, max_value=@, error_tolerance=@, max_iters=@, verbose=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.preprocessing.iterative_svd_impute": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "An AnnData object to impute missing values in.",
                "optional_value": true
            },
            "var_names": {
                "type": "Optional[Iterable[str]]",
                "default": "None",
                "optional": true,
                "description": "A list of var names indicating which columns to impute. If `None`, all columns will be imputed.\nDefaults to None.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to return a copy of the AnnData object or act in place. Defaults to False.",
                "optional_value": false
            },
            "warning_threshold": {
                "type": "int",
                "default": "70",
                "optional": true,
                "description": "Threshold of percentage of missing values to display a warning for. Defaults to 30.",
                "optional_value": false
            },
            "rank": {
                "type": "int",
                "default": "10",
                "optional": true,
                "description": "Rank of the SVD decomposition. Defaults to 10.",
                "optional_value": false
            },
            "convergence_threshold": {
                "type": "float",
                "default": "1e-05",
                "optional": true,
                "description": "Convergence threshold for the iterative algorithm.\nThe algorithm stops when the relative difference in\nFrobenius norm between two iterations is less than `convergence_threshold`.\nDefaults to 0.00001.",
                "optional_value": false
            },
            "max_iters": {
                "type": "int",
                "default": "200",
                "optional": true,
                "description": "Maximum number of iterations. The algorithm stops after `max_iters` iterations if it does not converge.\nDefaults to 200.",
                "optional_value": false
            },
            "gradual_rank_increase": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to increase the rank gradually or to use the rank value immediately.\nDefaults to True.",
                "optional_value": false
            },
            "svd_algorithm": {
                "type": "Literal['arpack', 'randomized']",
                "default": "arpack",
                "optional": true,
                "description": "The SVD algorithm to use. Can be one of {'arpack', 'randomized'}. Defaults to `arpack`.",
                "optional_value": true
            },
            "init_fill_method": {
                "type": "Literal['zero', 'mean', 'median']",
                "default": "mean",
                "optional": true,
                "description": "The fill method to use for initializing missing values. Can be one of `{'zero', 'mean', 'median'}`.\nDefaults to `mean`.",
                "optional_value": true
            },
            "min_value": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "The minimum value allowed for the imputed data. Any imputed value less than `min_value` is clipped to `min_value`.\nDefaults to None.",
                "optional_value": false
            },
            "max_value": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "The maximum value allowed for the imputed data. Any imputed value greater than `max_value` is clipped to `max_value`.\nDefaults to None.",
                "optional_value": false
            },
            "verbose": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to print progress messages during the imputation. Defaults to False.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": ""
        },
        "Docstring": "Impute missing values in an AnnData object using the IterativeSVD algorithm.\n\nThe IterativeSVD algorithm is a matrix completion method based on iterative low-rank singular value decomposition (SVD).\nThis function can impute missing values for numerical and ordinal-encoded data.\n\nArgs:\n    adata: An AnnData object to impute missing values in.\n    var_names: A list of var names indicating which columns to impute. If `None`, all columns will be imputed.\n               Defaults to None.\n    copy: Whether to return a copy of the AnnData object or act in place. Defaults to False.\n    warning_threshold: Threshold of percentage of missing values to display a warning for. Defaults to 30.\n    rank: Rank of the SVD decomposition. Defaults to 10.\n    convergence_threshold: Convergence threshold for the iterative algorithm.\n                           The algorithm stops when the relative difference in\n                           Frobenius norm between two iterations is less than `convergence_threshold`.\n                           Defaults to 0.00001.\n    max_iters: Maximum number of iterations. The algorithm stops after `max_iters` iterations if it does not converge.\n               Defaults to 200.\n    gradual_rank_increase: Whether to increase the rank gradually or to use the rank value immediately.\n                           Defaults to True.\n    svd_algorithm: The SVD algorithm to use. Can be one of {'arpack', 'randomized'}. Defaults to `arpack`.\n    init_fill_method: The fill method to use for initializing missing values. Can be one of `{'zero', 'mean', 'median'}`.\n                      Defaults to `mean`.\n    min_value: The minimum value allowed for the imputed data. Any imputed value less than `min_value` is clipped to `min_value`.\n               Defaults to None.\n    max_value: The maximum value allowed for the imputed data. Any imputed value greater than `max_value` is clipped to `max_value`.\n               Defaults to None.\n    verbose: Whether to print progress messages during the imputation. Defaults to False.\n\nReturns:\n    An AnnData object with imputed values.\n\nRaises:\n    ValueError:\n        If `svd_algorithm` is not one of `{'arpack', 'randomized'}`.\n    ValueError:\n        If `init_fill_method` is not one of `{'zero', 'mean', 'median'}`.\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.iterative_svd_impute(adata)",
        "description": "Impute missing values in an AnnData object using the IterativeSVD algorithm.The IterativeSVD algorithm is a matrix completion method based on iterative low-rank singular value decomposition (SVD).\nThis function can impute missing values for numerical and ordinal-encoded data.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.iterative_svd_impute(adata)",
        "api_type": "function",
        "api_calling": [
            "ehrapy.preprocessing.iterative_svd_impute(adata=$, var_names=@, copy=@, warning_threshold=@, rank=@, convergence_threshold=@, max_iters=@, gradual_rank_increase=@, svd_algorithm=$, init_fill_method=$, min_value=@, max_value=@, verbose=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.preprocessing.neighbors": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object object containing all observations.",
                "optional_value": true
            },
            "n_neighbors": {
                "type": "int",
                "default": "15",
                "optional": true,
                "description": "The size of local neighborhood (in terms of number of neighboring data points) used for manifold approximation.\nLarger values result in more global views of the manifold, while smaller values result in more local data being preserved.\nIn general values should be in the range 2 to 100. If `knn` is `True`, number of nearest neighbors to be searched.\nIf `knn` is `False`, a Gaussian kernel width is set to the distance of the `n_neighbors` neighbor.",
                "optional_value": false
            },
            "n_pcs": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Use this many PCs. If `n_pcs==0` use `.X` if `use_rep is None`.",
                "optional_value": false
            },
            "use_rep": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Use the indicated representation. `'X'` or any key for `.obsm` is valid.\nIf `None`, the representation is chosen automatically:\nFor `.n_vars` < 50, `.X` is used, otherwise 'X_pca' is used.\nIf 'X_pca' is not present, it\u2019s computed with default parameters.",
                "optional_value": false
            },
            "knn": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "If `True`, use a hard threshold to restrict the number of neighbors to `n_neighbors`, that is, consider a knn graph.\nOtherwise, use a Gaussian Kernel to assign low weights to neighbors more distant than the `n_neighbors` nearest neighbor.",
                "optional_value": false
            },
            "random_state": {
                "type": "Optional[Union[int, RandomState]]",
                "default": "0",
                "optional": true,
                "description": "A numpy random seed.",
                "optional_value": false
            },
            "method": {
                "type": "Optional[Literal[umap, gauss, rapids]]",
                "default": "umap",
                "optional": true,
                "description": "Use 'umap' [McInnes18]_ or 'gauss' (Gauss kernel following [Coifman05]_ with adaptive width [Haghverdi16]_) for computing connectivities.\nUse 'rapids' for the RAPIDS implementation of UMAP (experimental, GPU only).",
                "optional_value": true
            },
            "metric": {
                "type": "Union[Literal[cityblock, cosine, euclidean, l1, l2, manhattan], Literal[braycurtis, canberra, chebyshev, correlation, dice, hamming, jaccard, kulsinski, mahalanobis, minkowski, rogerstanimoto, russellrao, seuclidean, sokalmichener, sokalsneath, sqeuclidean, yule], Callable[ndarray, ndarray, float]]",
                "default": "euclidean",
                "optional": true,
                "description": "A known metric\u2019s name or a callable that returns a distance.",
                "optional_value": false
            },
            "key_added": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "If not specified, the neighbors data is stored in .uns['neighbors'],\ndistances and connectivities are stored in .obsp['distances'] and .obsp['connectivities'] respectively.\nIf specified, the neighbors data is added to .uns[key_added], distances are stored in .obsp[key_added+'_distances']\nand connectivities in .obsp[key_added+'_connectivities'].",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Determines whether a copy of `adata` is returned.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[AnnData]",
            "description": ""
        },
        "Docstring": "Compute a neighborhood graph of observations [McInnes18]_.\n\nThe neighbor search efficiency of this heavily relies on UMAP [McInnes18]_,\nwhich also provides a method for estimating connectivities of data points -\nthe connectivity of the manifold (`method=='umap'`). If `method=='gauss'`,\nconnectivities are computed according to [Coifman05]_, in the adaption of [Haghverdi16]_.\n\nArgs:\n    adata: :class:`~anndata.AnnData` object object containing all observations.\n    n_neighbors: The size of local neighborhood (in terms of number of neighboring data points) used for manifold approximation.\n                 Larger values result in more global views of the manifold, while smaller values result in more local data being preserved.\n                 In general values should be in the range 2 to 100. If `knn` is `True`, number of nearest neighbors to be searched.\n                 If `knn` is `False`, a Gaussian kernel width is set to the distance of the `n_neighbors` neighbor.\n    n_pcs: Use this many PCs. If `n_pcs==0` use `.X` if `use_rep is None`.\n    use_rep: Use the indicated representation. `'X'` or any key for `.obsm` is valid.\n             If `None`, the representation is chosen automatically:\n             For `.n_vars` < 50, `.X` is used, otherwise 'X_pca' is used.\n             If 'X_pca' is not present, it\u2019s computed with default parameters.\n    knn: If `True`, use a hard threshold to restrict the number of neighbors to `n_neighbors`, that is, consider a knn graph.\n         Otherwise, use a Gaussian Kernel to assign low weights to neighbors more distant than the `n_neighbors` nearest neighbor.\n    random_state: A numpy random seed.\n    method: Use 'umap' [McInnes18]_ or 'gauss' (Gauss kernel following [Coifman05]_ with adaptive width [Haghverdi16]_) for computing connectivities.\n            Use 'rapids' for the RAPIDS implementation of UMAP (experimental, GPU only).\n    metric: A known metric\u2019s name or a callable that returns a distance.\n    metric_kwds: Options for the metric.\n    key_added: If not specified, the neighbors data is stored in .uns['neighbors'],\n               distances and connectivities are stored in .obsp['distances'] and .obsp['connectivities'] respectively.\n               If specified, the neighbors data is added to .uns[key_added], distances are stored in .obsp[key_added+'_distances']\n               and connectivities in .obsp[key_added+'_connectivities'].\n    copy: Determines whether a copy of `adata` is returned.\n\nReturns:\n     Depending on `copy`, updates or returns `adata` with the following;\n     See `key_added` parameter description for the storage path of connectivities and distances.\n\n     **connectivities** : sparse matrix of dtype `float32`.\n     Weighted adjacency matrix of the neighborhood graph of data points. Weights should be interpreted as connectivities.\n\n     **distances** : sparse matrix of dtype `float32`.\n     Instead of decaying weights, this stores distances for each pair of neighbors.",
        "description": "Compute a neighborhood graph of observations [McInnes18]_.The neighbor search efficiency of this heavily relies on UMAP [McInnes18]_,\nwhich also provides a method for estimating connectivities of data points -\nthe connectivity of the manifold (`method=='umap'`). If `method=='gauss'`,\nconnectivities are computed according to [Coifman05]_, in the adaption of [Haghverdi16]_.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "ehrapy.preprocessing.neighbors(adata=$, n_neighbors=@, n_pcs=@, use_rep=@, knn=@, random_state=@, method=$, metric=@, key_added=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.data.statlog_heart": {
        "Parameters": {
            "encoded": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to return an already encoded object",
                "optional_value": false
            },
            "columns_obs_only": {
                "type": "Optional[Union[dict[str, list[str]], list[str]]]",
                "default": "None",
                "optional": true,
                "description": "Columns to include in obs only and not X.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": ""
        },
        "Docstring": "Loads the Statlog (Heart) Data Set\n\nMore details: http://archive.ics.uci.edu/ml/datasets/Statlog+%28Heart%29\nPreprocessing: https://github.com/theislab/ehrapy-datasets/blob/main/statlog_heart/statlog_heart.ipynb\n\nArgs:\n    encoded: Whether to return an already encoded object\n    columns_obs_only: Columns to include in obs only and not X.\n\nReturns:\n    :class:`~anndata.AnnData` object of the Statlog (Heart) Data Set\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.statlog_heart(encoded=True)",
        "description": "Loads the Statlog (Heart) Data SetMore details: http://archive.ics.uci.edu/ml/datasets/Statlog+%28Heart%29\nPreprocessing: https://github.com/theislab/ehrapy-datasets/blob/main/statlog_heart/statlog_heart.ipynb",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.statlog_heart(encoded=True)",
        "api_type": "function",
        "api_calling": [
            "ehrapy.data.statlog_heart(encoded=@, columns_obs_only=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.plot.rank_features_groups_dotplot": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "groups": {
                "type": "Union[str, Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "List of group names.",
                "optional_value": false
            },
            "n_features": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Number of features to show. Is ignored if `feature_names` is passed.",
                "optional_value": false
            },
            "groupby": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Which key to group the features by.",
                "optional_value": false
            },
            "values_to_plot": {
                "type": "Optional[Literal['scores', 'logfoldchanges', 'pvals', 'pvals_adj', 'log10_pvals', 'log10_pvals_adj']]",
                "default": "None",
                "optional": true,
                "description": "Key to plot. One of 'scores', 'logfoldchanges', 'pvals', 'pvalds_adj',\n'log10_pvals', 'log10_pvalds_adj'.",
                "optional_value": true
            },
            "var_names": {
                "type": "Optional[Union[Sequence[str], Mapping[str, Sequence[str]]]]",
                "default": "None",
                "optional": true,
                "description": "Feature names.",
                "optional_value": false
            },
            "feature_symbols": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Key for field in `.var` that stores feature symbols if you do not want to\nuse `.var_names` displayed in the plot.",
                "optional_value": false
            },
            "min_logfoldchange": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Minimum log fold change to consider.",
                "optional_value": false
            },
            "key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "The key of the calculated feature group rankings (default: 'rank_features_groups').",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Whether to show the plot.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Where to save the plot.",
                "optional_value": false
            },
            "return_fig": {
                "type": "Optional[bool]",
                "default": "False",
                "optional": true,
                "description": "Returns :class:`StackedViolin` object. Useful for fine-tuning the plot.\nTakes precedence over `show=False`.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Plot ranking of genes using dotplot plot (see :func:`~ehrapy.pl.dotplot`)\n\nArgs:\n    adata: Annotated data matrix.\n    groups: List of group names.\n    n_features: Number of features to show. Is ignored if `feature_names` is passed.\n    groupby: Which key to group the features by.\n    feature_symbols: Key for field in `.var` that stores feature symbols if you do not want to\n                     use `.var_names` displayed in the plot.\n    values_to_plot: Key to plot. One of 'scores', 'logfoldchanges', 'pvals', 'pvalds_adj',\n                    'log10_pvals', 'log10_pvalds_adj'.\n    var_names: Feature names.\n    min_logfoldchange: Minimum log fold change to consider.\n    key: The key of the calculated feature group rankings (default: 'rank_features_groups').\n    show: Whether to show the plot.\n    save: Where to save the plot.\n    return_fig: Returns :class:`StackedViolin` object. Useful for fine-tuning the plot.\n                Takes precedence over `show=False`.\n\nReturns:\n    If `return_fig` is `True`, returns a :class:`StackedViolin` object,\n    else if `show` is false, return axes dict\n\nExample:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.knn_impute(adata)\n    >>> ep.pp.neighbors(adata)\n    >>> ep.tl.leiden(adata, resolution=0.5, key_added=\"leiden_0_5\")\n    >>> ep.tl.rank_features_groups(adata, groupby=\"leiden_0_5\")\n    >>> ep.pl.rank_features_groups_dotplot(adata, key=\"rank_features_groups\", groupby=\"leiden_0_5\")\n\nPreview:\n    .. image:: /_static/docstring_previews/rank_features_groups_dotplot.png",
        "description": "Plot ranking of genes using dotplot plot (see :func:`~ehrapy.pl.dotplot`)",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.knn_impute(adata)\n    >>> ep.pp.neighbors(adata)\n    >>> ep.tl.leiden(adata, resolution=0.5, key_added=\"leiden_0_5\")\n    >>> ep.tl.rank_features_groups(adata, groupby=\"leiden_0_5\")\n    >>> ep.pl.rank_features_groups_dotplot(adata, key=\"rank_features_groups\", groupby=\"leiden_0_5\")\n\nPreview:\n    .. image:: /_static/docstring_previews/rank_features_groups_dotplot.png",
        "api_type": "function",
        "api_calling": [
            "ehrapy.plot.rank_features_groups_dotplot(adata=$, groups=@, n_features=@, groupby=@, values_to_plot=$, var_names=@, feature_symbols=@, min_logfoldchange=@, key=@, show=@, save=@, return_fig=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.preprocessing.highly_variable_features": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "The annotated data matrix of shape `n_obs` \u00d7 `n_vars`.",
                "optional_value": true
            },
            "layer": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "If provided, use `adata.layers[layer]` for expression values instead of `adata.X`. Defaults to None .",
                "optional_value": false
            },
            "top_features_percentage": {
                "type": "float",
                "default": "0.2",
                "optional": true,
                "description": "Percentage of highly-variable features to keep. Defaults to 0.2 .",
                "optional_value": false
            },
            "span": {
                "type": "Optional[float]",
                "default": "0.3",
                "optional": true,
                "description": "The fraction of the data used when estimating the variance in the loess model fit. Defaults to 0.3 .",
                "optional_value": false
            },
            "n_bins": {
                "type": "int",
                "default": "20",
                "optional": true,
                "description": "Number of bins for binning. Normalization is done with respect to each bin.\nIf just a single observation falls into a bin, the normalized dispersion is artificially set to 1.\nYou'll be informed about this if you set `settings.verbosity = 4`. Defaults to 20 .",
                "optional_value": false
            },
            "subset": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Inplace subset to highly-variable features if `True` otherwise merely indicate highly variable features.\nDefaults to False .",
                "optional_value": false
            },
            "inplace": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to place calculated metrics in `.var` or return them. Defaults to True .",
                "optional_value": false
            },
            "check_values": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Check if counts in selected layer are integers. A Warning is returned if set to True.\nDefaults to True .",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[pd.DataFrame]",
            "description": ""
        },
        "Docstring": "Annotate highly variable features.\n\nExpects count data. A normalized variance for each feature is computed. First, the data\nare standardized (i.e., z-score normalization per feature) with a regularized\nstandard deviation. Next, the normalized variance is computed as the variance\nof each feature after the transformation. Features are ranked by the normalized variance.\n\nArgs:\n    adata: The annotated data matrix of shape `n_obs` \u00d7 `n_vars`.\n    layer: If provided, use `adata.layers[layer]` for expression values instead of `adata.X`. Defaults to None .\n    top_features_percentage: Percentage of highly-variable features to keep. Defaults to 0.2 .\n    span: The fraction of the data used when estimating the variance in the loess model fit. Defaults to 0.3 .\n    n_bins: Number of bins for binning. Normalization is done with respect to each bin.\n            If just a single observation falls into a bin, the normalized dispersion is artificially set to 1.\n            You'll be informed about this if you set `settings.verbosity = 4`. Defaults to 20 .\n    subset: Inplace subset to highly-variable features if `True` otherwise merely indicate highly variable features.\n            Defaults to False .\n    inplace: Whether to place calculated metrics in `.var` or return them. Defaults to True .\n    check_values: Check if counts in selected layer are integers. A Warning is returned if set to True.\n                  Defaults to True .\n\nReturns:\n    Depending on `inplace` returns calculated metrics (:class:`~pandas.DataFrame`) or\n    updates `.var` with the following fields\n\nhighly_variable : bool\n    boolean indicator of highly-variable features\n**means**\n    means per feature\n**variances**\n    variance per feature\n**variances_norm**\n    normalized variance per feature, averaged in the case of multiple batches\nhighly_variable_rank : float\n    rank of the feature according to normalized variance, median rank in the case of multiple batches",
        "description": "Annotate highly variable features.Expects count data. A normalized variance for each feature is computed. First, the data\nare standardized (i.e., z-score normalization per feature) with a regularized\nstandard deviation. Next, the normalized variance is computed as the variance\nof each feature after the transformation. Features are ranked by the normalized variance.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "ehrapy.preprocessing.highly_variable_features(adata=$, layer=@, top_features_percentage=@, span=@, n_bins=@, subset=@, inplace=@, check_values=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.plot.rank_features_groups_tracksplot": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "groups": {
                "type": "Union[str, Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "List of group names.",
                "optional_value": false
            },
            "n_features": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Number of features to show. Is ignored if `feature_names` is passed.",
                "optional_value": false
            },
            "groupby": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Which key to group the features by.",
                "optional_value": false
            },
            "var_names": {
                "type": "Optional[Union[Sequence[str], Mapping[str, Sequence[str]]]]",
                "default": "None",
                "optional": true,
                "description": "Feature names.",
                "optional_value": false
            },
            "feature_symbols": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Key for field in `.var` that stores feature symbols if you do not want to\nuse `.var_names` displayed in the plot.",
                "optional_value": false
            },
            "min_logfoldchange": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Minimum log fold change to consider.",
                "optional_value": false
            },
            "key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "The key of the calculated feature group rankings (default: 'rank_features_groups').",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Whether to show the plot.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Where to save the plot.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Plot ranking of genes using tracksplot plot (see :func:`~ehrapy.pl.tracksplot`)\n\nArgs:\n    adata: Annotated data matrix.\n    groups: List of group names.\n    n_features: Number of features to show. Is ignored if `feature_names` is passed.\n    groupby: Which key to group the features by.\n    feature_symbols: Key for field in `.var` that stores feature symbols if you do not want to\n                     use `.var_names` displayed in the plot.\n    var_names: Feature names.\n    min_logfoldchange: Minimum log fold change to consider.\n    key: The key of the calculated feature group rankings (default: 'rank_features_groups').\n    show: Whether to show the plot.\n    save: Where to save the plot.\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.knn_impute(adata)\n    >>> ep.pp.log_norm(adata, offset=1)\n    >>> ep.pp.neighbors(adata)\n    >>> ep.tl.leiden(adata, resolution=0.15, key_added=\"leiden_0_5\")\n    >>> ep.tl.rank_features_groups(adata, groupby=\"leiden_0_5\")\n    >>> ep.pl.rank_features_groups_tracksplot(adata, key=\"rank_features_groups\")\n\nPreview:\n    .. image:: /_static/docstring_previews/rank_features_groups_tracksplot.png",
        "description": "Plot ranking of genes using tracksplot plot (see :func:`~ehrapy.pl.tracksplot`)",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.knn_impute(adata)\n    >>> ep.pp.log_norm(adata, offset=1)\n    >>> ep.pp.neighbors(adata)\n    >>> ep.tl.leiden(adata, resolution=0.15, key_added=\"leiden_0_5\")\n    >>> ep.tl.rank_features_groups(adata, groupby=\"leiden_0_5\")\n    >>> ep.pl.rank_features_groups_tracksplot(adata, key=\"rank_features_groups\")\n\nPreview:\n    .. image:: /_static/docstring_previews/rank_features_groups_tracksplot.png",
        "api_type": "function",
        "api_calling": [
            "ehrapy.plot.rank_features_groups_tracksplot(adata=$, groups=@, n_features=@, groupby=@, var_names=@, feature_symbols=@, min_logfoldchange=@, key=@, show=@, save=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.tools.get_medcat_annotation_overview": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "",
                "optional_value": true
            },
            "status": {
                "type": "str",
                "default": "Affirmed",
                "optional": true,
                "description": "One of \"Affirmed\" (default), \"Other\" or \"Both\". Displays stats for either only affirmed entities, negated ones or both.",
                "optional_value": false
            },
            "use_key": {
                "type": "str",
                "default": "medcat_annotations",
                "optional": true,
                "description": "Key to use for the annotated results.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "pd.DataFrame",
            "description": ""
        },
        "Docstring": "Provide an overview for the annotation results. An overview will look like the following:\n\ncui (the CUI), nsubjects (from how many rows this one got extracted), type_ids (TUIs), name(name of the entitiy), perc_subjects (how many rows relative\nto absolute number of rows)\n\nArgs:\n    medcat_obj: The current MedCAT object which holds all infos on NLP analysis with MedCAT and ehrapy.\n    n: Basically the parameter for head() of pandas Dataframe. How many of the most common entities should be shown?\n    status: One of \"Affirmed\" (default), \"Other\" or \"Both\". Displays stats for either only affirmed entities, negated ones or both.\n    use_key: Key to use for the annotated results.\n\nReturns:\n    A Pandas DataFrame with the overview stats.",
        "description": "Provide an overview for the annotation results. An overview will look like the following:cui (the CUI), nsubjects (from how many rows this one got extracted), type_ids (TUIs), name(name of the entitiy), perc_subjects (how many rows relative\nto absolute number of rows)",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "ehrapy.tools.get_medcat_annotation_overview(adata=$, status=@, use_key=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.plot.dendrogram": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object object containing all observations.",
                "optional_value": true
            },
            "groupby": {
                "type": "str",
                "default": null,
                "optional": false,
                "description": "Categorical data column used to create the dendrogram.",
                "optional_value": false
            },
            "dendrogram_key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Key under with the dendrogram information was stored.\nBy default the dendrogram information is stored under `.uns[f'dendrogram_{groupby}']`.",
                "optional_value": false
            },
            "orientation": {
                "type": "Literal['top', 'bottom', 'left', 'right']",
                "default": "top",
                "optional": true,
                "description": "Origin of the tree. Will grow into the opposite direction.",
                "optional_value": true
            },
            "remove_labels": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Don\u2019t draw labels. Used e.g. by :func:`scanpy.pl.matrixplot` to annotate matrix columns/rows.",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Whether to display the figure or return axis.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[str, bool]]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.",
                "optional_value": false
            },
            "ax": {
                "type": "Optional[Axes]",
                "default": "None",
                "optional": true,
                "description": "A matplotlib axes object. Only works if plotting a single component.",
                "optional_value": true
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Plots a dendrogram of the categories defined in `groupby`.\n\nSee :func:`~ehrapy.tl.dendrogram`.\n\nArgs:\n    adata: :class:`~anndata.AnnData` object object containing all observations.\n    groupby: Categorical data column used to create the dendrogram.\n    dendrogram_key: Key under with the dendrogram information was stored.\n                    By default the dendrogram information is stored under `.uns[f'dendrogram_{groupby}']`.\n    orientation: Origin of the tree. Will grow into the opposite direction.\n    remove_labels: Don\u2019t draw labels. Used e.g. by :func:`scanpy.pl.matrixplot` to annotate matrix columns/rows.\n    show: Whether to display the figure or return axis.\n    save: If `True` or a `str`, save the figure.\n          A string is appended to the default filename.\n          Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\n    ax: A matplotlib axes object. Only works if plotting a single component.\n\nReturns:\n    :class:`matplotlib.axes.Axes`\n\nExample:\n    .. code-block:: python\n\n        import ehrapy as ep\n\n        adata = ep.dt.mimic_2(encoded=True)\n        ep.pp.knn_impute(adata)\n        ep.pp.log_norm(adata, offset=1)\n        ep.pp.neighbors(adata)\n        ep.tl.leiden(adata, resolution=0.5, key_added=\"leiden_0_5\")\n        ep.pl.dendrogram(adata, groupby=\"leiden_0_5\")\n\nPreview:\n    .. image:: /_static/docstring_previews/dendrogram.png",
        "description": "Plots a dendrogram of the categories defined in `groupby`.See :func:`~ehrapy.tl.dendrogram`.",
        "example": ".. code-block:: python\n\n        import ehrapy as ep\n\n        adata = ep.dt.mimic_2(encoded=True)\n        ep.pp.knn_impute(adata)\n        ep.pp.log_norm(adata, offset=1)\n        ep.pp.neighbors(adata)\n        ep.tl.leiden(adata, resolution=0.5, key_added=\"leiden_0_5\")\n        ep.pl.dendrogram(adata, groupby=\"leiden_0_5\")\n\nPreview:\n    .. image:: /_static/docstring_previews/dendrogram.png",
        "api_type": "function",
        "api_calling": [
            "ehrapy.plot.dendrogram(adata=$, groupby=@, dendrogram_key=@, orientation=$, remove_labels=@, show=@, save=@, ax=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.data.parkinson_dataset_with_replicated_acoustic_features": {
        "Parameters": {
            "encoded": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to return an already encoded object.",
                "optional_value": false
            },
            "columns_obs_only": {
                "type": "Optional[Union[dict[str, list[str]], list[str]]]",
                "default": "None",
                "optional": true,
                "description": "Columns to include in obs only and not X.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": ""
        },
        "Docstring": "Loads the Parkinson Dataset with replicated acoustic features Data Set\n\nMore details: http://archive.ics.uci.edu/ml/datasets/Parkinson+Dataset+with+replicated+acoustic+features+\nPreprocessing: https://github.com/theislab/ehrapy-datasets/blob/main/parkinson_dataset_with_replicated_acoustic_features/parkinson_dataset_with_replicated_acoustic_features.ipynb\n\nArgs:\n    encoded: Whether to return an already encoded object.\n    columns_obs_only: Columns to include in obs only and not X.\n\nReturns:\n    :class:`~anndata.AnnData` object of the Parkinson Dataset with replicated acoustic features Data Set\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.parkinson_dataset_with_replicated_acoustic_features(columns_obs_only=['ID'], encoded=True)",
        "description": "Loads the Parkinson Dataset with replicated acoustic features Data SetMore details: http://archive.ics.uci.edu/ml/datasets/Parkinson+Dataset+with+replicated+acoustic+features+\nPreprocessing: https://github.com/theislab/ehrapy-datasets/blob/main/parkinson_dataset_with_replicated_acoustic_features/parkinson_dataset_with_replicated_acoustic_features.ipynb",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.parkinson_dataset_with_replicated_acoustic_features(columns_obs_only=['ID'], encoded=True)",
        "api_type": "function",
        "api_calling": [
            "ehrapy.data.parkinson_dataset_with_replicated_acoustic_features(encoded=@, columns_obs_only=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.data.chronic_kidney_disease": {
        "Parameters": {
            "encoded": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to return an already encoded object",
                "optional_value": false
            },
            "columns_obs_only": {
                "type": "Optional[Union[dict[str, list[str]], list[str]]]",
                "default": "None",
                "optional": true,
                "description": "Columns to include in obs only and not X.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": ""
        },
        "Docstring": "Loads the Chronic Kidney Disease dataset\n\nMore details: https://archive.ics.uci.edu/ml/datasets/Chronic_Kidney_Disease\nPreprocessing: https://github.com/theislab/ehrapy-datasets/tree/main/chronic_kidney_disease/chronic_kidney_disease.ipynb\n\nArgs:\n    encoded: Whether to return an already encoded object\n    columns_obs_only: Columns to include in obs only and not X.\n\nReturns:\n    :class:`~anndata.AnnData` object of the Chronic Kidney Disease dataset\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.chronic_kidney_disease(encoded=True)",
        "description": "Loads the Chronic Kidney Disease datasetMore details: https://archive.ics.uci.edu/ml/datasets/Chronic_Kidney_Disease\nPreprocessing: https://github.com/theislab/ehrapy-datasets/tree/main/chronic_kidney_disease/chronic_kidney_disease.ipynb",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.chronic_kidney_disease(encoded=True)",
        "api_type": "function",
        "api_calling": [
            "ehrapy.data.chronic_kidney_disease(encoded=@, columns_obs_only=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.plot.ols": {
        "Parameters": {
            "adata": {
                "type": "Optional[AnnData]",
                "default": "None",
                "optional": true,
                "description": ":class:`~anndata.AnnData` object object containing all observations.",
                "optional_value": true
            },
            "x": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "x coordinate, for scatter plotting.",
                "optional_value": false
            },
            "y": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "y coordinate, for scatter plotting.",
                "optional_value": false
            },
            "scatter_plot": {
                "type": "Optional[Boolean]",
                "default": "True",
                "optional": true,
                "description": "If True, show scatter plot. Defaults to True.",
                "optional_value": true
            },
            "ols_results": {
                "type": "Optional[list[RegressionResults]]",
                "default": "None",
                "optional": true,
                "description": "List of RegressionResults from ehrapy.tl.ols. Example: [result_1, result_2]",
                "optional_value": false
            },
            "ols_color": {
                "type": "Optional[list[str]]",
                "default": "None",
                "optional": true,
                "description": "List of colors for each ols_results. Example: ['red', 'blue'].",
                "optional_value": false
            },
            "xlabel": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "The x-axis label text.",
                "optional_value": false
            },
            "ylabel": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "The y-axis label text.",
                "optional_value": false
            },
            "figsize": {
                "type": "Optional[tuple[float, float]]",
                "default": "None",
                "optional": true,
                "description": "Width, height in inches. Defaults to None.",
                "optional_value": false
            },
            "lines": {
                "type": "Optional[Union[list[tuple[ndarray, float, ndarray, float]]]]",
                "default": "None",
                "optional": true,
                "description": "List of Tuples of (slope, intercept) or (x, y). Plot lines by slope and intercept or data points.\nExample: plot two lines (y = x + 2 and y = 2*x + 1): [(1, 2), (2, 1)]",
                "optional_value": false
            },
            "lines_color": {
                "type": "Optional[list[str]]",
                "default": "None",
                "optional": true,
                "description": "List of colors for each line. Example: ['red', 'blue']",
                "optional_value": false
            },
            "lines_style": {
                "type": "Optional[list[str]]",
                "default": "None",
                "optional": true,
                "description": "List of line styles for each line. Example: ['-', '--']",
                "optional_value": false
            },
            "lines_label": {
                "type": "Optional[list[str]]",
                "default": "None",
                "optional": true,
                "description": "List of line labels for each line. Example: ['Line1', 'Line2']",
                "optional_value": false
            },
            "xlim": {
                "type": "Optional[tuple[float, float]]",
                "default": "None",
                "optional": true,
                "description": "Set the x-axis view limits. Required for only plotting lines using slope and intercept.",
                "optional_value": false
            },
            "ylim": {
                "type": "Optional[tuple[float, float]]",
                "default": "None",
                "optional": true,
                "description": "Set the y-axis view limits. Required for only plotting lines using slope and intercept.",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Show the plot, do not return axis.",
                "optional_value": false
            },
            "ax": {
                "type": "Optional[Axes]",
                "default": "None",
                "optional": true,
                "description": "A matplotlib axes object. Only works if plotting a single component.",
                "optional_value": true
            },
            "title": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Set the title of the plot.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Plots a Ordinary Least Squares (OLS) Model result, scatter plot, and line plot.\n\nArgs:\n    adata: :class:`~anndata.AnnData` object object containing all observations.\n    x: x coordinate, for scatter plotting.\n    y: y coordinate, for scatter plotting.\n    scatter_plot: If True, show scatter plot. Defaults to True.\n    ols_results: List of RegressionResults from ehrapy.tl.ols. Example: [result_1, result_2]\n    ols_color: List of colors for each ols_results. Example: ['red', 'blue'].\n    xlabel: The x-axis label text.\n    ylabel: The y-axis label text.\n    figsize: Width, height in inches. Defaults to None.\n    lines: List of Tuples of (slope, intercept) or (x, y). Plot lines by slope and intercept or data points.\n           Example: plot two lines (y = x + 2 and y = 2*x + 1): [(1, 2), (2, 1)]\n    lines_color: List of colors for each line. Example: ['red', 'blue']\n    lines_style: List of line styles for each line. Example: ['-', '--']\n    lines_label: List of line labels for each line. Example: ['Line1', 'Line2']\n    xlim: Set the x-axis view limits. Required for only plotting lines using slope and intercept.\n    ylim: Set the y-axis view limits. Required for only plotting lines using slope and intercept.\n    show: Show the plot, do not return axis.\n    ax: A matplotlib axes object. Only works if plotting a single component.\n    title: Set the title of the plot.\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=False)\n    >>> co2_lm_result = ep.tl.ols(adata, var_names=['pco2_first', 'tco2_first'], formula='tco2_first ~ pco2_first', missing=\"drop\").fit()\n    >>> ep.pl.ols(adata, x='pco2_first', y='tco2_first', ols_results=[co2_lm_result], ols_color=['red'], xlabel=\"PCO2\", ylabel=\"TCO2\")\n\n    .. image:: /_static/docstring_previews/ols_plot_1.png\n\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=False)\n    >>> ep.pl.ols(adata, x='pco2_first', y='tco2_first', lines=[(0.25, 10), (0.3, 20)],\n    >>>           lines_color=['red', 'blue'], lines_style=['-', ':'], lines_label=['Line1', 'Line2'])\n\n    .. image:: /_static/docstring_previews/ols_plot_2.png\n\n    >>> import ehrapy as ep\n    >>> ep.pl.ols(lines=[(0.25, 10), (0.3, 20)], lines_color=['red', 'blue'], lines_style=['-', ':'],\n    >>>           lines_label=['Line1', 'Line2'], xlim=(0, 150), ylim=(0, 50))\n\n    .. image:: /_static/docstring_previews/ols_plot_3.png",
        "description": "Plots a Ordinary Least Squares (OLS) Model result, scatter plot, and line plot.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=False)\n    >>> co2_lm_result = ep.tl.ols(adata, var_names=['pco2_first', 'tco2_first'], formula='tco2_first ~ pco2_first', missing=\"drop\").fit()\n    >>> ep.pl.ols(adata, x='pco2_first', y='tco2_first', ols_results=[co2_lm_result], ols_color=['red'], xlabel=\"PCO2\", ylabel=\"TCO2\")\n\n    .. image:: /_static/docstring_previews/ols_plot_1.png\n\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=False)\n    >>> ep.pl.ols(adata, x='pco2_first', y='tco2_first', lines=[(0.25, 10), (0.3, 20)],\n    >>>           lines_color=['red', 'blue'], lines_style=['-', ':'], lines_label=['Line1', 'Line2'])\n\n    .. image:: /_static/docstring_previews/ols_plot_2.png\n\n    >>> import ehrapy as ep\n    >>> ep.pl.ols(lines=[(0.25, 10), (0.3, 20)], lines_color=['red', 'blue'], lines_style=['-', ':'],\n    >>>           lines_label=['Line1', 'Line2'], xlim=(0, 150), ylim=(0, 50))\n\n    .. image:: /_static/docstring_previews/ols_plot_3.png",
        "api_type": "function",
        "api_calling": [
            "ehrapy.plot.ols(adata=$, x=@, y=@, scatter_plot=$, ols_results=@, ols_color=@, xlabel=@, ylabel=@, figsize=@, lines=@, lines_color=@, lines_style=@, lines_label=@, xlim=@, ylim=@, show=@, ax=$, title=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.plot.heatmap": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "var_names": {
                "type": "Union[_VarNames, Mapping[str, _VarNames]]",
                "default": null,
                "optional": false,
                "description": "`var_names` should be a valid subset of `adata.var_names`.\nIf `var_names` is a mapping, then the key is used as label\nto group the values (see `var_group_labels`). The mapping values\nshould be sequences of valid `adata.var_names`. In this\ncase either coloring or 'brackets' are used for the grouping\nof var names depending on the plot. When `var_names` is a mapping,\nthen the `var_group_labels` and `var_group_positions` are set.",
                "optional_value": false
            },
            "groupby": {
                "type": "Union[str, Sequence[str]]",
                "default": null,
                "optional": false,
                "description": "The key of the observation grouping to consider.",
                "optional_value": false
            },
            "use_raw": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Use `raw` attribute of `adata` if present.",
                "optional_value": false
            },
            "log": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Plot on logarithmic axis.",
                "optional_value": false
            },
            "num_categories": {
                "type": "int",
                "default": "7",
                "optional": true,
                "description": "Only used if groupby observation is not categorical. This value\ndetermines the number of groups into which the groupby observation should be subdivided.",
                "optional_value": false
            },
            "dendrogram": {
                "type": "Union[bool, str]",
                "default": "False",
                "optional": true,
                "description": "If True or a valid dendrogram key, a dendrogram based on the hierarchical\nclustering between the `groupby` categories is added.\nThe dendrogram information is computed using :func:`scanpy.tl.dendrogram`.\nIf `tl.dendrogram` has not been called previously the function is called with default parameters.",
                "optional_value": false
            },
            "feature_symbols": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Column name in `.var` DataFrame that stores feature symbols.\nBy default `var_names` refer to the index column of the `.var` DataFrame.\nSetting this option allows alternative names to be used.",
                "optional_value": false
            },
            "var_group_positions": {
                "type": "Optional[Sequence[tuple[int, int]]]",
                "default": "None",
                "optional": true,
                "description": "Use this parameter to highlight groups of `var_names`.\nThis will draw a 'bracket' or a color block between the given start and end\npositions. If the parameter `var_group_labels` is set, the corresponding\nlabels are added on top/left. E.g. `var_group_positions=[(4,10)]`\nwill add a bracket between the fourth `var_name` and the tenth `var_name`.\nBy giving more positions, more brackets/color blocks are drawn.",
                "optional_value": false
            },
            "var_group_labels": {
                "type": "Optional[Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "Labels for each of the `var_group_positions` that want to be highlighted.",
                "optional_value": false
            },
            "var_group_rotation": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Label rotation degrees. By default, labels larger than 4 characters are rotated 90 degrees.",
                "optional_value": false
            },
            "layer": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Name of the AnnData object layer that wants to be plotted. By default adata.raw.X is plotted.\nIf `use_raw=False` is set, then `adata.X` is plotted. If `layer` is set to a valid layer name,\nthen the layer is plotted. `layer` takes precedence over `use_raw`.",
                "optional_value": false
            },
            "standard_scale": {
                "type": "Optional[Literal['var', 'obs']]",
                "default": "None",
                "optional": true,
                "description": "Whether or not to standardize that dimension between 0 and 1, meaning for each variable or observation,\nsubtract the minimum and divide each by its maximum.",
                "optional_value": true
            },
            "swap_axes": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "By default, the x axis contains `var_names` (e.g. features) and the y axis the `groupby`\ncategories (if any). By setting `swap_axes` then x are the `groupby` categories and y the `var_names`.",
                "optional_value": false
            },
            "show_feature_labels": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "By default feature labels are shown when there are 50 or less features. Otherwise the labels are removed.",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Whether to display the figure or return axis.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[str, bool]]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.",
                "optional_value": false
            },
            "figsize": {
                "type": "Optional[tuple[float, float]]",
                "default": "None",
                "optional": true,
                "description": "Figure size when `multi_panel=True`. Otherwise the `rcParam['figure.figsize]` value is used.\nFormat is (width, height)",
                "optional_value": false
            },
            "vmin": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "vmax": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "The value representing the upper limit of the color scale. Values larger than vmax are plotted with the same color as vmax.",
                "optional_value": false
            },
            "vcenter": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "The value representing the center of the color scale. Useful for diverging colormaps.",
                "optional_value": false
            },
            "norm": {
                "type": "Optional[Normalize]",
                "default": "None",
                "optional": true,
                "description": "Custom color normalization object from matplotlib. See `https://matplotlib.org/stable/tutorials/colors/colormapnorms.html` for details.",
                "optional_value": true
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Heatmap of the feature values.\n\nIf `groupby` is given, the heatmap is ordered by the respective group.\nIf the `groupby` observation annotation is not categorical the observation\nannotation is turned into a categorical by binning the data into the number specified in `num_categories`.\n\nArgs:\n    adata: Annotated data matrix.\n    var_names: `var_names` should be a valid subset of `adata.var_names`.\n               If `var_names` is a mapping, then the key is used as label\n               to group the values (see `var_group_labels`). The mapping values\n               should be sequences of valid `adata.var_names`. In this\n               case either coloring or 'brackets' are used for the grouping\n               of var names depending on the plot. When `var_names` is a mapping,\n               then the `var_group_labels` and `var_group_positions` are set.\n    groupby: The key of the observation grouping to consider.\n    use_raw: Use `raw` attribute of `adata` if present.\n    log: Plot on logarithmic axis.\n    num_categories: Only used if groupby observation is not categorical. This value\n                    determines the number of groups into which the groupby observation should be subdivided.\n    categories_order: Order in which to show the categories. Note: add_dendrogram or add_totals\n                      can change the categories order.\n    figsize: Figure size when `multi_panel=True`. Otherwise the `rcParam['figure.figsize]` value is used.\n             Format is (width, height)\n    dendrogram: If True or a valid dendrogram key, a dendrogram based on the hierarchical\n                clustering between the `groupby` categories is added.\n                The dendrogram information is computed using :func:`scanpy.tl.dendrogram`.\n                If `tl.dendrogram` has not been called previously the function is called with default parameters.\n    feature_symbols: Column name in `.var` DataFrame that stores feature symbols.\n                     By default `var_names` refer to the index column of the `.var` DataFrame.\n                     Setting this option allows alternative names to be used.\n    var_group_positions: Use this parameter to highlight groups of `var_names`.\n                         This will draw a 'bracket' or a color block between the given start and end\n                         positions. If the parameter `var_group_labels` is set, the corresponding\n                         labels are added on top/left. E.g. `var_group_positions=[(4,10)]`\n                         will add a bracket between the fourth `var_name` and the tenth `var_name`.\n                         By giving more positions, more brackets/color blocks are drawn.\n    var_group_labels: Labels for each of the `var_group_positions` that want to be highlighted.\n    var_group_rotation: Label rotation degrees. By default, labels larger than 4 characters are rotated 90 degrees.\n    layer: Name of the AnnData object layer that wants to be plotted. By default adata.raw.X is plotted.\n           If `use_raw=False` is set, then `adata.X` is plotted. If `layer` is set to a valid layer name,\n           then the layer is plotted. `layer` takes precedence over `use_raw`.\n    standard_scale: Whether or not to standardize that dimension between 0 and 1, meaning for each variable or observation,\n                    subtract the minimum and divide each by its maximum.\n    swap_axes: By default, the x axis contains `var_names` (e.g. features) and the y axis the `groupby`\n               categories (if any). By setting `swap_axes` then x are the `groupby` categories and y the `var_names`.\n    show_feature_labels: By default feature labels are shown when there are 50 or less features. Otherwise the labels are removed.\n    show: Whether to display the figure or return axis.\n    save: If `True` or a `str`, save the figure.\n          A string is appended to the default filename.\n          Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\n    ax: A matplotlib axes object. Only works if plotting a single component.\n            vmin: The value representing the lower limit of the color scale. Values smaller than vmin are plotted with the same color as vmin.\n    vmax: The value representing the upper limit of the color scale. Values larger than vmax are plotted with the same color as vmax.\n    vcenter: The value representing the center of the color scale. Useful for diverging colormaps.\n    norm: Custom color normalization object from matplotlib. See `https://matplotlib.org/stable/tutorials/colors/colormapnorms.html` for details.\n    **kwds:\n        Are passed to :func:`matplotlib.pyplot.imshow`.\n\nReturns:\n    List of :class:`~matplotlib.axes.Axes`\n\nExample:\n    .. code-block:: python\n\n        import ehrapy as ep\n\n        adata = ep.dt.mimic_2(encoded=True)\n        ep.pp.knn_impute(adata)\n        ep.pp.log_norm(adata, offset=1)\n        ep.pp.neighbors(adata)\n        ep.tl.leiden(adata, resolution=0.5, key_added=\"leiden_0_5\")\n        ep.pl.heatmap(\n            adata,\n            var_names=[\n                \"map_1st\",\n                \"hr_1st\",\n                \"temp_1st\",\n                \"spo2_1st\",\n                \"abg_count\",\n                \"wbc_first\",\n                \"hgb_first\",\n                \"platelet_first\",\n                \"sodium_first\",\n                \"potassium_first\",\n                \"tco2_first\",\n                \"chloride_first\",\n                \"bun_first\",\n                \"creatinine_first\",\n                \"po2_first\",\n                \"pco2_first\",\n                \"iv_day_1\",\n            ],\n            groupby=\"leiden_0_5\",\n        )\n\nPreview:\n    .. image:: /_static/docstring_previews/heatmap.png",
        "description": "Heatmap of the feature values.If `groupby` is given, the heatmap is ordered by the respective group.\nIf the `groupby` observation annotation is not categorical the observation\nannotation is turned into a categorical by binning the data into the number specified in `num_categories`.",
        "example": ".. code-block:: python\n\n        import ehrapy as ep\n\n        adata = ep.dt.mimic_2(encoded=True)\n        ep.pp.knn_impute(adata)\n        ep.pp.log_norm(adata, offset=1)\n        ep.pp.neighbors(adata)\n        ep.tl.leiden(adata, resolution=0.5, key_added=\"leiden_0_5\")\n        ep.pl.heatmap(\n            adata,\n            var_names=[\n                \"map_1st\",\n                \"hr_1st\",\n                \"temp_1st\",\n                \"spo2_1st\",\n                \"abg_count\",\n                \"wbc_first\",\n                \"hgb_first\",\n                \"platelet_first\",\n                \"sodium_first\",\n                \"potassium_first\",\n                \"tco2_first\",\n                \"chloride_first\",\n                \"bun_first\",\n                \"creatinine_first\",\n                \"po2_first\",\n                \"pco2_first\",\n                \"iv_day_1\",\n            ],\n            groupby=\"leiden_0_5\",\n        )\n\nPreview:\n    .. image:: /_static/docstring_previews/heatmap.png",
        "api_type": "function",
        "api_calling": [
            "ehrapy.plot.heatmap(adata=$, var_names=@, groupby=@, use_raw=@, log=@, num_categories=@, dendrogram=@, feature_symbols=@, var_group_positions=@, var_group_labels=@, var_group_rotation=@, layer=@, standard_scale=$, swap_axes=@, show_feature_labels=@, show=@, save=@, figsize=@, vmin=@, vmax=@, vcenter=@, norm=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.plot.pca": {
        "Parameters": {
            "adata": {
                "type": null,
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object object containing all observations.",
                "optional_value": true
            },
            "annotate_var_explained": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to only annotate the explained variables.",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Whether to display the figure or return axis.",
                "optional_value": false
            },
            "return_fig": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[bool, str]]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[Union[Axes, list[Axes]]]",
            "description": ""
        },
        "Docstring": "Scatter plot in PCA coordinates.\n\nUse the parameter `annotate_var_explained` to annotate the explained variance.\n\nArgs:\n    adata: :class:`~anndata.AnnData` object object containing all observations.\n    color: Keys for annotations of observations/patients or features, e.g., `'ann1'` or `['ann1', 'ann2']`.\n    feature_symbols: Column name in `.var` DataFrame that stores feature symbols. By default `var_names`\n                     refer to the index column of the `.var` DataFrame. Setting this option allows alternative names to be used.\n    use_raw: Use `.raw` attribute of `adata` for coloring with feature values. If `None`,\n             defaults to `True` if `layer` isn't provided and `adata.raw` is present.\n    layer: Name of the AnnData object layer that wants to be plotted. By default\n           adata.raw.X is plotted. If `use_raw=False` is set, then `adata.X` is plotted.\n           If `layer` is set to a valid layer name, then the layer is plotted. `layer` takes precedence over `use_raw`.\n    annotate_var_explained: Whether to only annotate the explained variables.\n    sort_order: For continuous annotations used as color parameter, plot data points with higher values on top of others.\n    groups: Restrict to a few categories in categorical observation annotation.\n            The default is not to restrict to any groups.\n    components: For instance, `['1,2', '2,3']`. To plot all available components use `components='all'`.\n    projection: Projection of plot (default: `'2d'`).\n    legend_loc: Location of legend, either `'on data'`, `'right margin'` or a valid keyword for the `loc` parameter of :class:`~matplotlib.legend.Legend`.\n    legend_fontsize: Numeric size in pt or string describing the size. See :meth:`~matplotlib.text.Text.set_fontsize`.\n    legend_fontweight: Legend font weight. A numeric value in range 0-1000 or a string.\n                       Defaults to `'bold'` if `legend_loc == 'on data'`, otherwise to `'normal'`.\n                       See :meth:`~matplotlib.text.Text.set_fontweight`.\n    legend_fontoutline: Line width of the legend font outline in pt. Draws a white outline using the path effect :class:`~matplotlib.patheffects.withStroke`.\n    size: Point size. If `None`, is automatically computed as 120000 / n_features.\n          Can be a sequence containing the size for each observation. The order should be the same as in adata.obs.\n    color_map: Color map to use for continous variables. Can be a name or a\n               :class:`~matplotlib.colors.Colormap` instance (e.g. `\"magma`\", `\"viridis\"`\n               or `mpl.cm.cividis`), see :func:`~matplotlib.cm.get_cmap`.\n               If `None`, the value of `mpl.rcParams[\"image.cmap\"]` is used.\n               The default `color_map` can be set using :func:`~scanpy.set_figure_params`.\n    palette: Colors to use for plotting categorical annotation groups.\n             The palette can be a valid :class:`~matplotlib.colors.ListedColormap` name\n             (`'Set2'`, `'tab20'`, \u2026), a :class:`~cycler.Cycler` object, a dict mapping\n             categories to colors, or a sequence of colors. Colors must be valid to\n             matplotlib. (see :func:`~matplotlib.colors.is_color_like`).\n             If `None`, `mpl.rcParams[\"axes.prop_cycle\"]` is used unless the categorical\n             variable already has colors stored in `adata.uns[\"{var}_colors\"]`.\n             If provided, values of `adata.uns[\"{var}_colors\"]` will be set.\n    na_color: Color to use for null or masked values. Can be anything matplotlib accepts as a color.\n              Used for all points if `color=None`.\n    na_in_legend: If there are missing values, whether they get an entry in the legend.\n                  Currently only implemented for categorical legends.\n    frameon: Draw a frame around the scatter plot. Defaults to value set in :func:`~scanpy.set_figure_params` (default: True).\n    title: Provide title for panels either as string or list of strings, e.g. `['title1', 'title2', ...]`.\n    vmin: The value representing the lower limit of the color scale. Values smaller than vmin are plotted\n          with the same color as vmin. vmin can be a number, a string, a function or `None`. If\n          vmin is a string and has the format `pN`, this is interpreted as a vmin=percentile(N).\n          For example vmin='p1.5' is interpreted as the 1.5 percentile. If vmin is function, then\n          vmin is interpreted as the return value of the function over the list of values to plot.\n          For example to set vmin tp the mean of the values to plot, `def my_vmin(values): return\n          np.mean(values)` and then set `vmin=my_vmin`. If vmin is None (default) an automatic\n          minimum value is used as defined by matplotlib `scatter` function. When making multiple\n          plots, vmin can be a list of values, one for each plot. For example `vmin=[0.1, 'p1', None, my_vmin]`\n    vmax: The value representing the upper limit of the color scale. The format is the same as for `vmin`.\n    vcenter: The value representing the center of the color scale. Useful for diverging colormaps.\n             The format is the same as for `vmin`.\n             Example: sc.pl.umap(adata, color='TREM2', vcenter='p50', cmap='RdBu_r')\n    add_outline: If set to True, this will add a thin border around groups of dots. In some situations\n                 this can enhance the aesthetics of the resulting image\n    outline_color: Tuple with two valid color names used to adjust the add_outline. The first color is the\n                   border color (default: black), while the second color is a gap color between the\n                   border color and the scatter dot (default: white).\n    outline_width: Tuple with two width numbers used to adjust the outline. The first value is the width\n                   of the border color as a fraction of the scatter dot size (default: 0.3). The second value is\n                   width of the gap color (default: 0.05).\n    ncols: Number of panels per row.\n           wspace: Adjust the width of the space between multiple panels.\n           hspace: Adjust the height of the space between multiple panels.\n           return_fig: Return the matplotlib figure.\n    kwargs: Arguments to pass to :func:`matplotlib.pyplot.scatter`,\n            for instance: the maximum and minimum values (e.g. `vmin=-2, vmax=5`).\n    show: Whether to display the figure or return axis.\n    save: If `True` or a `str`, save the figure.\n          A string is appended to the default filename.\n          Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\n    ax: A matplotlib axes object. Only works if plotting a single component.\n\nReturns:\n    If `show==False` a :class:`~matplotlib.axes.Axes` or a list of it.\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.knn_impute(adata)\n    >>> ep.pp.log_norm(adata, offset=1)\n    >>> ep.pp.neighbors(adata)\n    >>> ep.tl.pca(adata)\n    >>> ep.pl.pca(adata, color=\"service_unit\")\n\nPreview:\n    .. image:: /_static/docstring_previews/pca.png",
        "description": "Scatter plot in PCA coordinates.Use the parameter `annotate_var_explained` to annotate the explained variance.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.knn_impute(adata)\n    >>> ep.pp.log_norm(adata, offset=1)\n    >>> ep.pp.neighbors(adata)\n    >>> ep.tl.pca(adata)\n    >>> ep.pl.pca(adata, color=\"service_unit\")\n\nPreview:\n    .. image:: /_static/docstring_previews/pca.png",
        "api_type": "function",
        "api_calling": [
            "ehrapy.plot.pca(adata=$, annotate_var_explained=@, show=@, return_fig=@, save=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.plot.violin": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "",
                "optional_value": true
            },
            "keys": {
                "type": "Union[str, Sequence[str]]",
                "default": null,
                "optional": false,
                "description": "",
                "optional_value": false
            },
            "groupby": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "log": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "use_raw": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "stripplot": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "jitter": {
                "type": "Union[float, bool]",
                "default": "True",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "size": {
                "type": "int",
                "default": "1",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "layer": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "scale": {
                "type": "Literal['area', 'count', 'width']",
                "default": "width",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "order": {
                "type": "Optional[Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "multi_panel": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "xlabel": {
                "type": "str",
                "default": "",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "ylabel": {
                "type": "Optional[Union[str, Sequence[str]]]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "rotation": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[bool, str]]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "ax": {
                "type": "Optional[Axes]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Violin plot.\n\nWraps :func:`seaborn.violinplot` for :class:`~anndata.AnnData`.\n\nArgs:\n    adata: :class:`~anndata.AnnData` object object containing all observations.\n    keys: Keys for accessing variables of `.var_names` or fields of `.obs`.\n    groupby: The key of the observation grouping to consider.\n    log: Plot on logarithmic axis.\n    use_raw: Whether to use `raw` attribute of `adata`. Defaults to `True` if `.raw` is present.\n    stripplot: Add a stripplot on top of the violin plot. See :func:`~seaborn.stripplot`.\n    jitter: Add jitter to the stripplot (only when stripplot is True) See :func:`~seaborn.stripplot`.\n    size: Size of the jitter points.\n    layer: Name of the AnnData object layer that wants to be plotted. By\n           default adata.raw.X is plotted. If `use_raw=False` is set,\n           then `adata.X` is plotted. If `layer` is set to a valid layer name,\n           then the layer is plotted. `layer` takes precedence over `use_raw`.\n    scale: The method used to scale the width of each violin.\n           If 'width' (the default), each violin will have the same width.\n           If 'area', each violin will have the same area.\n           If 'count', a violin\u2019s width corresponds to the number of observations.\n    order: Order in which to show the categories.\n    multi_panel: Display keys in multiple panels also when `groupby is not None`.\n    xlabel: Label of the x axis. Defaults to `groupby` if `rotation` is `None`, otherwise, no label is shown.\n    ylabel: Label of the y axis. If `None` and `groupby` is `None`, defaults to `'value'`.\n            If `None` and `groubpy` is not `None`, defaults to `keys`.\n    rotation: Rotation of xtick labels.\n    {show_save_ax}\n    **kwds:\n        Are passed to :func:`~seaborn.violinplot`.\n\nReturns:\n    A :class:`~matplotlib.axes.Axes` object if `ax` is `None` else `None`.\n\nExample:\n    .. code-block:: python\n\n        import ehrapy as ep\n\n        adata = ep.dt.mimic_2(encoded=True)\n        ep.pp.knn_impute(adata)\n        ep.pp.log_norm(adata, offset=1)\n        ep.pp.neighbors(adata)\n        ep.tl.leiden(adata, resolution=0.5, key_added=\"leiden_0_5\")\n        ep.pl.violin(adata, keys=[\"age\"], groupby=\"leiden_0_5\")\n\nPreview:\n    .. image:: /_static/docstring_previews/violin.png",
        "description": "Violin plot.Wraps :func:`seaborn.violinplot` for :class:`~anndata.AnnData`.\n\nArgs:\n    adata: :class:`~anndata.AnnData` object object containing all observations.\n    keys: Keys for accessing variables of `.var_names` or fields of `.obs`.\n    groupby: The key of the observation grouping to consider.\n    log: Plot on logarithmic axis.\n    use_raw: Whether to use `raw` attribute of `adata`. Defaults to `True` if `.raw` is present.\n    stripplot: Add a stripplot on top of the violin plot. See :func:`~seaborn.stripplot`.\n    jitter: Add jitter to the stripplot (only when stripplot is True) See :func:`~seaborn.stripplot`.\n    size: Size of the jitter points.\n    layer: Name of the AnnData object layer that wants to be plotted. By\n           default adata.raw.X is plotted. If `use_raw=False` is set,\n           then `adata.X` is plotted. If `layer` is set to a valid layer name,\n           then the layer is plotted. `layer` takes precedence over `use_raw`.\n    scale: The method used to scale the width of each violin.\n           If 'width' (the default), each violin will have the same width.\n           If 'area', each violin will have the same area.\n           If 'count', a violin\u2019s width corresponds to the number of observations.\n    order: Order in which to show the categories.\n    multi_panel: Display keys in multiple panels also when `groupby is not None`.\n    xlabel: Label of the x axis. Defaults to `groupby` if `rotation` is `None`, otherwise, no label is shown.\n    ylabel: Label of the y axis. If `None` and `groupby` is `None`, defaults to `'value'`.\n            If `None` and `groubpy` is not `None`, defaults to `keys`.\n    rotation: Rotation of xtick labels.\n    {show_save_ax}\n    **kwds:\n        Are passed to :func:`~seaborn.violinplot`.\n\nReturns:\n    A :class:`~matplotlib.axes.Axes` object if `ax` is `None` else `None`.\n\nExample:\n    .. code-block:: python\n\n        import ehrapy as ep\n\n        adata = ep.dt.mimic_2(encoded=True)\n        ep.pp.knn_impute(adata)\n        ep.pp.log_norm(adata, offset=1)\n        ep.pp.neighbors(adata)\n        ep.tl.leiden(adata, resolution=0.5, key_added=\"leiden_0_5\")\n        ep.pl.violin(adata, keys=[\"age\"], groupby=\"leiden_0_5\")\n\nPreview:\n    .. image:: /_static/docstring_previews/violin.png",
        "example": ".. code-block:: python\n\n        import ehrapy as ep\n\n        adata = ep.dt.mimic_2(encoded=True)\n        ep.pp.knn_impute(adata)\n        ep.pp.log_norm(adata, offset=1)\n        ep.pp.neighbors(adata)\n        ep.tl.leiden(adata, resolution=0.5, key_added=\"leiden_0_5\")\n        ep.pl.violin(adata, keys=[\"age\"], groupby=\"leiden_0_5\")\n\nPreview:\n    .. image:: /_static/docstring_previews/violin.png",
        "api_type": "function",
        "api_calling": [
            "ehrapy.plot.violin(adata=$, keys=@, groupby=@, log=@, use_raw=@, stripplot=@, jitter=@, size=@, layer=@, scale=$, order=@, multi_panel=@, xlabel=@, ylabel=@, rotation=@, show=@, save=@, ax=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.preprocessing.maxabs_norm": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object containing X to normalize values in.\nMust already be encoded using :func:`~ehrapy.preprocessing.encode`.",
                "optional_value": true
            },
            "vars": {
                "type": "Optional[Union[str, Sequence[str]]]",
                "default": "None",
                "optional": true,
                "description": "List of the names of the numeric variables to normalize.\nIf None all numeric variables will be normalized. Defaults to None .",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to return a copy or act in place. Defaults to False .",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[AnnData]",
            "description": ""
        },
        "Docstring": "Apply max-abs normalization.\n\nFunctionality is provided by :func:`~sklearn.preprocessing.maxabs_scale`,\nsee https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.maxabs_scale.html for details.\n\nArgs:\n    adata: :class:`~anndata.AnnData` object containing X to normalize values in.\n           Must already be encoded using :func:`~ehrapy.preprocessing.encode`.\n    vars: List of the names of the numeric variables to normalize.\n          If None all numeric variables will be normalized. Defaults to None .\n    copy: Whether to return a copy or act in place. Defaults to False .\n\nReturns:\n    :class:`~anndata.AnnData` object with normalized X.\n    Also stores a record of applied normalizations as a dictionary in adata.uns[\"normalization\"].\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> adata_norm = ep.pp.maxabs_norm(adata, copy=True)",
        "description": "Apply max-abs normalization.Functionality is provided by :func:`~sklearn.preprocessing.maxabs_scale`,\nsee https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.maxabs_scale.html for details.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> adata_norm = ep.pp.maxabs_norm(adata, copy=True)",
        "api_type": "function",
        "api_calling": [
            "ehrapy.preprocessing.maxabs_norm(adata=$, vars=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.tools.Translator": {
        "Parameters": {
            "flavour": {
                "type": "str",
                "default": "deepl",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "source": {
                "type": "str",
                "default": "de",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "target": {
                "type": "str",
                "default": "en",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "token": {
                "type": "str",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Class providing an interface to all translation functions. Requires a flavour.",
        "description": "Class providing an interface to all translation functions. Requires a flavour.",
        "example": "",
        "api_type": "class",
        "api_calling": [
            "ehrapy.tools.Translator(flavour=@, source=@, target=@, token=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.tools.Translator.translate_X_column": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object containing the var column to translate",
                "optional_value": true
            },
            "columns": {
                "type": null,
                "default": "typing.Union[str, list]",
                "optional": true,
                "description": "The columns to translate. Can be either a single column (str) or a list of columns",
                "optional_value": true
            },
            "translate_column_name": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to translate the column name itself (only translates var_names, not var)",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Translates a X column into the target language in place.\n\nNote that the translation of a column in X is **always** in place.\n\nArgs:\n    adata: :class:`~anndata.AnnData` object containing the var column to translate\n    target_language: The target language to translate into (default: EN-US)\n    columns: The columns to translate. Can be either a single column (str) or a list of columns\n    translate_column_name: Whether to translate the column name itself (only translates var_names, not var)",
        "description": "Translates a X column into the target language in place.Note that the translation of a column in X is **always** in place.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "ehrapy.tools.Translator.translate_X_column(adata=$, columns=$, translate_column_name=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.tools.Translator.translate_obs_column": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object containing the obs column to translate",
                "optional_value": true
            },
            "columns": {
                "type": null,
                "default": "typing.Union[str, list]",
                "optional": true,
                "description": "The columns to translate. Can be either a single column (str) or a list of columns",
                "optional_value": true
            },
            "translate_column_name": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to translate the column name itself",
                "optional_value": false
            },
            "inplace": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to replace the obs values or add a new obs column",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Translates a single obs column and optionally replaces the original values\n\nArgs:\n    adata: :class:`~anndata.AnnData` object containing the obs column to translate\n    target_language: The target language to translate into (default: EN-US)\n    columns: The columns to translate. Can be either a single column (str) or a list of columns\n    translate_column_name: Whether to translate the column name itself\n    inplace: Whether to replace the obs values or add a new obs column",
        "description": "Translates a single obs column and optionally replaces the original values",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "ehrapy.tools.Translator.translate_obs_column(adata=$, columns=$, translate_column_name=@, inplace=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.tools.Translator.translate_text": {
        "Parameters": {
            "text": {
                "type": "Union[str, Iterable]",
                "default": null,
                "optional": false,
                "description": "The text to translate",
                "optional_value": false
            },
            "target_language": {
                "type": "str",
                "default": "None",
                "optional": true,
                "description": "The target language to translate the Text into, e.g. EN-GB",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Union[str, list[str]]",
            "description": ""
        },
        "Docstring": "Translates the provided text into the target language.\n\nArgs:\n    text: The text to translate\n    target_language: The target language to translate the Text into, e.g. EN-GB\n\nReturns:\n    A :class:`~deepl.TextResult` object",
        "description": "Translates the provided text into the target language.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "ehrapy.tools.Translator.translate_text(text=@, target_language=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.tools.Translator.translate_var_column": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object containing the obs column to translate",
                "optional_value": true
            },
            "columns": {
                "type": null,
                "default": "typing.Union[str, list]",
                "optional": true,
                "description": "The columns to translate. Can be either a single column (str) or a list of columns",
                "optional_value": true
            },
            "translate_column_name": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to translate the column name itself",
                "optional_value": false
            },
            "inplace": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to replace the obs values or add a new obs column",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Translates a single var column and optionally replaces the original values\n\nArgs:\n    adata: :class:`~anndata.AnnData` object containing the obs column to translate\n    target_language: The target language to translate into (default: EN-US)\n    columns: The columns to translate. Can be either a single column (str) or a list of columns\n    translate_column_name: Whether to translate the column name itself\n    inplace: Whether to replace the obs values or add a new obs column",
        "description": "Translates a single var column and optionally replaces the original values",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "ehrapy.tools.Translator.translate_var_column(adata=$, columns=$, translate_column_name=@, inplace=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.anndata.type_overview": {
        "Parameters": {
            "data": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object to display",
                "optional_value": true
            },
            "sort_by": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "How the tree output should be sorted. One of `dtype`, `order`, `num_cats` or None (Defaults to None -> unsorted)",
                "optional_value": false
            },
            "sort_reversed": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to sort in reversed order or not",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Prints the current state of an :class:`~anndata.AnnData` object in a tree format.\n\nOutput can be printed in sorted format by using one of `dtype`, `order`, `num_cats` or `None`, which sorts by data type, lexicographical order,\nnumber of unique values (excluding NaN's) and unsorted respectively. Note that sorting by `num_cats` only affects\nencoded variables currently and will display unencoded vars unsorted.\n\nArgs:\n    data: :class:`~anndata.AnnData` object to display\n    sort_by: How the tree output should be sorted. One of `dtype`, `order`, `num_cats` or None (Defaults to None -> unsorted)\n    sort_reversed: Whether to sort in reversed order or not\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.ad.type_overview(adata)",
        "description": "Prints the current state of an :class:`~anndata.AnnData` object in a tree format.Output can be printed in sorted format by using one of `dtype`, `order`, `num_cats` or `None`, which sorts by data type, lexicographical order,\nnumber of unique values (excluding NaN's) and unsorted respectively. Note that sorting by `num_cats` only affects\nencoded variables currently and will display unencoded vars unsorted.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.ad.type_overview(adata)",
        "api_type": "function",
        "api_calling": [
            "ehrapy.anndata.type_overview(data=$, sort_by=@, sort_reversed=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.plot.missing_values_heatmap": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object object containing all observations.",
                "optional_value": true
            },
            "filter": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "The filter to apply to the heatmap. Should be one of \"top\", \"bottom\", or None. Defaults to None .",
                "optional_value": false
            },
            "max_cols": {
                "type": "int",
                "default": "0",
                "optional": true,
                "description": "The max number of columns from the AnnData object to include.",
                "optional_value": false
            },
            "max_percentage": {
                "type": "float",
                "default": "0",
                "optional": true,
                "description": "The max percentage fill of the columns from the AnnData object.",
                "optional_value": false
            },
            "sort": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "The row sort order to apply. Can be \"ascending\", \"descending\", or None.",
                "optional_value": false
            },
            "figsize": {
                "type": "tuple",
                "default": "(20, 12)",
                "optional": true,
                "description": "The size of the figure to display.",
                "optional_value": false
            },
            "fontsize": {
                "type": "float",
                "default": "16",
                "optional": true,
                "description": "The figure's font size.",
                "optional_value": false
            },
            "labels": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether or not to display the column names.",
                "optional_value": false
            },
            "label_rotation": {
                "type": "float",
                "default": "45",
                "optional": true,
                "description": "What angle to rotate the text labels to.",
                "optional_value": false
            },
            "cmap": {
                "type": "str",
                "default": "RdBu",
                "optional": true,
                "description": "What `matplotlib` colormap to use.",
                "optional_value": false
            },
            "vmin": {
                "type": "int",
                "default": "-1",
                "optional": true,
                "description": "The normalized colormap threshold.",
                "optional_value": false
            },
            "vmax": {
                "type": "int",
                "default": "1",
                "optional": true,
                "description": "The normalized colormap threshold.",
                "optional_value": false
            },
            "cbar": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to draw a colorbar.",
                "optional_value": false
            },
            "categoricals": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to include \"ehrapycat\" columns to the plot.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Presents a `seaborn` heatmap visualization of nullity correlation in the given AnnData object.\n\nNote that this visualization has no special support for large datasets. For those, try the dendrogram instead.\n\nArgs:\n    adata: :class:`~anndata.AnnData` object object containing all observations.\n    filter: The filter to apply to the heatmap. Should be one of \"top\", \"bottom\", or None. Defaults to None .\n    max_cols: The max number of columns from the AnnData object to include.\n    max_percentage: The max percentage fill of the columns from the AnnData object.\n    sort: The row sort order to apply. Can be \"ascending\", \"descending\", or None.\n    figsize: The size of the figure to display.\n    fontsize: The figure's font size.\n    labels: Whether or not to display the column names.\n    label_rotation: What angle to rotate the text labels to.\n    cmap: What `matplotlib` colormap to use.\n    vmin: The normalized colormap threshold.\n    vmax: The normalized colormap threshold.\n    cbar: Whether to draw a colorbar.\n    categoricals: Whether to include \"ehrapycat\" columns to the plot.\n\nReturns:\n    The plot axis.\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.data.mimic_2(encoded=True)\n    >>> ep.pl.missing_values_heatmap(adata, filter='bottom', max_cols=15, max_percentage=0.999)\n\nPreview:\n    .. image:: /_static/docstring_previews/missingno_heatmap.png",
        "description": "Presents a `seaborn` heatmap visualization of nullity correlation in the given AnnData object.Note that this visualization has no special support for large datasets. For those, try the dendrogram instead.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.data.mimic_2(encoded=True)\n    >>> ep.pl.missing_values_heatmap(adata, filter='bottom', max_cols=15, max_percentage=0.999)\n\nPreview:\n    .. image:: /_static/docstring_previews/missingno_heatmap.png",
        "api_type": "function",
        "api_calling": [
            "ehrapy.plot.missing_values_heatmap(adata=$, filter=@, max_cols=@, max_percentage=@, sort=@, figsize=@, fontsize=@, labels=@, label_rotation=@, cmap=@, vmin=@, vmax=@, cbar=@, categoricals=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.tools.annotate_text": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "AnnData object that holds the data to annotate.",
                "optional_value": true
            },
            "cat": {
                "type": "CAT",
                "default": null,
                "optional": false,
                "description": "MedCAT object.",
                "optional_value": true
            },
            "text_column": {
                "type": "str",
                "default": null,
                "optional": false,
                "description": "Name of the column that should be annotated.",
                "optional_value": false
            },
            "key_added": {
                "type": "str",
                "default": "medcat_annotations",
                "optional": true,
                "description": "Key to add to adata.uns for the annotated results.",
                "optional_value": false
            },
            "n_proc": {
                "type": "int",
                "default": "2",
                "optional": true,
                "description": "Number of processors to use.",
                "optional_value": false
            },
            "batch_size_chars": {
                "type": "int",
                "default": "500000",
                "optional": true,
                "description": "batch size to use for CAT's multiprocessing method.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to copy adata or not.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[AnnData]",
            "description": ""
        },
        "Docstring": "Annotate the original free text data. Note this will only annotate non null rows.\n\nThe result is a DataFrame.\nThis DataFrame serves as the base for all further analyses, for example coloring UMAPs by specific diseases.\n\nArgs:\n    adata: AnnData object that holds the data to annotate.\n    cat: MedCAT object.\n    text_column: Name of the column that should be annotated.\n    key_added: Key to add to adata.uns for the annotated results.\n    n_proc: Number of processors to use.\n    batch_size_chars: batch size to use for CAT's multiprocessing method.\n    copy: Whether to copy adata or not.\n\nReturns:\n    Returns `None` if `copy=False`, else returns an `AnnData` object. Sets the following fields;\n\n    `adata.uns[key_added]` : :class:`pandas.DataFrame`\n        DataFrame with the annotated results.",
        "description": "Annotate the original free text data. Note this will only annotate non null rows.The result is a DataFrame.\nThis DataFrame serves as the base for all further analyses, for example coloring UMAPs by specific diseases.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "ehrapy.tools.annotate_text(adata=$, cat=$, text_column=@, key_added=@, n_proc=@, batch_size_chars=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.preprocessing.knn_impute": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "An annotated data matrix containing gene expression values.",
                "optional_value": true
            },
            "var_names": {
                "type": "Optional[Iterable[str]]",
                "default": "None",
                "optional": true,
                "description": "A list of variable names indicating which columns to impute.\nIf `None`, all columns are imputed. Default is `None`.",
                "optional_value": false
            },
            "n_neighbours": {
                "type": "int",
                "default": "5",
                "optional": true,
                "description": "Number of neighbors to use when performing the imputation. Defaults to 5.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to perform the imputation on a copy of the original `AnnData` object.\nIf `True`, the original object remains unmodified. Defaults to `False`.",
                "optional_value": false
            },
            "warning_threshold": {
                "type": "int",
                "default": "70",
                "optional": true,
                "description": "Percentage of missing values above which a warning is issued. Defaults to 30.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": ""
        },
        "Docstring": "Imputes missing values in the input AnnData object using K-nearest neighbor imputation.\n\nWhen using KNN Imputation with mixed data (non-numerical and numerical), encoding using ordinal encoding is required\nsince KNN Imputation can only work on numerical data. The encoding itself is just a utility and will be undone once\nimputation ran successfully.\n\nArgs:\n    adata: An annotated data matrix containing gene expression values.\n    var_names: A list of variable names indicating which columns to impute.\n               If `None`, all columns are imputed. Default is `None`.\n    n_neighbours: Number of neighbors to use when performing the imputation. Defaults to 5.\n    copy: Whether to perform the imputation on a copy of the original `AnnData` object.\n          If `True`, the original object remains unmodified. Defaults to `False`.\n    warning_threshold: Percentage of missing values above which a warning is issued. Defaults to 30.\n\nReturns:\n    An updated AnnData object with imputed values.\n\nRaises:\n    ValueError: If the input data matrix contains only categorical (non-numeric) values.\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.knn_impute(adata)",
        "description": "Imputes missing values in the input AnnData object using K-nearest neighbor imputation.When using KNN Imputation with mixed data (non-numerical and numerical), encoding using ordinal encoding is required\nsince KNN Imputation can only work on numerical data. The encoding itself is just a utility and will be undone once\nimputation ran successfully.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.knn_impute(adata)",
        "api_type": "function",
        "api_calling": [
            "ehrapy.preprocessing.knn_impute(adata=$, var_names=@, n_neighbours=@, copy=@, warning_threshold=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.data.mimic_3_demo": {
        "Parameters": {
            "encoded": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to return an already encoded object.",
                "optional_value": false
            },
            "anndata": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to return one AnnData object per CSV file. Defaults to False",
                "optional_value": false
            },
            "columns_obs_only": {
                "type": "Optional[Union[dict[str, list[str]], list[str]]]",
                "default": "None",
                "optional": true,
                "description": "Columns to include in obs only and not X.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Union[dict[str, AnnData], dict[str, pd.DataFrame]]",
            "description": ""
        },
        "Docstring": "Loads the MIMIC-III demo dataset as a dictionary of Pandas DataFrames.\n\nThe MIMIC-III dataset comes in the form of 26 CSV tables. Although, it is possible to return one AnnData object per\ncsv table, it might be easier to start with Pandas DataFrames to aggregate the desired measurements with Pandas SQL.\nhttps://github.com/yhat/pandasql/ might be useful.\nThe resulting DataFrame can then be transformed into an AnnData object with :func:`~ehrapy.anndata.df_to_anndata`.\n\nArgs:\n    encoded: Whether to return an already encoded object.\n    anndata: Whether to return one AnnData object per CSV file. Defaults to False\n    columns_obs_only: Columns to include in obs only and not X.\n\nReturns:\n    A dictionary of AnnData objects or a dictionary of Pandas DataFrames\n\nExamples:\n    >>> import ehrapy as ep\n    >>> dfs = ep.dt.mimic_3_demo()",
        "description": "Loads the MIMIC-III demo dataset as a dictionary of Pandas DataFrames.The MIMIC-III dataset comes in the form of 26 CSV tables. Although, it is possible to return one AnnData object per\ncsv table, it might be easier to start with Pandas DataFrames to aggregate the desired measurements with Pandas SQL.\nhttps://github.com/yhat/pandasql/ might be useful.\nThe resulting DataFrame can then be transformed into an AnnData object with :func:`~ehrapy.anndata.df_to_anndata`.",
        "example": ">>> import ehrapy as ep\n    >>> dfs = ep.dt.mimic_3_demo()",
        "api_type": "function",
        "api_calling": [
            "ehrapy.data.mimic_3_demo(encoded=@, anndata=@, columns_obs_only=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.plot.missing_values_dendrogram": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object object containing all observations.",
                "optional_value": true
            },
            "method": {
                "type": "str",
                "default": "average",
                "optional": true,
                "description": "The distance measure being used for clustering. This parameter is passed to `scipy.hierarchy`.",
                "optional_value": false
            },
            "filter": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "The filter to apply to the dendrogram. Should be one of \"top\", \"bottom\", or None. Defaults to None .",
                "optional_value": false
            },
            "max_cols": {
                "type": "int",
                "default": "0",
                "optional": true,
                "description": "The max number of columns from the AnnData object to include.",
                "optional_value": false
            },
            "max_percentage": {
                "type": "float",
                "default": "0",
                "optional": true,
                "description": "The max percentage fill of the columns from the AnnData object.",
                "optional_value": false
            },
            "orientation": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "The way the dendrogram is oriented.",
                "optional_value": false
            },
            "figsize": {
                "type": "Optional[tuple]",
                "default": "None",
                "optional": true,
                "description": "The size of the figure to display.",
                "optional_value": false
            },
            "fontsize": {
                "type": "float",
                "default": "16",
                "optional": true,
                "description": "The figure's font size.",
                "optional_value": false
            },
            "label_rotation": {
                "type": "float",
                "default": "45",
                "optional": true,
                "description": "What angle to rotate the text labels to. .",
                "optional_value": false
            },
            "categoricals": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to include \"ehrapycat\" columns to the plot.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Fits a `scipy` hierarchical clustering algorithm to the given AnnData object's var and visualizes the results as\na `scipy` dendrogram.\n\nThe default vertical display will fit up to 50 columns. If more than 50 columns are specified and orientation is\nleft unspecified the dendrogram will automatically swap to a horizontal display to fit the additional variables.\n\nArgs:\n    adata: :class:`~anndata.AnnData` object object containing all observations.\n    method: The distance measure being used for clustering. This parameter is passed to `scipy.hierarchy`.\n    filter: The filter to apply to the dendrogram. Should be one of \"top\", \"bottom\", or None. Defaults to None .\n    max_cols: The max number of columns from the AnnData object to include.\n    max_percentage: The max percentage fill of the columns from the AnnData object.\n    figsize: The size of the figure to display.\n    fontsize: The figure's font size.\n    orientation: The way the dendrogram is oriented.\n    label_rotation: What angle to rotate the text labels to. .\n    categoricals: Whether to include \"ehrapycat\" columns to the plot.\n\nReturns:\n    The plot axis.\n\nExample:\n    >>> import ehrapy as ep\n    >>> adata = ep.data.mimic_2(encoded=True)\n    >>> ep.pl.missing_values_dendrogram(adata, filter='bottom', max_cols=15, max_percentage=0.999)\n\nPreview:\n    .. image:: /_static/docstring_previews/missingno_dendrogram.png",
        "description": "Fits a `scipy` hierarchical clustering algorithm to the given AnnData object's var and visualizes the results asa `scipy` dendrogram.\n\nThe default vertical display will fit up to 50 columns. If more than 50 columns are specified and orientation is\nleft unspecified the dendrogram will automatically swap to a horizontal display to fit the additional variables.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.data.mimic_2(encoded=True)\n    >>> ep.pl.missing_values_dendrogram(adata, filter='bottom', max_cols=15, max_percentage=0.999)\n\nPreview:\n    .. image:: /_static/docstring_previews/missingno_dendrogram.png",
        "api_type": "function",
        "api_calling": [
            "ehrapy.plot.missing_values_dendrogram(adata=$, method=@, filter=@, max_cols=@, max_percentage=@, orientation=@, figsize=@, fontsize=@, label_rotation=@, categoricals=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.plot.rank_features_groups_heatmap": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "groups": {
                "type": "Union[str, Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "List of group names.",
                "optional_value": false
            },
            "n_features": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Number of features to show. Is ignored if `feature_names` is passed.",
                "optional_value": false
            },
            "groupby": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Which key to group the features by.",
                "optional_value": false
            },
            "feature_symbols": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Key for field in `.var` that stores feature symbols if you do not want to\nuse `.var_names` displayed in the plot.",
                "optional_value": false
            },
            "var_names": {
                "type": "Optional[Union[Sequence[str], Mapping[str, Sequence[str]]]]",
                "default": "None",
                "optional": true,
                "description": "Feature names.",
                "optional_value": false
            },
            "min_logfoldchange": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Minimum log fold change to consider.",
                "optional_value": false
            },
            "key": {
                "type": "str",
                "default": "None",
                "optional": true,
                "description": "The key of the calculated feature group rankings (default: 'rank_features_groups').",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Whether to show the plot.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Where to save the plot.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Plot ranking of genes using heatmap plot (see :func:`~ehrapy.pl.heatmap`)\n\nArgs:\n    adata: Annotated data matrix.\n    groups: List of group names.\n    n_features: Number of features to show. Is ignored if `feature_names` is passed.\n    groupby: Which key to group the features by.\n    feature_symbols: Key for field in `.var` that stores feature symbols if you do not want to\n                     use `.var_names` displayed in the plot.\n    var_names: Feature names.\n    min_logfoldchange: Minimum log fold change to consider.\n    key: The key of the calculated feature group rankings (default: 'rank_features_groups').\n    show: Whether to show the plot.\n    save: Where to save the plot.\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.knn_impute(adata)\n    >>> ep.pp.log_norm(adata, offset=1)\n    >>> ep.pp.neighbors(adata)\n    >>> ep.tl.leiden(adata, resolution=0.15, key_added=\"leiden_0_5\")\n    >>> ep.tl.rank_features_groups(adata, groupby=\"leiden_0_5\")\n    >>> ep.pl.rank_features_groups_heatmap(adata, key=\"rank_features_groups\")\n\nPreview:\n    .. image:: /_static/docstring_previews/rank_features_groups_heatmap.png",
        "description": "Plot ranking of genes using heatmap plot (see :func:`~ehrapy.pl.heatmap`)",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.knn_impute(adata)\n    >>> ep.pp.log_norm(adata, offset=1)\n    >>> ep.pp.neighbors(adata)\n    >>> ep.tl.leiden(adata, resolution=0.15, key_added=\"leiden_0_5\")\n    >>> ep.tl.rank_features_groups(adata, groupby=\"leiden_0_5\")\n    >>> ep.pl.rank_features_groups_heatmap(adata, key=\"rank_features_groups\")\n\nPreview:\n    .. image:: /_static/docstring_previews/rank_features_groups_heatmap.png",
        "api_type": "function",
        "api_calling": [
            "ehrapy.plot.rank_features_groups_heatmap(adata=$, groups=@, n_features=@, groupby=@, feature_symbols=@, var_names=@, min_logfoldchange=@, key=@, show=@, save=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.data.mimic_2_preprocessed": {
        "Parameters": {},
        "Returns": {
            "type": "AnnData",
            "description": ""
        },
        "Docstring": "Loads the preprocessed MIMIC-II dataset.\n\nMore details: https://physionet.org/content/mimic2-iaccd/1.0/\nThe dataset was preprocessed according to: https://github.com/theislab/ehrapy-datasets/tree/main/mimic_2\n\nReturns:\n    :class:`~anndata.AnnData` object of the prprocessed MIMIC-II dataset\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2_preprocessed()",
        "description": "Loads the preprocessed MIMIC-II dataset.More details: https://physionet.org/content/mimic2-iaccd/1.0/\nThe dataset was preprocessed according to: https://github.com/theislab/ehrapy-datasets/tree/main/mimic_2",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2_preprocessed()",
        "api_type": "function",
        "api_calling": [
            "ehrapy.data.mimic_2_preprocessed()"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.preprocessing.matrix_factorization_impute": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "The AnnData object to use MatrixFactorization on.",
                "optional_value": true
            },
            "var_names": {
                "type": "Optional[Iterable[str]]",
                "default": "None",
                "optional": true,
                "description": "A list of var names indicating which columns to impute (if None -> all columns).",
                "optional_value": false
            },
            "warning_threshold": {
                "type": "int",
                "default": "70",
                "optional": true,
                "description": "Threshold of percentage of missing values to display a warning for. Defaults to 30 .",
                "optional_value": false
            },
            "rank": {
                "type": "int",
                "default": "40",
                "optional": true,
                "description": "Number of latent factors to use in the matrix factorization model.\nIt determines the size of the latent feature space that will be used to estimate the missing values.\nA higher rank will allow for more complex relationships between the features, but it can also lead to overfitting.\nDefaults to 40.",
                "optional_value": false
            },
            "learning_rate": {
                "type": "float",
                "default": "0.01",
                "optional": true,
                "description": "The learning rate is the step size at which the optimization algorithm updates the model parameters during training.\nA larger learning rate can lead to faster convergence, but if it is set too high, the optimization can become unstable.\nDefaults to 0.01.",
                "optional_value": false
            },
            "max_iters": {
                "type": "int",
                "default": "50",
                "optional": true,
                "description": "Maximum number of iterations to train the matrix factorization model for.\nThe algorithm stops once this number of iterations is reached, or if convergence is achieved earlier.\nDefaults to 50.",
                "optional_value": false
            },
            "shrinkage_value": {
                "type": "float",
                "default": "0",
                "optional": true,
                "description": "The shrinkage value is a regularization parameter that controls the amount of shrinkage applied to the estimated values during optimization.\nThis term is added to the loss function and serves to penalize large values in the estimated matrix.\nA higher shrinkage value can help prevent overfitting, but can also lead to underfitting if set too high.\nDefaults to 0.",
                "optional_value": false
            },
            "min_value": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "The minimum value allowed for the imputed data. Any imputed value less than `min_value` is clipped to `min_value`.\nDefaults to None.",
                "optional_value": false
            },
            "max_value": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "The maximum value allowed for the imputed data. Any imputed value greater than `max_value` is clipped to `max_value`.\nDefaults to None.",
                "optional_value": false
            },
            "verbose": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether or not to printout training progress. Defaults to False.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to return a copy or act in place. Defaults to False.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": ""
        },
        "Docstring": "Impute data using the MatrixFactorization.\n\nSee https://github.com/iskandr/fancyimpute/blob/master/fancyimpute/matrix_factorization.py\nTrain a matrix factorization model to predict empty entries in a matrix.\n\nArgs:\n    adata: The AnnData object to use MatrixFactorization on.\n    var_names: A list of var names indicating which columns to impute (if None -> all columns).\n    warning_threshold: Threshold of percentage of missing values to display a warning for. Defaults to 30 .\n    rank: Number of latent factors to use in the matrix factorization model.\n          It determines the size of the latent feature space that will be used to estimate the missing values.\n          A higher rank will allow for more complex relationships between the features, but it can also lead to overfitting.\n          Defaults to 40.\n    learning_rate: The learning rate is the step size at which the optimization algorithm updates the model parameters during training.\n                   A larger learning rate can lead to faster convergence, but if it is set too high, the optimization can become unstable.\n                   Defaults to 0.01.\n    max_iters: Maximum number of iterations to train the matrix factorization model for.\n               The algorithm stops once this number of iterations is reached, or if convergence is achieved earlier.\n               Defaults to 50.\n    shrinkage_value: The shrinkage value is a regularization parameter that controls the amount of shrinkage applied to the estimated values during optimization.\n                     This term is added to the loss function and serves to penalize large values in the estimated matrix.\n                     A higher shrinkage value can help prevent overfitting, but can also lead to underfitting if set too high.\n                     Defaults to 0.\n    min_value: The minimum value allowed for the imputed data. Any imputed value less than `min_value` is clipped to `min_value`.\n               Defaults to None.\n    max_value: The maximum value allowed for the imputed data. Any imputed value greater than `max_value` is clipped to `max_value`.\n               Defaults to None.\n    verbose: Whether or not to printout training progress. Defaults to False.\n    copy: Whether to return a copy or act in place. Defaults to False.\n\nReturns:\n    The imputed AnnData object\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.matrix_factorization_impute(adata)",
        "description": "Impute data using the MatrixFactorization.See https://github.com/iskandr/fancyimpute/blob/master/fancyimpute/matrix_factorization.py\nTrain a matrix factorization model to predict empty entries in a matrix.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.matrix_factorization_impute(adata)",
        "api_type": "function",
        "api_calling": [
            "ehrapy.preprocessing.matrix_factorization_impute(adata=$, var_names=@, warning_threshold=@, rank=@, learning_rate=@, max_iters=@, shrinkage_value=@, min_value=@, max_value=@, verbose=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.anndata.get_rank_features_df": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "AnnData object to get values from.",
                "optional_value": true
            },
            "group": {
                "type": "Union[str, Iterable[str]]",
                "default": null,
                "optional": false,
                "description": "Which group (as in :func:`ehrapy.tl.rank_genes_groups`'s `groupby` argument)\nto return results from. Can be a list. All groups are returned if groups is `None`.",
                "optional_value": false
            },
            "key": {
                "type": "str",
                "default": "rank_features_groups",
                "optional": true,
                "description": "Key differential groups were stored under.",
                "optional_value": false
            },
            "pval_cutoff": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Return only adjusted p-values below the  cutoff.",
                "optional_value": false
            },
            "log2fc_min": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Minimum logfc to return.",
                "optional_value": false
            },
            "log2fc_max": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Maximum logfc to return.",
                "optional_value": false
            },
            "features": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Column name in `.var` DataFrame that stores gene symbols.\nSpecifying this will add that column to the returned DataFrame.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": ":func:`ehrapy.tl.rank_features_groups` results in the form of a :class:`~pandas.DataFrame`.\n\nArgs:\n    adata: AnnData object to get values from.\n    group: Which group (as in :func:`ehrapy.tl.rank_genes_groups`'s `groupby` argument)\n           to return results from. Can be a list. All groups are returned if groups is `None`.\n    key: Key differential groups were stored under.\n    pval_cutoff: Return only adjusted p-values below the  cutoff.\n    log2fc_min: Minimum logfc to return.\n    log2fc_max: Maximum logfc to return.\n    features: Column name in `.var` DataFrame that stores gene symbols.\n              Specifying this will add that column to the returned DataFrame.\n\nReturns:\n    A Pandas DataFrame of all rank genes groups results.\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.tl.rank_features_groups(adata, \"service_unit\")\n    >>> df = ep.ad.get_rank_features_df(adata, group=\"FICU\")",
        "description": ":func:`ehrapy.tl.rank_features_groups` results in the form of a :class:`~pandas.DataFrame`.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.tl.rank_features_groups(adata, \"service_unit\")\n    >>> df = ep.ad.get_rank_features_df(adata, group=\"FICU\")",
        "api_type": "function",
        "api_calling": [
            "ehrapy.anndata.get_rank_features_df(adata=$, group=@, key=@, pval_cutoff=@, log2fc_min=@, log2fc_max=@, features=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.plot.paga": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object object containing all observations.",
                "optional_value": true
            },
            "threshold": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Do not draw edges for weights below this threshold. Set to 0 if you want\nall edges. Discarding low-connectivity edges helps in getting a much clearer picture of the graph.",
                "optional_value": false
            },
            "color": {
                "type": "Optional[Union[str, Mapping[str, int, Mapping[Any, float]]]]",
                "default": "None",
                "optional": true,
                "description": "Feature name or `obs` annotation defining the node colors.\nAlso plots the degree of the abstracted graph when\npassing {`'degree_dashed'`, `'degree_solid'`}.\nCan be also used to visualize pie chart at each node in the following form:\n`{<group name or index>: {<color>: <fraction>, ...}, ...}`. If the fractions\ndo not sum to 1, a new category called `'rest'` colored grey will be created.",
                "optional_value": false
            },
            "layout": {
                "type": "Optional[_IGraphLayout]",
                "default": "None",
                "optional": true,
                "description": "The node labels. If `None`, this defaults to the group labels stored in\nthe categorical for which :func:`~scanpy.tl.paga` has been computed.",
                "optional_value": true
            },
            "init_pos": {
                "type": "Optional[np.ndarray]",
                "default": "None",
                "optional": true,
                "description": "Two-column array storing the x and y coordinates for initializing the layout.",
                "optional_value": true
            },
            "root": {
                "type": "Optional[Union[int, str, Sequence[int]]]",
                "default": "0",
                "optional": true,
                "description": "If choosing a tree layout, this is the index of the root node or a list\nof root node indices. If this is a non-empty vector then the supplied\nnode IDs are used as the roots of the trees (or a single tree if the\ngraph is connected). If this is `None` or an empty list, the root\nvertices are automatically calculated based on topological sorting.",
                "optional_value": false
            },
            "labels": {
                "type": "Optional[Union[str, Sequence[str], Mapping[str, str]]]",
                "default": "None",
                "optional": true,
                "description": "The node labels. If `None`, this defaults to the group labels stored in\nthe categorical for which :func:`~scanpy.tl.paga` has been computed.",
                "optional_value": false
            },
            "single_component": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Restrict to largest connected component.",
                "optional_value": false
            },
            "solid_edges": {
                "type": "str",
                "default": "connectivities",
                "optional": true,
                "description": "Key for `.uns['paga']` that specifies the matrix that stores the edges to be drawn solid black.",
                "optional_value": false
            },
            "dashed_edges": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Key for `.uns['paga']` that specifies the matrix that stores the edges\nto be drawn dashed grey. If `None`, no dashed edges are drawn.",
                "optional_value": false
            },
            "transitions": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Key for `.uns['paga']` that specifies the matrix that stores the\narrows, for instance `'transitions_confidence'`.",
                "optional_value": false
            },
            "fontsize": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Font size for node labels.",
                "optional_value": false
            },
            "fontweight": {
                "type": "str",
                "default": "bold",
                "optional": true,
                "description": "Weight of the font.",
                "optional_value": false
            },
            "fontoutline": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Width of the white outline around fonts.",
                "optional_value": false
            },
            "node_size_scale": {
                "type": "float",
                "default": "1.0",
                "optional": true,
                "description": "Increase or decrease the size of the nodes.",
                "optional_value": false
            },
            "node_size_power": {
                "type": "float",
                "default": "0.5",
                "optional": true,
                "description": "The power with which groups sizes influence the radius of the nodes.",
                "optional_value": false
            },
            "edge_width_scale": {
                "type": "float",
                "default": "1.0",
                "optional": true,
                "description": "Edge with scale in units of `rcParams['lines.linewidth']`.",
                "optional_value": false
            },
            "min_edge_width": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Min width of solid edges.",
                "optional_value": false
            },
            "max_edge_width": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Max width of solid and dashed edges.",
                "optional_value": false
            },
            "arrowsize": {
                "type": "int",
                "default": "30",
                "optional": true,
                "description": "For directed graphs, choose the size of the arrow head head's length and width.\nSee :py:class: `matplotlib.patches.FancyArrowPatch` for attribute `mutation_scale` for more info.",
                "optional_value": false
            },
            "title": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Provide a title.",
                "optional_value": false
            },
            "left_margin": {
                "type": "float",
                "default": "0.01",
                "optional": true,
                "description": "Margin to the left of the plot.",
                "optional_value": false
            },
            "random_state": {
                "type": "Optional[int]",
                "default": "0",
                "optional": true,
                "description": "For layouts with random initialization like `'fr'`, change this to use\ndifferent intial states for the optimization. If `None`, the initial state is not reproducible.",
                "optional_value": false
            },
            "pos": {
                "type": "Optional[Union[np.ndarray, str, Path]]",
                "default": "None",
                "optional": true,
                "description": "Two-column array-like storing the x and y coordinates for drawing.\nOtherwise, path to a `.gdf` file that has been exported from Gephi or\na similar graph visualization software.",
                "optional_value": false
            },
            "normalize_to_color": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to normalize categorical plots to `color` or the underlying grouping.",
                "optional_value": false
            },
            "cmap": {
                "type": "Union[str, Colormap]",
                "default": "None",
                "optional": true,
                "description": "The Matplotlib color map.",
                "optional_value": false
            },
            "cax": {
                "type": "Optional[Axes]",
                "default": "None",
                "optional": true,
                "description": "A matplotlib axes object for a potential colorbar.",
                "optional_value": true
            },
            "frameon": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Draw a frame around the PAGA graph.",
                "optional_value": false
            },
            "add_pos": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Add the positions to `adata.uns['paga']`.",
                "optional_value": false
            },
            "export_to_gexf": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Export to gexf format to be read by graph visualization programs such as Gephi.",
                "optional_value": false
            },
            "use_raw": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to use `raw` attribute of `adata`. Defaults to `True` if `.raw` is present.",
                "optional_value": false
            },
            "plot": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "If `False`, do not create the figure, simply compute the layout.",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Whether to show the plot.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[bool, str]]",
                "default": "None",
                "optional": true,
                "description": "Whether or where to save the plot.",
                "optional_value": false
            },
            "ax": {
                "type": "Optional[Axes]",
                "default": "None",
                "optional": true,
                "description": "Matplotlib Axis object.",
                "optional_value": true
            }
        },
        "Returns": {
            "type": "Optional[Union[Axes, list[Axes]]]",
            "description": ""
        },
        "Docstring": "Plot the PAGA graph through thresholding low-connectivity edges.\n\nCompute a coarse-grained layout of the data. Reuse this by passing\n`init_pos='paga'` to :func:`~scanpy.tl.umap` or\n:func:`~scanpy.tl.draw_graph` and obtain embeddings with more meaningful\nglobal topology [Wolf19]_.\nThis uses ForceAtlas2 or igraph's layout algorithms for most layouts [Csardi06]_.\n\nArgs:\n    adata: :class:`~anndata.AnnData` object object containing all observations.\n    threshold: Do not draw edges for weights below this threshold. Set to 0 if you want\n               all edges. Discarding low-connectivity edges helps in getting a much clearer picture of the graph.\n    color: Feature name or `obs` annotation defining the node colors.\n           Also plots the degree of the abstracted graph when\n           passing {`'degree_dashed'`, `'degree_solid'`}.\n           Can be also used to visualize pie chart at each node in the following form:\n           `{<group name or index>: {<color>: <fraction>, ...}, ...}`. If the fractions\n           do not sum to 1, a new category called `'rest'` colored grey will be created.\n    layout: The node labels. If `None`, this defaults to the group labels stored in\n            the categorical for which :func:`~scanpy.tl.paga` has been computed.\n    layout_kwds: Keywords for the layout.\n    init_pos: Two-column array storing the x and y coordinates for initializing the layout.\n    root: If choosing a tree layout, this is the index of the root node or a list\n          of root node indices. If this is a non-empty vector then the supplied\n          node IDs are used as the roots of the trees (or a single tree if the\n          graph is connected). If this is `None` or an empty list, the root\n          vertices are automatically calculated based on topological sorting.\n    labels: The node labels. If `None`, this defaults to the group labels stored in\n            the categorical for which :func:`~scanpy.tl.paga` has been computed.\n    single_component: Restrict to largest connected component.\n    solid_edges: Key for `.uns['paga']` that specifies the matrix that stores the edges to be drawn solid black.\n    dashed_edges: Key for `.uns['paga']` that specifies the matrix that stores the edges\n                  to be drawn dashed grey. If `None`, no dashed edges are drawn.\n    transitions: Key for `.uns['paga']` that specifies the matrix that stores the\n                 arrows, for instance `'transitions_confidence'`.\n    fontsize: Font size for node labels.\n    fontweight: Weight of the font.\n    fontoutline: Width of the white outline around fonts.\n    text_kwds: Keywords for :meth:`~matplotlib.axes.Axes.text`.\n    node_size_scale: Increase or decrease the size of the nodes.\n    node_size_power: The power with which groups sizes influence the radius of the nodes.\n    edge_width_scale: Edge with scale in units of `rcParams['lines.linewidth']`.\n    min_edge_width: Min width of solid edges.\n    max_edge_width: Max width of solid and dashed edges.\n    arrowsize: For directed graphs, choose the size of the arrow head head's length and width.\n               See :py:class: `matplotlib.patches.FancyArrowPatch` for attribute `mutation_scale` for more info.\n    title: Provide a title.\n    left_margin: Margin to the left of the plot.\n    random_state: For layouts with random initialization like `'fr'`, change this to use\n                  different intial states for the optimization. If `None`, the initial state is not reproducible.\n    pos: Two-column array-like storing the x and y coordinates for drawing.\n         Otherwise, path to a `.gdf` file that has been exported from Gephi or\n         a similar graph visualization software.\n    normalize_to_color: Whether to normalize categorical plots to `color` or the underlying grouping.\n    cmap: The Matplotlib color map.\n    cax: A matplotlib axes object for a potential colorbar.\n    cb_kwds: Keyword arguments for :class:`~matplotlib.colorbar.ColorbarBase`, for instance, `ticks`.\n    frameon: Draw a frame around the PAGA graph.\n    add_pos: Add the positions to `adata.uns['paga']`.\n    export_to_gexf: Export to gexf format to be read by graph visualization programs such as Gephi.\n    use_raw: Whether to use `raw` attribute of `adata`. Defaults to `True` if `.raw` is present.\n    plot: If `False`, do not create the figure, simply compute the layout.\n    ax: Matplotlib Axis object.\n    show: Whether to show the plot.\n    save: Whether or where to save the plot.\n\nReturns:\n    A :class:`~matplotlib.axes.Axes` object, if `ax` is `None`, else `None`.\n    If `return_data`, return the timeseries data in addition to an axes.\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.knn_impute(adata)\n    >>> ep.pp.log_norm(adata, offset=1)\n    >>> ep.pp.neighbors(adata)\n    >>> ep.tl.leiden(adata, resolution=0.5, key_added=\"leiden_0_5\")\n    >>> ep.tl.paga(adata, groups=\"leiden_0_5\")\n    >>> ep.pl.paga(\n    ...     adata,\n    ...     color=[\"leiden_0_5\", \"day_28_flg\"],\n    ...     cmap=ep.pl.Colormaps.grey_red.value,\n    ...     title=[\"Leiden 0.5\", \"Died in less than 28 days\"],\n    ... )\n\nPreview:\n    .. image:: /_static/docstring_previews/paga.png",
        "description": "Plot the PAGA graph through thresholding low-connectivity edges.Compute a coarse-grained layout of the data. Reuse this by passing\n`init_pos='paga'` to :func:`~scanpy.tl.umap` or\n:func:`~scanpy.tl.draw_graph` and obtain embeddings with more meaningful\nglobal topology [Wolf19]_.\nThis uses ForceAtlas2 or igraph's layout algorithms for most layouts [Csardi06]_.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.knn_impute(adata)\n    >>> ep.pp.log_norm(adata, offset=1)\n    >>> ep.pp.neighbors(adata)\n    >>> ep.tl.leiden(adata, resolution=0.5, key_added=\"leiden_0_5\")\n    >>> ep.tl.paga(adata, groups=\"leiden_0_5\")\n    >>> ep.pl.paga(\n    ...     adata,\n    ...     color=[\"leiden_0_5\", \"day_28_flg\"],\n    ...     cmap=ep.pl.Colormaps.grey_red.value,\n    ...     title=[\"Leiden 0.5\", \"Died in less than 28 days\"],\n    ... )\n\nPreview:\n    .. image:: /_static/docstring_previews/paga.png",
        "api_type": "function",
        "api_calling": [
            "ehrapy.plot.paga(adata=$, threshold=@, color=@, layout=$, init_pos=$, root=@, labels=@, single_component=@, solid_edges=@, dashed_edges=@, transitions=@, fontsize=@, fontweight=@, fontoutline=@, node_size_scale=@, node_size_power=@, edge_width_scale=@, min_edge_width=@, max_edge_width=@, arrowsize=@, title=@, left_margin=@, random_state=@, pos=@, normalize_to_color=@, cmap=@, cax=$, frameon=@, add_pos=@, export_to_gexf=@, use_raw=@, plot=@, show=@, save=@, ax=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.data.hepatitis": {
        "Parameters": {
            "encoded": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to return an already encoded object",
                "optional_value": false
            },
            "columns_obs_only": {
                "type": "Optional[Union[dict[str, list[str]], list[str]]]",
                "default": "None",
                "optional": true,
                "description": "Columns to include in obs only and not X.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": ""
        },
        "Docstring": "Loads the Hepatitis Data Set\n\nMore details: http://archive.ics.uci.edu/ml/datasets/Hepatitis\nPreprocessing: https://github.com/theislab/ehrapy-datasets/blob/main/hepatitis/hepatitis.ipynb\n\nArgs:\n    encoded: Whether to return an already encoded object\n    columns_obs_only: Columns to include in obs only and not X.\n\nReturns:\n    :class:`~anndata.AnnData` object of the Hepatitis Data Set\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.hepatitis(encoded=True)",
        "description": "Loads the Hepatitis Data SetMore details: http://archive.ics.uci.edu/ml/datasets/Hepatitis\nPreprocessing: https://github.com/theislab/ehrapy-datasets/blob/main/hepatitis/hepatitis.ipynb",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.hepatitis(encoded=True)",
        "api_type": "function",
        "api_calling": [
            "ehrapy.data.hepatitis(encoded=@, columns_obs_only=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.anndata.anndata_to_df": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "The AnnData object to be transformed into a pandas Dataframe",
                "optional_value": true
            },
            "layer": {
                "type": "str",
                "default": "None",
                "optional": true,
                "description": "The layer to use for X.",
                "optional_value": false
            },
            "obs_cols": {
                "type": "Optional[Union[list[str], str]]",
                "default": "None",
                "optional": true,
                "description": "List of obs columns to add to X.",
                "optional_value": false
            },
            "var_cols": {
                "type": "Optional[Union[list[str], str]]",
                "default": "None",
                "optional": true,
                "description": "List of var columns to add to X.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "pd.DataFrame",
            "description": ""
        },
        "Docstring": "Transform an AnnData object to a pandas DataFrame.\n\nArgs:\n    adata: The AnnData object to be transformed into a pandas Dataframe\n    layer: The layer to use for X.\n    obs_cols: List of obs columns to add to X.\n    var_cols: List of var columns to add to X.\n\nReturns:\n    The AnnData object as a pandas Dataframe\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> df = ep.ad.anndata_to_df(adata)",
        "description": "Transform an AnnData object to a pandas DataFrame.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> df = ep.ad.anndata_to_df(adata)",
        "api_type": "function",
        "api_calling": [
            "ehrapy.anndata.anndata_to_df(adata=$, layer=@, obs_cols=@, var_cols=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.tools.glm": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "The AnnData object for the GLM model.",
                "optional_value": true
            },
            "var_names": {
                "type": "Optional[Iterable[str]]",
                "default": "None",
                "optional": true,
                "description": "A list of var names indicating which columns are for the GLM model.",
                "optional_value": false
            },
            "formula": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "The formula specifying the model.",
                "optional_value": false
            },
            "family": {
                "type": "Literal['Gaussian', 'Binomial', 'Gamma', 'Gaussian', 'InverseGaussian']",
                "default": "Gaussian",
                "optional": true,
                "description": "The distribution families. Available options are 'Gaussian', 'Binomial', 'Gamma', and 'InverseGaussian'.\nDefaults to 'Gaussian'.",
                "optional_value": true
            },
            "missing": {
                "type": "Literal['none', 'drop', 'raise']",
                "default": "none",
                "optional": true,
                "description": "Available options are 'none', 'drop', and 'raise'. If 'none', no nan checking is done.\nIf 'drop', any observations with nans are dropped. If 'raise', an error is raised (default: 'none').",
                "optional_value": true
            },
            "as_continuous": {
                "type": "Optional[Iterable[str]]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "sm.GLM",
            "description": ""
        },
        "Docstring": "Create a Generalized Linear Model (GLM) from a formula, a distribution, and AnnData.\n\nSee https://www.statsmodels.org/stable/generated/statsmodels.formula.api.glm.html#statsmodels.formula.api.glm\nInternally use the statsmodel to create a GLM Model from a formula, a distribution, and dataframe.\n\nArgs:\n    adata: The AnnData object for the GLM model.\n    var_names: A list of var names indicating which columns are for the GLM model.\n    formula: The formula specifying the model.\n    family: The distribution families. Available options are 'Gaussian', 'Binomial', 'Gamma', and 'InverseGaussian'.\n            Defaults to 'Gaussian'.\n    missing: Available options are 'none', 'drop', and 'raise'. If 'none', no nan checking is done.\n             If 'drop', any observations with nans are dropped. If 'raise', an error is raised (default: 'none').\n    ascontinus: A list of var names indicating which columns are continuous rather than categorical.\n                The corresponding columns will be set as type float.\n\nReturns:\n    The GLM model instance.\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=False)\n    >>> formula = 'day_28_flg ~ age'\n    >>> var_names = ['day_28_flg', 'age']\n    >>> family = 'Binomial'\n    >>> glm = ep.tl.glmglm(adata, var_names, formula, family, missing = 'drop', ascontinus = ['age'])",
        "description": "Create a Generalized Linear Model (GLM) from a formula, a distribution, and AnnData.See https://www.statsmodels.org/stable/generated/statsmodels.formula.api.glm.html#statsmodels.formula.api.glm\nInternally use the statsmodel to create a GLM Model from a formula, a distribution, and dataframe.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=False)\n    >>> formula = 'day_28_flg ~ age'\n    >>> var_names = ['day_28_flg', 'age']\n    >>> family = 'Binomial'\n    >>> glm = ep.tl.glmglm(adata, var_names, formula, family, missing = 'drop', ascontinus = ['age'])",
        "api_type": "function",
        "api_calling": [
            "ehrapy.tools.glm(adata=$, var_names=@, formula=@, family=$, missing=$, as_continuous=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.plot.draw_graph": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object object containing all observations.",
                "optional_value": true
            },
            "layout": {
                "type": "Optional[_IGraphLayout]",
                "default": "None",
                "optional": true,
                "description": "One of the :func:`~scanpy.tl.draw_graph` layouts. By default, the last computed layout is used.",
                "optional_value": true
            }
        },
        "Returns": {
            "type": "Optional[Union[Axes, list[Axes]]]",
            "description": ""
        },
        "Docstring": "Scatter plot in graph-drawing basis.\n\nArgs:\n    adata: :class:`~anndata.AnnData` object object containing all observations.\n    color: Keys for annotations of observations/patients or features, e.g., `'ann1'` or `['ann1', 'ann2']`.\n    feature_symbols: Column name in `.var` DataFrame that stores feature symbols. By default `var_names`\n                     refer to the index column of the `.var` DataFrame. Setting this option allows alternative names to be used.\n    use_raw: Use `.raw` attribute of `adata` for coloring with feature values. If `None`,\n             defaults to `True` if `layer` isn't provided and `adata.raw` is present.\n    layer: Name of the AnnData object layer that wants to be plotted. By default\n           adata.raw.X is plotted. If `use_raw=False` is set, then `adata.X` is plotted.\n           If `layer` is set to a valid layer name, then the layer is plotted. `layer` takes precedence over `use_raw`.\n    layout: One of the :func:`~scanpy.tl.draw_graph` layouts. By default, the last computed layout is used.\n    edges: Show edges.\n    edges_width: Width of edges.\n    edges_color: Color of edges. See :func:`~networkx.drawing.nx_pylab.draw_networkx_edges`.\n    neighbors_key: Where to look for neighbors connectivities.\n                   If not specified, this looks .obsp['connectivities'] for connectivities\n                   (default storage place for pp.neighbors). If specified, this looks at\n                   `.obsp[.uns[neighbors_key]['connectivities_key']]` for connectivities.\n    arrows: Show arrows (deprecated in favour of `scvelo.pl.velocity_embedding`).\n    arrows_kwds: Passed to :meth:`~matplotlib.axes.Axes.quiver`\n    sort_order: For continuous annotations used as color parameter, plot data points with higher values on top of others.\n    groups: Restrict to a few categories in categorical observation annotation.\n            The default is not to restrict to any groups.\n    components: For instance, `['1,2', '2,3']`. To plot all available components use `components='all'`.\n    projection: Projection of plot (default: `'2d'`).\n    legend_loc: Location of legend, either `'on data'`, `'right margin'` or a valid keyword for the `loc` parameter of :class:`~matplotlib.legend.Legend`.\n    legend_fontsize: Numeric size in pt or string describing the size. See :meth:`~matplotlib.text.Text.set_fontsize`.\n    legend_fontweight: Legend font weight. A numeric value in range 0-1000 or a string.\n                       Defaults to `'bold'` if `legend_loc == 'on data'`, otherwise to `'normal'`.\n                       See :meth:`~matplotlib.text.Text.set_fontweight`.\n    legend_fontoutline: Line width of the legend font outline in pt. Draws a white outline using the path effect :class:`~matplotlib.patheffects.withStroke`.\n    size: Point size. If `None`, is automatically computed as 120000 / n_features.\n          Can be a sequence containing the size for each observation. The order should be the same as in adata.obs.\n    color_map: Color map to use for continous variables. Can be a name or a\n               :class:`~matplotlib.colors.Colormap` instance (e.g. `\"magma`\", `\"viridis\"`\n               or `mpl.cm.cividis`), see :func:`~matplotlib.cm.get_cmap`.\n               If `None`, the value of `mpl.rcParams[\"image.cmap\"]` is used.\n               The default `color_map` can be set using :func:`~scanpy.set_figure_params`.\n    palette: Colors to use for plotting categorical annotation groups.\n             The palette can be a valid :class:`~matplotlib.colors.ListedColormap` name\n             (`'Set2'`, `'tab20'`, \u2026), a :class:`~cycler.Cycler` object, a dict mapping\n             categories to colors, or a sequence of colors. Colors must be valid to\n             matplotlib. (see :func:`~matplotlib.colors.is_color_like`).\n             If `None`, `mpl.rcParams[\"axes.prop_cycle\"]` is used unless the categorical\n             variable already has colors stored in `adata.uns[\"{var}_colors\"]`.\n             If provided, values of `adata.uns[\"{var}_colors\"]` will be set.\n    na_color: Color to use for null or masked values. Can be anything matplotlib accepts as a color.\n              Used for all points if `color=None`.\n    na_in_legend: If there are missing values, whether they get an entry in the legend.\n                  Currently only implemented for categorical legends.\n    frameon: Draw a frame around the scatter plot. Defaults to value set in :func:`~scanpy.set_figure_params` (default: True).\n    title: Provide title for panels either as string or list of strings, e.g. `['title1', 'title2', ...]`.\n    vmin: The value representing the lower limit of the color scale. Values smaller than vmin are plotted\n          with the same color as vmin. vmin can be a number, a string, a function or `None`. If\n          vmin is a string and has the format `pN`, this is interpreted as a vmin=percentile(N).\n          For example vmin='p1.5' is interpreted as the 1.5 percentile. If vmin is function, then\n          vmin is interpreted as the return value of the function over the list of values to plot.\n          For example to set vmin tp the mean of the values to plot, `def my_vmin(values): return\n          np.mean(values)` and then set `vmin=my_vmin`. If vmin is None (default) an automatic\n          minimum value is used as defined by matplotlib `scatter` function. When making multiple\n          plots, vmin can be a list of values, one for each plot. For example `vmin=[0.1, 'p1', None, my_vmin]`\n    vmax: The value representing the upper limit of the color scale. The format is the same as for `vmin`.\n    vcenter: The value representing the center of the color scale. Useful for diverging colormaps.\n             The format is the same as for `vmin`.\n             Example: sc.pl.umap(adata, color='TREM2', vcenter='p50', cmap='RdBu_r')\n    add_outline: If set to True, this will add a thin border around groups of dots. In some situations\n                 this can enhance the aesthetics of the resulting image\n    outline_color: Tuple with two valid color names used to adjust the add_outline. The first color is the\n                   border color (default: black), while the second color is a gap color between the\n                   border color and the scatter dot (default: white).\n    outline_width: Tuple with two width numbers used to adjust the outline. The first value is the width\n                   of the border color as a fraction of the scatter dot size (default: 0.3). The second value is\n                   width of the gap color (default: 0.05).\n    ncols: Number of panels per row.\n           wspace: Adjust the width of the space between multiple panels.\n           hspace: Adjust the height of the space between multiple panels.\n           return_fig: Return the matplotlib figure.\n    kwargs: Arguments to pass to :func:`matplotlib.pyplot.scatter`,\n            for instance: the maximum and minimum values (e.g. `vmin=-2, vmax=5`).\n    show: Whether to display the figure or return axis.\n    save: If `True` or a `str`, save the figure.\n          A string is appended to the default filename.\n          Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\n    ax: A matplotlib axes object. Only works if plotting a single component.\n\nReturns:\n    If `show==False` a :class:`~matplotlib.axes.Axes` or a list of it.\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.knn_impute(adata)\n    >>> ep.pp.log_norm(adata, offset=1)\n    >>> ep.pp.neighbors(adata)\n    >>> ep.tl.leiden(adata, resolution=0.5, key_added=\"leiden_0_5\")\n    >>> ep.tl.paga(adata, groups=\"leiden_0_5\")\n    >>> ep.pl.paga(\n    ...     adata,\n    ...     color=[\"leiden_0_5\", \"day_28_flg\"],\n    ...     cmap=ep.pl.Colormaps.grey_red.value,\n    ...     title=[\"Leiden 0.5\", \"Died in less than 28 days\"],\n    ... )\n    >>> ep.tl.draw_graph(adata, init_pos=\"paga\")\n    >>> ep.pl.draw_graph(adata, color=[\"leiden_0_5\", \"icu_exp_flg\"], legend_loc=\"on data\")\n\nPreview:\n    .. image:: /_static/docstring_previews/draw_graph_1.png\n\n    .. image:: /_static/docstring_previews/draw_graph_2.png",
        "description": "Scatter plot in graph-drawing basis.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.knn_impute(adata)\n    >>> ep.pp.log_norm(adata, offset=1)\n    >>> ep.pp.neighbors(adata)\n    >>> ep.tl.leiden(adata, resolution=0.5, key_added=\"leiden_0_5\")\n    >>> ep.tl.paga(adata, groups=\"leiden_0_5\")\n    >>> ep.pl.paga(\n    ...     adata,\n    ...     color=[\"leiden_0_5\", \"day_28_flg\"],\n    ...     cmap=ep.pl.Colormaps.grey_red.value,\n    ...     title=[\"Leiden 0.5\", \"Died in less than 28 days\"],\n    ... )\n    >>> ep.tl.draw_graph(adata, init_pos=\"paga\")\n    >>> ep.pl.draw_graph(adata, color=[\"leiden_0_5\", \"icu_exp_flg\"], legend_loc=\"on data\")\n\nPreview:\n    .. image:: /_static/docstring_previews/draw_graph_1.png\n\n    .. image:: /_static/docstring_previews/draw_graph_2.png",
        "api_type": "function",
        "api_calling": [
            "ehrapy.plot.draw_graph(adata=$, layout=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.plot.paga_path": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object object containing all observations.",
                "optional_value": true
            },
            "nodes": {
                "type": "Sequence[str | int]",
                "default": null,
                "optional": false,
                "description": "A path through nodes of the abstracted graph, that is, names or indices\n(within `.categories`) of groups that have been used to run PAGA.",
                "optional_value": false
            },
            "keys": {
                "type": "Sequence[str]",
                "default": null,
                "optional": false,
                "description": "Either variables in `adata.var_names` or annotations in `adata.obs`. They are plotted using `color_map`.",
                "optional_value": false
            },
            "use_raw": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Use `adata.raw` for retrieving feature values if it has been set.",
                "optional_value": false
            },
            "annotations": {
                "type": "Sequence[str]",
                "default": "('dpt_pseudotime',)",
                "optional": true,
                "description": "Plot these keys with `color_maps_annotations`. Need to be keys for `adata.obs`.",
                "optional_value": false
            },
            "color_map": {
                "type": "Optional[Union[str, Colormap]]",
                "default": "None",
                "optional": true,
                "description": "Matplotlib colormap.",
                "optional_value": false
            },
            "color_maps_annotations": {
                "type": "Mapping[str, str | Colormap]",
                "default": "{'dpt_pseudotime': 'Greys'}",
                "optional": true,
                "description": "Color maps for plotting the annotations. Keys of the dictionary must appear in `annotations`.",
                "optional_value": false
            },
            "palette_groups": {
                "type": "Optional[Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "Usually, use the same `sc.pl.palettes...` as used for coloring the abstracted graph.",
                "optional_value": false
            },
            "n_avg": {
                "type": "int",
                "default": "1",
                "optional": true,
                "description": "Number of data points to include in computation of running average.",
                "optional_value": false
            },
            "groups_key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Key of the grouping used to run PAGA. If `None`, defaults to `adata.uns['paga']['groups']`.",
                "optional_value": false
            },
            "xlim": {
                "type": "tuple[int | None, int | None]",
                "default": "(None, None)",
                "optional": true,
                "description": "Matplotlib x limit.",
                "optional_value": false
            },
            "title": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Plot title.",
                "optional_value": false
            },
            "left_margin": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "Margin to the left of the plot.",
                "optional_value": true
            },
            "ytick_fontsize": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Matplotlib ytick fontsize.",
                "optional_value": false
            },
            "title_fontsize": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Font size of the title.",
                "optional_value": false
            },
            "show_node_names": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to plot the node names on the nodes bar.",
                "optional_value": false
            },
            "show_yticks": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to show the y axis ticks.",
                "optional_value": false
            },
            "show_colorbar": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to show the color bar.",
                "optional_value": false
            },
            "legend_fontsize": {
                "type": "Optional[Union[int, float, _FontSize]]",
                "default": "None",
                "optional": true,
                "description": "Font size of the legend.",
                "optional_value": false
            },
            "legend_fontweight": {
                "type": "Optional[Union[int, _FontWeight]]",
                "default": "None",
                "optional": true,
                "description": "Font weight of the legend.",
                "optional_value": false
            },
            "normalize_to_zero_one": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Shift and scale the running average to [0, 1] per feature.",
                "optional_value": false
            },
            "as_heatmap": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to display the plot as heatmap.",
                "optional_value": false
            },
            "return_data": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to return the timeseries data in addition to the axes if `True`.",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Whether to show the plot.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[bool, str]]",
                "default": "None",
                "optional": true,
                "description": "Whether or where to save the plot.",
                "optional_value": false
            },
            "ax": {
                "type": "Optional[Axes]",
                "default": "None",
                "optional": true,
                "description": "Matplotlib Axis object.",
                "optional_value": true
            }
        },
        "Returns": {
            "type": "Optional[Axes]",
            "description": ""
        },
        "Docstring": "Feature changes along paths in the abstracted graph.\n\nArgs:\n    adata: :class:`~anndata.AnnData` object object containing all observations.\n    nodes: A path through nodes of the abstracted graph, that is, names or indices\n           (within `.categories`) of groups that have been used to run PAGA.\n    keys: Either variables in `adata.var_names` or annotations in `adata.obs`. They are plotted using `color_map`.\n    use_raw: Use `adata.raw` for retrieving feature values if it has been set.\n    annotations: Plot these keys with `color_maps_annotations`. Need to be keys for `adata.obs`.\n    color_map: Matplotlib colormap.\n    color_maps_annotations: Color maps for plotting the annotations. Keys of the dictionary must appear in `annotations`.\n    palette_groups: Usually, use the same `sc.pl.palettes...` as used for coloring the abstracted graph.\n    n_avg: Number of data points to include in computation of running average.\n    groups_key: Key of the grouping used to run PAGA. If `None`, defaults to `adata.uns['paga']['groups']`.\n    xlim: Matplotlib x limit.\n    title: Plot title.\n    left_margin: Margin to the left of the plot.\n    ytick_fontsize: Matplotlib ytick fontsize.\n    title_fontsize: Font size of the title.\n    show_node_names: Whether to plot the node names on the nodes bar.\n    show_yticks: Whether to show the y axis ticks.\n    show_colorbar: Whether to show the color bar.\n    legend_fontsize: Font size of the legend.\n    legend_fontweight: Font weight of the legend.\n    normalize_to_zero_one: Shift and scale the running average to [0, 1] per feature.\n    as_heatmap: Whether to display the plot as heatmap.\n    return_data: Whether to return the timeseries data in addition to the axes if `True`.\n    ax: Matplotlib Axis object.\n    show: Whether to show the plot.\n    save: Whether or where to save the plot.\n\nReturns:\n    A :class:`~matplotlib.axes.Axes` object, if `ax` is `None`, else `None`.\n    If `return_data`, return the timeseries data in addition to an axes.",
        "description": "Feature changes along paths in the abstracted graph.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "ehrapy.plot.paga_path(adata=$, nodes=@, keys=@, use_raw=@, annotations=@, color_map=@, color_maps_annotations=@, palette_groups=@, n_avg=@, groups_key=@, xlim=@, title=@, left_margin=$, ytick_fontsize=@, title_fontsize=@, show_node_names=@, show_yticks=@, show_colorbar=@, legend_fontsize=@, legend_fontweight=@, normalize_to_zero_one=@, as_heatmap=@, return_data=@, show=@, save=@, ax=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.data.parkinsons_disease_classification": {
        "Parameters": {
            "encoded": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to return an already encoded object.",
                "optional_value": false
            },
            "columns_obs_only": {
                "type": "Optional[Union[dict[str, list[str]], list[str]]]",
                "default": "None",
                "optional": true,
                "description": "Columns to include in obs only and not X.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": ""
        },
        "Docstring": "Loads the Parkinson's Disease Classification Data Set\n\nMore details: http://archive.ics.uci.edu/ml/datasets/Parkinson%27s+Disease+Classification\nPreprocessing: https://github.com/theislab/ehrapy-datasets/blob/main/parkinson's_disease_classification/parkinson's_disease_classification.ipynb\n\nArgs:\n    encoded: Whether to return an already encoded object.\n    columns_obs_only: Columns to include in obs only and not X.\n\nReturns:\n    :class:`~anndata.AnnData` object of the Parkinson's Disease Classification Data Set\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.parkinsons_disease_classification(encoded=True)",
        "description": "Loads the Parkinson's Disease Classification Data SetMore details: http://archive.ics.uci.edu/ml/datasets/Parkinson%27s+Disease+Classification\nPreprocessing: https://github.com/theislab/ehrapy-datasets/blob/main/parkinson's_disease_classification/parkinson's_disease_classification.ipynb",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.parkinsons_disease_classification(encoded=True)",
        "api_type": "function",
        "api_calling": [
            "ehrapy.data.parkinsons_disease_classification(encoded=@, columns_obs_only=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.data.echocardiogram": {
        "Parameters": {
            "encoded": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to return an already encoded object",
                "optional_value": false
            },
            "columns_obs_only": {
                "type": "Optional[Union[dict[str, list[str]], list[str]]]",
                "default": "None",
                "optional": true,
                "description": "Columns to include in obs only and not X.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": ""
        },
        "Docstring": "Loads the Echocardiogram Data Set\n\nMore details: http://archive.ics.uci.edu/ml/datasets/Echocardiogram\nPreprocessing: https://github.com/theislab/ehrapy-datasets/blob/main/echocardiogram/echocardiogram.ipynb\n\nArgs:\n    encoded: Whether to return an already encoded object\n    columns_obs_only: Columns to include in obs only and not X.\n\nReturns:\n    :class:`~anndata.AnnData` object of the Echocardiogram Data Set\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.echocardiogram(encoded=True)",
        "description": "Loads the Echocardiogram Data SetMore details: http://archive.ics.uci.edu/ml/datasets/Echocardiogram\nPreprocessing: https://github.com/theislab/ehrapy-datasets/blob/main/echocardiogram/echocardiogram.ipynb",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.echocardiogram(encoded=True)",
        "api_type": "function",
        "api_calling": [
            "ehrapy.data.echocardiogram(encoded=@, columns_obs_only=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.plot.dpt_groups_pseudotime": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object object containing all observations.",
                "optional_value": true
            },
            "color_map": {
                "type": "Optional[Union[str, Colormap]]",
                "default": "None",
                "optional": true,
                "description": "Matplotlib Colormap",
                "optional_value": false
            },
            "palette": {
                "type": "Optional[Union[Sequence[str], Cycler]]",
                "default": "None",
                "optional": true,
                "description": "Matplotlib color Palette",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Whether to show the plot.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[bool, str]]",
                "default": "None",
                "optional": true,
                "description": "Whether to save the plot or a path to save the plot.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Plot groups and pseudotime.\n\nArgs:\n    adata: :class:`~anndata.AnnData` object object containing all observations.\n    color_map: Matplotlib Colormap\n    palette: Matplotlib color Palette\n    show: Whether to show the plot.\n    save: Whether to save the plot or a path to save the plot.\n\nExamples:\n    >>> import ehrapy as ep\n    >>> import numpy as np\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.knn_impute(adata)\n    >>> ep.pp.log_norm(adata, offset=1)\n    >>> ep.pp.neighbors(adata, method='gauss')\n    >>> ep.tl.leiden(adata, resolution=0.5, key_added=\"leiden_0_5\")\n    >>> ep.tl.diffmap(adata, n_comps=10)\n    >>> adata.uns['iroot'] = np.flatnonzero(adata.obs['leiden_0_5'] == '0')[0]\n    >>> ep.tl.dpt(adata, n_branchings=3)\n    >>> ep.pl.dpt_groups_pseudotime(adata)\n\nPreview:\n    .. image:: /_static/docstring_previews/dpt_groups_pseudotime.png",
        "description": "Plot groups and pseudotime.",
        "example": ">>> import ehrapy as ep\n    >>> import numpy as np\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.knn_impute(adata)\n    >>> ep.pp.log_norm(adata, offset=1)\n    >>> ep.pp.neighbors(adata, method='gauss')\n    >>> ep.tl.leiden(adata, resolution=0.5, key_added=\"leiden_0_5\")\n    >>> ep.tl.diffmap(adata, n_comps=10)\n    >>> adata.uns['iroot'] = np.flatnonzero(adata.obs['leiden_0_5'] == '0')[0]\n    >>> ep.tl.dpt(adata, n_branchings=3)\n    >>> ep.pl.dpt_groups_pseudotime(adata)\n\nPreview:\n    .. image:: /_static/docstring_previews/dpt_groups_pseudotime.png",
        "api_type": "function",
        "api_calling": [
            "ehrapy.plot.dpt_groups_pseudotime(adata=$, color_map=@, palette=@, show=@, save=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.tools.test_nested_f_statistic": {
        "Parameters": {
            "small_model": {
                "type": "GLMResultsWrapper",
                "default": null,
                "optional": false,
                "description": "fitted generalized linear models.",
                "optional_value": true
            },
            "big_model": {
                "type": "GLMResultsWrapper",
                "default": null,
                "optional": false,
                "description": "fitted generalized linear models.",
                "optional_value": true
            }
        },
        "Returns": {
            "type": "float",
            "description": ""
        },
        "Docstring": "Given two fitted GLMs, the larger of which contains the parameter space of the smaller, return the P value corresponding to the larger model adding explanatory power.\n\nSee https://stackoverflow.com/questions/27328623/anova-test-for-glm-in-python/60769343#60769343\n\nArgs:\n    small_model (GLMResultsWrapper): fitted generalized linear models.\n    big_model (GLMResultsWrapper): fitted generalized linear models.\n\nReturns:\n    float: p_value",
        "description": "Given two fitted GLMs, the larger of which contains the parameter space of the smaller, return the P value corresponding to the larger model adding explanatory power.See https://stackoverflow.com/questions/27328623/anova-test-for-glm-in-python/60769343#60769343",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "ehrapy.tools.test_nested_f_statistic(small_model=$, big_model=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.anndata.get_var_df": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "AnnData object to get values from.",
                "optional_value": true
            },
            "keys": {
                "type": "Iterable[str]",
                "default": "()",
                "optional": true,
                "description": "Keys from either `.obs_names`, or `.var.columns`.",
                "optional_value": false
            },
            "varm_keys": {
                "type": "Iterable[tuple[str, int]]",
                "default": "()",
                "optional": true,
                "description": "Tuple of `(key from varm, column index of varm[key])`.",
                "optional_value": false
            },
            "layer": {
                "type": "str",
                "default": "None",
                "optional": true,
                "description": "Layer of `adata`.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Return values for observations in adata.\n\nArgs:\n    adata: AnnData object to get values from.\n    keys: Keys from either `.obs_names`, or `.var.columns`.\n    varm_keys: Tuple of `(key from varm, column index of varm[key])`.\n    layer: Layer of `adata`.\n\nReturns:\n    A dataframe with `adata.var_names` as index, and values specified by `keys` and `varm_keys`.\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> four_patients = ep.ad.get_var_df(adata, keys = ['0', '1', '2', '3'])",
        "description": "Return values for observations in adata.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> four_patients = ep.ad.get_var_df(adata, keys = ['0', '1', '2', '3'])",
        "api_type": "function",
        "api_calling": [
            "ehrapy.anndata.get_var_df(adata=$, keys=@, varm_keys=@, layer=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.preprocessing.regress_out": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object object containing all observations.",
                "optional_value": true
            },
            "keys": {
                "type": "Union[str, Sequence[str]]",
                "default": null,
                "optional": false,
                "description": "Keys for observation annotation on which to regress on.",
                "optional_value": false
            },
            "n_jobs": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Number of jobs for parallel computation. `None` means using :attr:`scanpy._settings.ScanpyConfig.n_jobs`.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Determines whether a copy of `adata` is returned.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[AnnData]",
            "description": ""
        },
        "Docstring": "Regress out (mostly) unwanted sources of variation.\n\nUses simple linear regression. This is inspired by Seurat's `regressOut` function in R [Satija15].\nNote that this function tends to overcorrect in certain circumstances.\n\nArgs:\n    adata: :class:`~anndata.AnnData` object object containing all observations.\n    keys: Keys for observation annotation on which to regress on.\n    n_jobs: Number of jobs for parallel computation. `None` means using :attr:`scanpy._settings.ScanpyConfig.n_jobs`.\n    copy: Determines whether a copy of `adata` is returned.\n\nReturns:\n    Depending on `copy` returns or updates an :class:`~anndata.AnnData` object with the corrected data matrix.",
        "description": "Regress out (mostly) unwanted sources of variation.Uses simple linear regression. This is inspired by Seurat's `regressOut` function in R [Satija15].\nNote that this function tends to overcorrect in certain circumstances.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "ehrapy.preprocessing.regress_out(adata=$, keys=@, n_jobs=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.plot.rank_features_groups": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "groups": {
                "type": "Union[str, Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "The groups for which to show the feature ranking.",
                "optional_value": false
            },
            "n_features": {
                "type": "int",
                "default": "20",
                "optional": true,
                "description": "The number of features to plot.",
                "optional_value": false
            },
            "feature_symbols": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Key for field in `.var` that stores feature symbols if you do not want to use `.var_names`.",
                "optional_value": false
            },
            "key": {
                "type": "Optional[str]",
                "default": "rank_features_groups",
                "optional": true,
                "description": "The key of the calculated feature group rankings (default: 'rank_features_groups').",
                "optional_value": false
            },
            "fontsize": {
                "type": "int",
                "default": "8",
                "optional": true,
                "description": "Fontsize for feature names.",
                "optional_value": false
            },
            "ncols": {
                "type": "int",
                "default": "4",
                "optional": true,
                "description": "Number of panels shown per row.",
                "optional_value": false
            },
            "share_y": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Controls if the y-axis of each panels should be shared.\nBut passing `sharey=False`, each panel has its own y-axis range.",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Whether to display the figure or return axis.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.",
                "optional_value": false
            },
            "ax": {
                "type": "Optional[Axes]",
                "default": "None",
                "optional": true,
                "description": "A matplotlib axes object. Only works if plotting a single component.",
                "optional_value": true
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Plot ranking of features.\n\nArgs:\n    adata: Annotated data matrix.\n    groups: The groups for which to show the feature ranking.\n    n_features: The number of features to plot.\n    feature_symbols: Key for field in `.var` that stores feature symbols if you do not want to use `.var_names`.\n    key: The key of the calculated feature group rankings (default: 'rank_features_groups').\n    fontsize: Fontsize for feature names.\n    ncols: Number of panels shown per row.\n    share_y: Controls if the y-axis of each panels should be shared.\n             But passing `sharey=False`, each panel has its own y-axis range.\n    show: Whether to display the figure or return axis.\n    save: If `True` or a `str`, save the figure.\n          A string is appended to the default filename.\n          Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\n    ax: A matplotlib axes object. Only works if plotting a single component.\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.knn_impute(adata)\n    >>> ep.pp.log_norm(adata, offset=1)\n    >>> ep.pp.neighbors(adata)\n    >>> ep.tl.leiden(adata, resolution=0.15, key_added=\"leiden_0_5\")\n    >>> ep.tl.rank_features_groups(adata, groupby=\"leiden_0_5\")\n    >>> ep.pl.rank_features_groups(adata, key=\"rank_features_groups\")\n\nPreview:\n    .. image:: /_static/docstring_previews/rank_features_groups.png",
        "description": "Plot ranking of features.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.knn_impute(adata)\n    >>> ep.pp.log_norm(adata, offset=1)\n    >>> ep.pp.neighbors(adata)\n    >>> ep.tl.leiden(adata, resolution=0.15, key_added=\"leiden_0_5\")\n    >>> ep.tl.rank_features_groups(adata, groupby=\"leiden_0_5\")\n    >>> ep.pl.rank_features_groups(adata, key=\"rank_features_groups\")\n\nPreview:\n    .. image:: /_static/docstring_previews/rank_features_groups.png",
        "api_type": "function",
        "api_calling": [
            "ehrapy.plot.rank_features_groups(adata=$, groups=@, n_features=@, feature_symbols=@, key=@, fontsize=@, ncols=@, share_y=@, show=@, save=@, ax=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.plot.embedding": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object object containing all observations.",
                "optional_value": true
            },
            "basis": {
                "type": "str",
                "default": null,
                "optional": false,
                "description": null,
                "optional_value": false
            },
            "color": {
                "type": "Optional[Union[str, Sequence[str]]]",
                "default": "None",
                "optional": true,
                "description": "Keys for annotations of observations/patients or features, e.g., `'ann1'` or `['ann1', 'ann2']`.",
                "optional_value": false
            },
            "feature_symbols": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Column name in `.var` DataFrame that stores feature symbols. By default `var_names`\nrefer to the index column of the `.var` DataFrame. Setting this option allows alternative names to be used.",
                "optional_value": false
            },
            "use_raw": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Use `.raw` attribute of `adata` for coloring with feature values. If `None`,\ndefaults to `True` if `layer` isn't provided and `adata.raw` is present.",
                "optional_value": false
            },
            "sort_order": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "For continuous annotations used as color parameter, plot data points with higher values on top of others.",
                "optional_value": false
            },
            "edges": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Show edges.",
                "optional_value": false
            },
            "edges_width": {
                "type": "float",
                "default": "0.1",
                "optional": true,
                "description": "Width of edges.",
                "optional_value": false
            },
            "edges_color": {
                "type": "Union[str, Sequence[float], Sequence[str]]",
                "default": "grey",
                "optional": true,
                "description": "Color of edges. See :func:`~networkx.drawing.nx_pylab.draw_networkx_edges`.",
                "optional_value": false
            },
            "neighbors_key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Where to look for neighbors connectivities.\nIf not specified, this looks .obsp['connectivities'] for connectivities\n(default storage place for pp.neighbors). If specified, this looks at\n`.obsp[.uns[neighbors_key]['connectivities_key']]` for connectivities.",
                "optional_value": false
            },
            "arrows": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Show arrows (deprecated in favour of `scvelo.pl.velocity_embedding`).",
                "optional_value": false
            },
            "groups": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Restrict to a few categories in categorical observation annotation.\nThe default is not to restrict to any groups.",
                "optional_value": false
            },
            "components": {
                "type": "Union[str, Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "For instance, `['1,2', '2,3']`. To plot all available components use `components='all'`.",
                "optional_value": false
            },
            "layer": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Name of the AnnData object layer that wants to be plotted. By default\nadata.raw.X is plotted. If `use_raw=False` is set, then `adata.X` is plotted.\nIf `layer` is set to a valid layer name, then the layer is plotted. `layer` takes precedence over `use_raw`.",
                "optional_value": false
            },
            "projection": {
                "type": "Literal['2d', '3d']",
                "default": "2d",
                "optional": true,
                "description": "Projection of plot (default: `'2d'`).",
                "optional_value": true
            },
            "scale_factor": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "color_map": {
                "type": "Optional[Union[Colormap, str]]",
                "default": "None",
                "optional": true,
                "description": "Color map to use for continous variables. Can be a name or a\n:class:`~matplotlib.colors.Colormap` instance (e.g. `\"magma`\", `\"viridis\"`\nor `mpl.cm.cividis`), see :func:`~matplotlib.cm.get_cmap`.\nIf `None`, the value of `mpl.rcParams[\"image.cmap\"]` is used.\nThe default `color_map` can be set using :func:`~scanpy.set_figure_params`.",
                "optional_value": false
            },
            "cmap": {
                "type": "Optional[Union[Colormap, str]]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "palette": {
                "type": "Optional[Union[str, Sequence[str], Cycler]]",
                "default": "None",
                "optional": true,
                "description": "Colors to use for plotting categorical annotation groups.\nThe palette can be a valid :class:`~matplotlib.colors.ListedColormap` name\n(`'Set2'`, `'tab20'`, \u2026), a :class:`~cycler.Cycler` object, a dict mapping\ncategories to colors, or a sequence of colors. Colors must be valid to\nmatplotlib. (see :func:`~matplotlib.colors.is_color_like`).\nIf `None`, `mpl.rcParams[\"axes.prop_cycle\"]` is used unless the categorical\nvariable already has colors stored in `adata.uns[\"{var}_colors\"]`.\nIf provided, values of `adata.uns[\"{var}_colors\"]` will be set.",
                "optional_value": false
            },
            "na_color": {
                "type": "ColorLike",
                "default": "lightgray",
                "optional": true,
                "description": "Color to use for null or masked values. Can be anything matplotlib accepts as a color.\nUsed for all points if `color=None`.",
                "optional_value": true
            },
            "na_in_legend": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "If there are missing values, whether they get an entry in the legend.\nCurrently only implemented for categorical legends.",
                "optional_value": false
            },
            "size": {
                "type": "Optional[Union[float, Sequence[float]]]",
                "default": "None",
                "optional": true,
                "description": "Point size. If `None`, is automatically computed as 120000 / n_features.\nCan be a sequence containing the size for each observation. The order should be the same as in adata.obs.",
                "optional_value": false
            },
            "frameon": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Draw a frame around the scatter plot. Defaults to value set in :func:`~scanpy.set_figure_params` (default: True).",
                "optional_value": false
            },
            "legend_fontsize": {
                "type": "Optional[Union[int, float, _FontSize]]",
                "default": "None",
                "optional": true,
                "description": "Numeric size in pt or string describing the size. See :meth:`~matplotlib.text.Text.set_fontsize`.",
                "optional_value": false
            },
            "legend_fontweight": {
                "type": "Union[int, _FontWeight]",
                "default": "bold",
                "optional": true,
                "description": "Legend font weight. A numeric value in range 0-1000 or a string.\nDefaults to `'bold'` if `legend_loc == 'on data'`, otherwise to `'normal'`.\nSee :meth:`~matplotlib.text.Text.set_fontweight`.",
                "optional_value": false
            },
            "legend_loc": {
                "type": "str",
                "default": "right margin",
                "optional": true,
                "description": "Location of legend, either `'on data'`, `'right margin'` or a valid keyword for the `loc` parameter of :class:`~matplotlib.legend.Legend`.",
                "optional_value": false
            },
            "legend_fontoutline": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Line width of the legend font outline in pt. Draws a white outline using the path effect :class:`~matplotlib.patheffects.withStroke`.",
                "optional_value": false
            },
            "vmax": {
                "type": "Optional[Union[VBound, Sequence[VBound]]]",
                "default": "None",
                "optional": true,
                "description": "The value representing the upper limit of the color scale. The format is the same as for `vmin`.",
                "optional_value": true
            },
            "vmin": {
                "type": "Optional[Union[VBound, Sequence[VBound]]]",
                "default": "None",
                "optional": true,
                "description": "The value representing the lower limit of the color scale. Values smaller than vmin are plotted\nwith the same color as vmin. vmin can be a number, a string, a function or `None`. If\nvmin is a string and has the format `pN`, this is interpreted as a vmin=percentile(N).\nFor example vmin='p1.5' is interpreted as the 1.5 percentile. If vmin is function, then\nvmin is interpreted as the return value of the function over the list of values to plot.\nFor example to set vmin tp the mean of the values to plot, `def my_vmin(values): return\nnp.mean(values)` and then set `vmin=my_vmin`. If vmin is None (default) an automatic\nminimum value is used as defined by matplotlib `scatter` function. When making multiple\nplots, vmin can be a list of values, one for each plot. For example `vmin=[0.1, 'p1', None, my_vmin]`",
                "optional_value": true
            },
            "vcenter": {
                "type": "Optional[Union[VBound, Sequence[VBound]]]",
                "default": "None",
                "optional": true,
                "description": "The value representing the center of the color scale. Useful for diverging colormaps.\nThe format is the same as for `vmin`.\nExample: sc.pl.umap(adata, color='TREM2', vcenter='p50', cmap='RdBu_r')",
                "optional_value": true
            },
            "norm": {
                "type": "Optional[Union[Normalize, Sequence[Normalize]]]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "add_outline": {
                "type": "Optional[bool]",
                "default": "False",
                "optional": true,
                "description": "If set to True, this will add a thin border around groups of dots. In some situations\nthis can enhance the aesthetics of the resulting image",
                "optional_value": false
            },
            "outline_width": {
                "type": "tuple[float, float]",
                "default": "(0.3, 0.05)",
                "optional": true,
                "description": "Tuple with two width numbers used to adjust the outline. The first value is the width\nof the border color as a fraction of the scatter dot size (default: 0.3). The second value is\nwidth of the gap color (default: 0.05).",
                "optional_value": false
            },
            "outline_color": {
                "type": "tuple[str, str]",
                "default": "('black', 'white')",
                "optional": true,
                "description": "Tuple with two valid color names used to adjust the add_outline. The first color is the\nborder color (default: black), while the second color is a gap color between the\nborder color and the scatter dot (default: white).",
                "optional_value": false
            },
            "ncols": {
                "type": "int",
                "default": "4",
                "optional": true,
                "description": "Number of panels per row.\nwspace: Adjust the width of the space between multiple panels.\nhspace: Adjust the height of the space between multiple panels.\nreturn_fig: Return the matplotlib figure.",
                "optional_value": false
            },
            "hspace": {
                "type": "float",
                "default": "0.25",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "wspace": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "title": {
                "type": "Optional[Union[str, Sequence[str]]]",
                "default": "None",
                "optional": true,
                "description": "Provide title for panels either as string or list of strings, e.g. `['title1', 'title2', ...]`.",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Whether to display the figure or return axis.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[bool, str]]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.",
                "optional_value": false
            },
            "ax": {
                "type": "Optional[Axes]",
                "default": "None",
                "optional": true,
                "description": "A matplotlib axes object. Only works if plotting a single component.",
                "optional_value": true
            },
            "return_fig": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[Union[Figure, Axes]]",
            "description": ""
        },
        "Docstring": "Scatter plot for user specified embedding basis (e.g. umap, pca, etc).\n\nArgs:\n    basis:\n    adata: :class:`~anndata.AnnData` object object containing all observations.\n    color: Keys for annotations of observations/patients or features, e.g., `'ann1'` or `['ann1', 'ann2']`.\n    feature_symbols: Column name in `.var` DataFrame that stores feature symbols. By default `var_names`\n                     refer to the index column of the `.var` DataFrame. Setting this option allows alternative names to be used.\n    use_raw: Use `.raw` attribute of `adata` for coloring with feature values. If `None`,\n             defaults to `True` if `layer` isn't provided and `adata.raw` is present.\n    layer: Name of the AnnData object layer that wants to be plotted. By default\n           adata.raw.X is plotted. If `use_raw=False` is set, then `adata.X` is plotted.\n           If `layer` is set to a valid layer name, then the layer is plotted. `layer` takes precedence over `use_raw`.\n    edges: Show edges.\n    edges_width: Width of edges.\n    edges_color: Color of edges. See :func:`~networkx.drawing.nx_pylab.draw_networkx_edges`.\n    neighbors_key: Where to look for neighbors connectivities.\n                   If not specified, this looks .obsp['connectivities'] for connectivities\n                   (default storage place for pp.neighbors). If specified, this looks at\n                   `.obsp[.uns[neighbors_key]['connectivities_key']]` for connectivities.\n    arrows: Show arrows (deprecated in favour of `scvelo.pl.velocity_embedding`).\n    arrows_kwds: Passed to :meth:`~matplotlib.axes.Axes.quiver`\n    sort_order: For continuous annotations used as color parameter, plot data points with higher values on top of others.\n    groups: Restrict to a few categories in categorical observation annotation.\n            The default is not to restrict to any groups.\n    components: For instance, `['1,2', '2,3']`. To plot all available components use `components='all'`.\n    projection: Projection of plot (default: `'2d'`).\n    legend_loc: Location of legend, either `'on data'`, `'right margin'` or a valid keyword for the `loc` parameter of :class:`~matplotlib.legend.Legend`.\n    legend_fontsize: Numeric size in pt or string describing the size. See :meth:`~matplotlib.text.Text.set_fontsize`.\n    legend_fontweight: Legend font weight. A numeric value in range 0-1000 or a string.\n                       Defaults to `'bold'` if `legend_loc == 'on data'`, otherwise to `'normal'`.\n                       See :meth:`~matplotlib.text.Text.set_fontweight`.\n    legend_fontoutline: Line width of the legend font outline in pt. Draws a white outline using the path effect :class:`~matplotlib.patheffects.withStroke`.\n    size: Point size. If `None`, is automatically computed as 120000 / n_features.\n          Can be a sequence containing the size for each observation. The order should be the same as in adata.obs.\n    color_map: Color map to use for continous variables. Can be a name or a\n               :class:`~matplotlib.colors.Colormap` instance (e.g. `\"magma`\", `\"viridis\"`\n               or `mpl.cm.cividis`), see :func:`~matplotlib.cm.get_cmap`.\n               If `None`, the value of `mpl.rcParams[\"image.cmap\"]` is used.\n               The default `color_map` can be set using :func:`~scanpy.set_figure_params`.\n    palette: Colors to use for plotting categorical annotation groups.\n             The palette can be a valid :class:`~matplotlib.colors.ListedColormap` name\n             (`'Set2'`, `'tab20'`, \u2026), a :class:`~cycler.Cycler` object, a dict mapping\n             categories to colors, or a sequence of colors. Colors must be valid to\n             matplotlib. (see :func:`~matplotlib.colors.is_color_like`).\n             If `None`, `mpl.rcParams[\"axes.prop_cycle\"]` is used unless the categorical\n             variable already has colors stored in `adata.uns[\"{var}_colors\"]`.\n             If provided, values of `adata.uns[\"{var}_colors\"]` will be set.\n    na_color: Color to use for null or masked values. Can be anything matplotlib accepts as a color.\n              Used for all points if `color=None`.\n    na_in_legend: If there are missing values, whether they get an entry in the legend.\n                  Currently only implemented for categorical legends.\n    frameon: Draw a frame around the scatter plot. Defaults to value set in :func:`~scanpy.set_figure_params` (default: True).\n    title: Provide title for panels either as string or list of strings, e.g. `['title1', 'title2', ...]`.\n    vmin: The value representing the lower limit of the color scale. Values smaller than vmin are plotted\n          with the same color as vmin. vmin can be a number, a string, a function or `None`. If\n          vmin is a string and has the format `pN`, this is interpreted as a vmin=percentile(N).\n          For example vmin='p1.5' is interpreted as the 1.5 percentile. If vmin is function, then\n          vmin is interpreted as the return value of the function over the list of values to plot.\n          For example to set vmin tp the mean of the values to plot, `def my_vmin(values): return\n          np.mean(values)` and then set `vmin=my_vmin`. If vmin is None (default) an automatic\n          minimum value is used as defined by matplotlib `scatter` function. When making multiple\n          plots, vmin can be a list of values, one for each plot. For example `vmin=[0.1, 'p1', None, my_vmin]`\n    vmax: The value representing the upper limit of the color scale. The format is the same as for `vmin`.\n    vcenter: The value representing the center of the color scale. Useful for diverging colormaps.\n             The format is the same as for `vmin`.\n             Example: sc.pl.umap(adata, color='TREM2', vcenter='p50', cmap='RdBu_r')\n    add_outline: If set to True, this will add a thin border around groups of dots. In some situations\n                 this can enhance the aesthetics of the resulting image\n    outline_color: Tuple with two valid color names used to adjust the add_outline. The first color is the\n                   border color (default: black), while the second color is a gap color between the\n                   border color and the scatter dot (default: white).\n    outline_width: Tuple with two width numbers used to adjust the outline. The first value is the width\n                   of the border color as a fraction of the scatter dot size (default: 0.3). The second value is\n                   width of the gap color (default: 0.05).\n    ncols: Number of panels per row.\n           wspace: Adjust the width of the space between multiple panels.\n           hspace: Adjust the height of the space between multiple panels.\n           return_fig: Return the matplotlib figure.\n    kwargs: Arguments to pass to :func:`matplotlib.pyplot.scatter`,\n            for instance: the maximum and minimum values (e.g. `vmin=-2, vmax=5`).\n    show: Whether to display the figure or return axis.\n    save: If `True` or a `str`, save the figure.\n          A string is appended to the default filename.\n          Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\n    ax: A matplotlib axes object. Only works if plotting a single component.\n\nReturns:\n    If `show==False` a :class:`~matplotlib.axes.Axes` or a list of it.\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.knn_impute(adata)\n    >>> ep.pp.log_norm(adata, offset=1)\n    >>> ep.pp.neighbors(adata)\n    >>> ep.tl.umap(adata)\n    >>> ep.pl.embedding(adata, 'X_umap', color='icu_exp_flg')\n\nPreview:\n    .. image:: /_static/docstring_previews/embedding.png",
        "description": "Scatter plot for user specified embedding basis (e.g. umap, pca, etc).",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.knn_impute(adata)\n    >>> ep.pp.log_norm(adata, offset=1)\n    >>> ep.pp.neighbors(adata)\n    >>> ep.tl.umap(adata)\n    >>> ep.pl.embedding(adata, 'X_umap', color='icu_exp_flg')\n\nPreview:\n    .. image:: /_static/docstring_previews/embedding.png",
        "api_type": "function",
        "api_calling": [
            "ehrapy.plot.embedding(adata=$, basis=@, color=@, feature_symbols=@, use_raw=@, sort_order=@, edges=@, edges_width=@, edges_color=@, neighbors_key=@, arrows=@, groups=@, components=@, layer=@, projection=$, scale_factor=@, color_map=@, cmap=@, palette=@, na_color=$, na_in_legend=@, size=@, frameon=@, legend_fontsize=@, legend_fontweight=@, legend_loc=@, legend_fontoutline=@, vmax=$, vmin=$, vcenter=$, norm=$, add_outline=@, outline_width=@, outline_color=@, ncols=@, hspace=@, wspace=@, title=@, show=@, save=@, ax=$, return_fig=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.preprocessing.qc_metrics": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "qc_vars": {
                "type": "Collection[str]",
                "default": "()",
                "optional": true,
                "description": "Optional List of vars to calculate additional metrics for.",
                "optional_value": false
            },
            "layer": {
                "type": "str",
                "default": "None",
                "optional": true,
                "description": "Layer to use to calculate the metrics.",
                "optional_value": false
            },
            "inplace": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to add the metrics to obs/var or to solely return a Pandas DataFrame.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[pd.DataFrame]",
            "description": ""
        },
        "Docstring": "Calculates various quality control metrics.\n\nUses the original values to calculate the metrics and not the encoded ones.\nLook at the return type for a more in depth description of the calculated metrics.\n\nArgs:\n    adata: Annotated data matrix.\n    qc_vars: Optional List of vars to calculate additional metrics for.\n    layer: Layer to use to calculate the metrics.\n    inplace: Whether to add the metrics to obs/var or to solely return a Pandas DataFrame.\n\nReturns:\n    Pandas DataFrame of all calculated QC metrics.\n\n    Observation level metrics include:\n\n    - `missing_values_abs`: Absolute amount of missing values.\n    - `missing_values_pct`: Relative amount of missing values in percent.\n\n    Feature level metrics include:\n\n    - `missing_values_abs`: Absolute amount of missing values.\n    - `missing_values_pct`: Relative amount of missing values in percent.\n    - `mean`: Mean value of the features.\n    - `median`: Median value of the features.\n    - `std`: Standard deviation of the features.\n    - `min`: Minimum value of the features.\n    - `max`: Maximum value of the features.\n\n    Examples:\n        >>> import ehrapy as ep\n        >>> import seaborn as sns\n        >>> adata = ep.dt.mimic_2(encoded=True)\n        >>> ep.pp.qc_metrics(adata)\n        >>> sns.displot(adata.obs[\"missing_values_abs\"])",
        "description": "Calculates various quality control metrics.Uses the original values to calculate the metrics and not the encoded ones.\nLook at the return type for a more in depth description of the calculated metrics.",
        "example": ">>> import ehrapy as ep\n        >>> import seaborn as sns\n        >>> adata = ep.dt.mimic_2(encoded=True)\n        >>> ep.pp.qc_metrics(adata)\n        >>> sns.displot(adata.obs[\"missing_values_abs\"])",
        "api_type": "function",
        "api_calling": [
            "ehrapy.preprocessing.qc_metrics(adata=$, qc_vars=@, layer=@, inplace=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.preprocessing.subsample": {
        "Parameters": {
            "data": {
                "type": "Union[AnnData, ndarray, spmatrix]",
                "default": null,
                "optional": false,
                "description": "The (annotated) data matrix of shape `n_obs` \u00d7 `n_vars`. Rows correspond to observations (patients) and columns to features.",
                "optional_value": true
            },
            "fraction": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Subsample to this `fraction` of the number of observations.",
                "optional_value": false
            },
            "n_obs": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Subsample to this number of observations.",
                "optional_value": false
            },
            "random_state": {
                "type": "Optional[Union[int, RandomState]]",
                "default": "0",
                "optional": true,
                "description": "Random seed to change subsampling.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If an :class:`~anndata.AnnData` is passed, determines whether a copy is returned.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[AnnData]",
            "description": ""
        },
        "Docstring": "Subsample to a fraction of the number of observations.\n\nArgs:\n    data: The (annotated) data matrix of shape `n_obs` \u00d7 `n_vars`. Rows correspond to observations (patients) and columns to features.\n    fraction: Subsample to this `fraction` of the number of observations.\n    n_obs: Subsample to this number of observations.\n    random_state: Random seed to change subsampling.\n    copy: If an :class:`~anndata.AnnData` is passed, determines whether a copy is returned.\n\nReturns:\n    Returns `X[obs_indices], obs_indices` if data is array-like, otherwise subsamples the passed\n    :class:`~anndata.AnnData` (`copy == False`) or returns a subsampled copy of it (`copy == True`).",
        "description": "Subsample to a fraction of the number of observations.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "ehrapy.preprocessing.subsample(data=$, fraction=@, n_obs=@, random_state=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.plot.dotplot": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "var_names": {
                "type": "Union[_VarNames, Mapping[str, _VarNames]]",
                "default": null,
                "optional": false,
                "description": "`var_names` should be a valid subset of `adata.var_names`.\nIf `var_names` is a mapping, then the key is used as label\nto group the values (see `var_group_labels`). The mapping values\nshould be sequences of valid `adata.var_names`. In this\ncase either coloring or 'brackets' are used for the grouping\nof var names depending on the plot. When `var_names` is a mapping,\nthen the `var_group_labels` and `var_group_positions` are set.",
                "optional_value": false
            },
            "groupby": {
                "type": "str",
                "default": null,
                "optional": false,
                "description": "The key of the observation grouping to consider.",
                "optional_value": false
            },
            "use_raw": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Use `raw` attribute of `adata` if present.",
                "optional_value": false
            },
            "log": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Plot on logarithmic axis.",
                "optional_value": false
            },
            "num_categories": {
                "type": "int",
                "default": "7",
                "optional": true,
                "description": "Only used if groupby observation is not categorical. This value\ndetermines the number of groups into which the groupby observation should be subdivided.",
                "optional_value": false
            },
            "feature_cutoff": {
                "type": "float",
                "default": "0.0",
                "optional": true,
                "description": "Count cutoff that is used for binarizing the counts and\ndetermining the fraction of patients having the feature.\nA feature is only used if its counts are greater than this threshold.",
                "optional_value": false
            },
            "mean_only_counts": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If True, counts are averaged only over the patients having the provided feature.",
                "optional_value": false
            },
            "cmap": {
                "type": "str",
                "default": "Reds",
                "optional": true,
                "description": "String denoting matplotlib color map.",
                "optional_value": false
            },
            "dot_max": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "If none, the maximum dot size is set to the maximum fraction value found\n(e.g. 0.6). If given, the value should be a number between 0 and 1.\nAll fractions larger than dot_max are clipped to this value.",
                "optional_value": false
            },
            "dot_min": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "If none, the minimum dot size is set to 0. If given,\nthe value should be a number between 0 and 1.\nAll fractions smaller than dot_min are clipped to this value.",
                "optional_value": false
            },
            "standard_scale": {
                "type": "Optional[Literal['var', 'group']]",
                "default": "None",
                "optional": true,
                "description": "Whether or not to standardize the given dimension between 0 and 1, meaning for\neach variable or group, subtract the minimum and divide each by its maximum.",
                "optional_value": true
            },
            "smallest_dot": {
                "type": "Optional[float]",
                "default": "0.0",
                "optional": true,
                "description": "If none, the smallest dot has size 0. All counts with `dot_min` are plotted with this size.",
                "optional_value": false
            },
            "title": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Title for the figure",
                "optional_value": false
            },
            "colorbar_title": {
                "type": "Optional[str]",
                "default": "Mean value in group",
                "optional": true,
                "description": "Title for the color bar. New line character (\\n) can be used.",
                "optional_value": false
            },
            "size_title": {
                "type": "Optional[str]",
                "default": "Fraction of cells\nin group (%)",
                "optional": true,
                "description": "Title for the size legend. New line character (\\n) can be used.",
                "optional_value": false
            },
            "figsize": {
                "type": "Optional[tuple[float, float]]",
                "default": "None",
                "optional": true,
                "description": "Figure size when `multi_panel=True`. Otherwise the `rcParam['figure.figsize]` value is used.\nFormat is (width, height)",
                "optional_value": false
            },
            "dendrogram": {
                "type": "Union[bool, str]",
                "default": "False",
                "optional": true,
                "description": "If True or a valid dendrogram key, a dendrogram based on the hierarchical\nclustering between the `groupby` categories is added.\nThe dendrogram information is computed using :func:`scanpy.tl.dendrogram`.\nIf `tl.dendrogram` has not been called previously the function is called with default parameters.",
                "optional_value": false
            },
            "feature_symbols": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Column name in `.var` DataFrame that stores feature symbols.\nBy default `var_names` refer to the index column of the `.var` DataFrame.\nSetting this option allows alternative names to be used.",
                "optional_value": false
            },
            "var_group_positions": {
                "type": "Optional[Sequence[tuple[int, int]]]",
                "default": "None",
                "optional": true,
                "description": "Use this parameter to highlight groups of `var_names`.\nThis will draw a 'bracket' or a color block between the given start and end\npositions. If the parameter `var_group_labels` is set, the corresponding\nlabels are added on top/left. E.g. `var_group_positions=[(4,10)]`\nwill add a bracket between the fourth `var_name` and the tenth `var_name`.\nBy giving more positions, more brackets/color blocks are drawn.",
                "optional_value": false
            },
            "var_group_labels": {
                "type": "Optional[Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "Labels for each of the `var_group_positions` that want to be highlighted.",
                "optional_value": false
            },
            "var_group_rotation": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Label rotation degrees. By default, labels larger than 4 characters are rotated 90 degrees.",
                "optional_value": false
            },
            "layer": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Name of the AnnData object layer that wants to be plotted. By default adata.raw.X is plotted.\nIf `use_raw=False` is set, then `adata.X` is plotted. If `layer` is set to a valid layer name,\nthen the layer is plotted. `layer` takes precedence over `use_raw`.",
                "optional_value": false
            },
            "swap_axes": {
                "type": "Optional[bool]",
                "default": "False",
                "optional": true,
                "description": "By default, the x axis contains `var_names` (e.g. genes) and the y axis\nthe `groupby` categories. By setting `swap_axes` then x are the `groupby` categories and y the `var_names`.",
                "optional_value": false
            },
            "dot_color_df": {
                "type": "Optional[pd.DataFrame]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Whether to display the figure or return axis.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[str, bool]]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.",
                "optional_value": false
            },
            "ax": {
                "type": "Optional[_AxesSubplot]",
                "default": "None",
                "optional": true,
                "description": "A matplotlib axes object. Only works if plotting a single component.\nvmin: The value representing the lower limit of the color scale. Values smaller than vmin are plotted with the same color as vmin.",
                "optional_value": true
            },
            "return_fig": {
                "type": "Optional[bool]",
                "default": "False",
                "optional": true,
                "description": "Returns :class:`DotPlot` object. Useful for fine-tuning the plot. Takes precedence over `show=False`.",
                "optional_value": false
            },
            "vmin": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "vmax": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "The value representing the upper limit of the color scale. Values larger than vmax are plotted with the same color as vmax.",
                "optional_value": false
            },
            "vcenter": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "The value representing the center of the color scale. Useful for diverging colormaps.",
                "optional_value": false
            },
            "norm": {
                "type": "Optional[Normalize]",
                "default": "None",
                "optional": true,
                "description": "Custom color normalization object from matplotlib. See `https://matplotlib.org/stable/tutorials/colors/colormapnorms.html` for details.",
                "optional_value": true
            }
        },
        "Returns": {
            "type": "Optional[Union[DotPlot, dict]]",
            "description": ""
        },
        "Docstring": "Makes a *dot plot* of the count values of `var_names`.\n\nFor each var_name and each `groupby` category a dot is plotted.\nEach dot represents two values: mean expression within each category\n(visualized by color) and fraction of observations expressing the `var_name` in the\ncategory (visualized by the size of the dot). If `groupby` is not given,\nthe dotplot assumes that all data belongs to a single category.\n\n.. note::\n   A count is used if it is above the specified threshold which is zero by default.\n\nArgs:\n    adata: Annotated data matrix.\n    var_names: `var_names` should be a valid subset of `adata.var_names`.\n               If `var_names` is a mapping, then the key is used as label\n               to group the values (see `var_group_labels`). The mapping values\n               should be sequences of valid `adata.var_names`. In this\n               case either coloring or 'brackets' are used for the grouping\n               of var names depending on the plot. When `var_names` is a mapping,\n               then the `var_group_labels` and `var_group_positions` are set.\n    groupby: The key of the observation grouping to consider.\n    use_raw: Use `raw` attribute of `adata` if present.\n    log: Plot on logarithmic axis.\n    num_categories: Only used if groupby observation is not categorical. This value\n                    determines the number of groups into which the groupby observation should be subdivided.\n    categories_order: Order in which to show the categories. Note: add_dendrogram or add_totals\n                      can change the categories order.\n    figsize: Figure size when `multi_panel=True`. Otherwise the `rcParam['figure.figsize]` value is used.\n             Format is (width, height)\n    dendrogram: If True or a valid dendrogram key, a dendrogram based on the hierarchical\n                clustering between the `groupby` categories is added.\n                The dendrogram information is computed using :func:`scanpy.tl.dendrogram`.\n                If `tl.dendrogram` has not been called previously the function is called with default parameters.\n    feature_symbols: Column name in `.var` DataFrame that stores feature symbols.\n                     By default `var_names` refer to the index column of the `.var` DataFrame.\n                     Setting this option allows alternative names to be used.\n    var_group_positions: Use this parameter to highlight groups of `var_names`.\n                         This will draw a 'bracket' or a color block between the given start and end\n                         positions. If the parameter `var_group_labels` is set, the corresponding\n                         labels are added on top/left. E.g. `var_group_positions=[(4,10)]`\n                         will add a bracket between the fourth `var_name` and the tenth `var_name`.\n                         By giving more positions, more brackets/color blocks are drawn.\n    var_group_labels: Labels for each of the `var_group_positions` that want to be highlighted.\n    var_group_rotation: Label rotation degrees. By default, labels larger than 4 characters are rotated 90 degrees.\n    layer: Name of the AnnData object layer that wants to be plotted. By default adata.raw.X is plotted.\n           If `use_raw=False` is set, then `adata.X` is plotted. If `layer` is set to a valid layer name,\n           then the layer is plotted. `layer` takes precedence over `use_raw`.\n    title: Title for the figure\n    colorbar_title: Title for the color bar. New line character (\\n) can be used.\n    cmap: String denoting matplotlib color map.\n    standard_scale: Whether or not to standardize the given dimension between 0 and 1, meaning for\n                    each variable or group, subtract the minimum and divide each by its maximum.\n    swap_axes: By default, the x axis contains `var_names` (e.g. genes) and the y axis\n         the `groupby` categories. By setting `swap_axes` then x are the `groupby` categories and y the `var_names`.\n    return_fig: Returns :class:`DotPlot` object. Useful for fine-tuning the plot. Takes precedence over `show=False`.\n    size_title: Title for the size legend. New line character (\\n) can be used.\n    feature_cutoff: Count cutoff that is used for binarizing the counts and\n                    determining the fraction of patients having the feature.\n                    A feature is only used if its counts are greater than this threshold.\n    mean_only_counts: If True, counts are averaged only over the patients having the provided feature.\n    dot_max: If none, the maximum dot size is set to the maximum fraction value found\n             (e.g. 0.6). If given, the value should be a number between 0 and 1.\n             All fractions larger than dot_max are clipped to this value.\n    dot_min: If none, the minimum dot size is set to 0. If given,\n             the value should be a number between 0 and 1.\n             All fractions smaller than dot_min are clipped to this value.\n    smallest_dot: If none, the smallest dot has size 0. All counts with `dot_min` are plotted with this size.\n    show: Whether to display the figure or return axis.\n    save: If `True` or a `str`, save the figure.\n          A string is appended to the default filename.\n          Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\n    ax: A matplotlib axes object. Only works if plotting a single component.\n            vmin: The value representing the lower limit of the color scale. Values smaller than vmin are plotted with the same color as vmin.\n    vmax: The value representing the upper limit of the color scale. Values larger than vmax are plotted with the same color as vmax.\n    vcenter: The value representing the center of the color scale. Useful for diverging colormaps.\n    norm: Custom color normalization object from matplotlib. See `https://matplotlib.org/stable/tutorials/colors/colormapnorms.html` for details.\n    kwds:\n        Are passed to :func:`matplotlib.pyplot.scatter`.\n\nReturns:\n    If `return_fig` is `True`, returns a :class:`~scanpy.pl.DotPlot` object, else if `show` is false, return axes dict\n\nExample:\n    .. code-block:: python\n\n        import ehrapy as ep\n\n        adata = ep.dt.mimic_2(encoded=True)\n        ep.pp.knn_impute(adata)\n        ep.pp.neighbors(adata)\n        ep.tl.leiden(adata, resolution=0.5, key_added=\"leiden_0_5\")\n        ep.pl.dotplot(\n            adata,\n            var_names=[\n                \"age\",\n                \"gender_num\",\n                \"weight_first\",\n                \"bmi\",\n                \"wbc_first\",\n                \"hgb_first\",\n                \"platelet_first\",\n                \"sodium_first\",\n                \"potassium_first\",\n                \"tco2_first\",\n                \"chloride_first\",\n                \"bun_first\",\n                \"creatinine_first\",\n                \"po2_first\",\n                \"pco2_first\",\n            ],\n            groupby=\"leiden_0_5\",\n        )\n\nPreview:\n    .. image:: /_static/docstring_previews/dotplot.png",
        "description": "Makes a *dot plot* of the count values of `var_names`.For each var_name and each `groupby` category a dot is plotted.\nEach dot represents two values: mean expression within each category\n(visualized by color) and fraction of observations expressing the `var_name` in the\ncategory (visualized by the size of the dot). If `groupby` is not given,\nthe dotplot assumes that all data belongs to a single category.\n\n.. note::\n   A count is used if it is above the specified threshold which is zero by default.",
        "example": ".. code-block:: python\n\n        import ehrapy as ep\n\n        adata = ep.dt.mimic_2(encoded=True)\n        ep.pp.knn_impute(adata)\n        ep.pp.neighbors(adata)\n        ep.tl.leiden(adata, resolution=0.5, key_added=\"leiden_0_5\")\n        ep.pl.dotplot(\n            adata,\n            var_names=[\n                \"age\",\n                \"gender_num\",\n                \"weight_first\",\n                \"bmi\",\n                \"wbc_first\",\n                \"hgb_first\",\n                \"platelet_first\",\n                \"sodium_first\",\n                \"potassium_first\",\n                \"tco2_first\",\n                \"chloride_first\",\n                \"bun_first\",\n                \"creatinine_first\",\n                \"po2_first\",\n                \"pco2_first\",\n            ],\n            groupby=\"leiden_0_5\",\n        )\n\nPreview:\n    .. image:: /_static/docstring_previews/dotplot.png",
        "api_type": "function",
        "api_calling": [
            "ehrapy.plot.dotplot(adata=$, var_names=@, groupby=@, use_raw=@, log=@, num_categories=@, feature_cutoff=@, mean_only_counts=@, cmap=@, dot_max=@, dot_min=@, standard_scale=$, smallest_dot=@, title=@, colorbar_title=@, size_title=@, figsize=@, dendrogram=@, feature_symbols=@, var_group_positions=@, var_group_labels=@, var_group_rotation=@, layer=@, swap_axes=@, dot_color_df=$, show=@, save=@, ax=$, return_fig=@, vmin=@, vmax=@, vcenter=@, norm=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.preprocessing.minmax_norm": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object containing X to normalize values in.\nMust already be encoded using :func:`~ehrapy.preprocessing.encode`.",
                "optional_value": true
            },
            "vars": {
                "type": "Optional[Union[str, Sequence[str]]]",
                "default": "None",
                "optional": true,
                "description": "List of the names of the numeric variables to normalize.\nIf None all numeric variables will be normalized. Defaults to False .",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to return a copy or act in place. Defaults to False .",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[AnnData]",
            "description": ""
        },
        "Docstring": "Apply min-max normalization.\n\nFunctionality is provided by :func:`~sklearn.preprocessing.minmax_scale`,\nsee https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.minmax_scale.html for details.\n\nArgs:\n    adata: :class:`~anndata.AnnData` object containing X to normalize values in.\n           Must already be encoded using :func:`~ehrapy.preprocessing.encode`.\n    vars: List of the names of the numeric variables to normalize.\n          If None all numeric variables will be normalized. Defaults to False .\n    copy: Whether to return a copy or act in place. Defaults to False .\n    **kwargs: Additional arguments passed to :func:`~sklearn.preprocessing.minmax_scale`\n\nReturns:\n    :class:`~anndata.AnnData` object with normalized X.\n    Also stores a record of applied normalizations as a dictionary in adata.uns[\"normalization\"].\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> adata_norm = ep.pp.minmax_norm(adata, copy=True)",
        "description": "Apply min-max normalization.Functionality is provided by :func:`~sklearn.preprocessing.minmax_scale`,\nsee https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.minmax_scale.html for details.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> adata_norm = ep.pp.minmax_norm(adata, copy=True)",
        "api_type": "function",
        "api_calling": [
            "ehrapy.preprocessing.minmax_norm(adata=$, vars=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.data.dermatology": {
        "Parameters": {
            "encoded": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to return an already encoded object",
                "optional_value": false
            },
            "columns_obs_only": {
                "type": "Optional[Union[dict[str, list[str]], list[str]]]",
                "default": "None",
                "optional": true,
                "description": "Columns to include in obs only and not X.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": ""
        },
        "Docstring": "Loads the Dermatology Data Set\n\nMore details: http://archive.ics.uci.edu/ml/datasets/Dermatology\nPreprocessing: https://github.com/theislab/ehrapy-datasets/blob/main/dermatology/dermatology.ipynb\n\nArgs:\n    encoded: Whether to return an already encoded object\n    columns_obs_only: Columns to include in obs only and not X.\n\nReturns:\n    :class:`~anndata.AnnData` object of the Dermatology Data Set\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.dermatology(encoded=True)",
        "description": "Loads the Dermatology Data SetMore details: http://archive.ics.uci.edu/ml/datasets/Dermatology\nPreprocessing: https://github.com/theislab/ehrapy-datasets/blob/main/dermatology/dermatology.ipynb",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.dermatology(encoded=True)",
        "api_type": "function",
        "api_calling": [
            "ehrapy.data.dermatology(encoded=@, columns_obs_only=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.preprocessing.simple_impute": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "The annotated data matrix to impute missing values on.",
                "optional_value": true
            },
            "var_names": {
                "type": "Optional[Iterable[str]]",
                "default": "None",
                "optional": true,
                "description": "A list of column names to apply imputation on (if None, impute all columns).",
                "optional_value": false
            },
            "strategy": {
                "type": "Literal['mean', 'median', 'most_frequent']",
                "default": "mean",
                "optional": true,
                "description": "Imputation strategy to use. One of {'mean', 'median', 'most_frequent'}.",
                "optional_value": true
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to return a copy of `adata` or modify it inplace. Defaults to False.",
                "optional_value": false
            },
            "warning_threshold": {
                "type": "int",
                "default": "70",
                "optional": true,
                "description": "Display a warning message if percentage of missing values exceeds this threshold. Defaults to 30.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": ""
        },
        "Docstring": "Impute missing values in numerical data using mean/median/most frequent imputation.\n\nArgs:\n    adata: The annotated data matrix to impute missing values on.\n    var_names: A list of column names to apply imputation on (if None, impute all columns).\n    strategy: Imputation strategy to use. One of {'mean', 'median', 'most_frequent'}.\n    warning_threshold: Display a warning message if percentage of missing values exceeds this threshold. Defaults to 30.\n    copy:Whether to return a copy of `adata` or modify it inplace. Defaults to False.\n\nReturns:\n    An updated AnnData object with imputed values.\n\nRaises:\n    ValueError:\n        If the selected imputation strategy is not applicable to the data.\n    ValueError:\n        If an unknown imputation strategy is provided.\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.simple_impute(adata, strategy=\"median\")",
        "description": "Impute missing values in numerical data using mean/median/most frequent imputation.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.simple_impute(adata, strategy=\"median\")",
        "api_type": "function",
        "api_calling": [
            "ehrapy.preprocessing.simple_impute(adata=$, var_names=@, strategy=$, copy=@, warning_threshold=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.plot.scatter": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object object containing all observations.",
                "optional_value": true
            },
            "x": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "x coordinate (MedCat entities currently not supported)",
                "optional_value": false
            },
            "y": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "y coordinate (MedCat entities currently not supported)",
                "optional_value": false
            },
            "color": {
                "type": "str",
                "default": "None",
                "optional": true,
                "description": "Keys for annotations of observations/patients or features, or a hex color specification, e.g.,\n`'ann1'`, `'#fe57a1'`, or `['ann1', 'ann2']` or extracted entities from ehrapy's MedCat tool.",
                "optional_value": false
            },
            "use_raw": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Whether to use `raw` attribute of `adata`. Defaults to `True` if `.raw` is present.",
                "optional_value": false
            },
            "layers": {
                "type": "Union[str, Collection[str]]",
                "default": "None",
                "optional": true,
                "description": "Use the `layers` attribute of `adata` if present: specify the layer for `x`, `y` and `color`.\nIf `layers` is a string, then it is expanded to `(layers, layers, layers)`.",
                "optional_value": false
            },
            "sort_order": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "For continuous annotations used as color parameter, plot data points with higher values on top of others.",
                "optional_value": false
            },
            "alpha": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "basis": {
                "type": "Optional[_Basis]",
                "default": "None",
                "optional": true,
                "description": "String that denotes a plotting tool that computed coordinates.",
                "optional_value": true
            },
            "groups": {
                "type": "Union[str, Iterable[str]]",
                "default": "None",
                "optional": true,
                "description": "Restrict to a few categories in categorical observation annotation.\nThe default is not to restrict to any groups.",
                "optional_value": false
            },
            "components": {
                "type": "Union[str, Collection[str]]",
                "default": "None",
                "optional": true,
                "description": "For instance, `['1,2', '2,3']`. To plot all available components use `components='all'`.",
                "optional_value": false
            },
            "projection": {
                "type": "Literal['2d', '3d']",
                "default": "2d",
                "optional": true,
                "description": "Projection of plot (default: `'2d'`).",
                "optional_value": true
            },
            "legend_loc": {
                "type": "str",
                "default": "right margin",
                "optional": true,
                "description": "Location of legend, either `'on data'`, `'right margin'` or a valid keyword for the `loc` parameter of :class:`~matplotlib.legend.Legend`.",
                "optional_value": false
            },
            "legend_fontsize": {
                "type": "Optional[Union[int, float, _FontSize]]",
                "default": "None",
                "optional": true,
                "description": "Numeric size in pt or string describing the size. See :meth:`~matplotlib.text.Text.set_fontsize`.",
                "optional_value": false
            },
            "legend_fontweight": {
                "type": "Optional[Union[int, _FontWeight]]",
                "default": "None",
                "optional": true,
                "description": "Legend font weight. A numeric value in range 0-1000 or a string.\nDefaults to `'bold'` if `legend_loc == 'on data'`, otherwise to `'normal'`.\nSee :meth:`~matplotlib.text.Text.set_fontweight`.",
                "optional_value": false
            },
            "legend_fontoutline": {
                "type": "float",
                "default": "None",
                "optional": true,
                "description": "Line width of the legend font outline in pt. Draws a white outline using the path effect :class:`~matplotlib.patheffects.withStroke`.",
                "optional_value": false
            },
            "color_map": {
                "type": "Union[str, Colormap]",
                "default": "None",
                "optional": true,
                "description": "Color map to use for continous variables. Can be a name or a\n:class:`~matplotlib.colors.Colormap` instance (e.g. `\"magma`\", `\"viridis\"`\nor `mpl.cm.cividis`), see :func:`~matplotlib.cm.get_cmap`.\nIf `None`, the value of `mpl.rcParams[\"image.cmap\"]` is used.\nThe default `color_map` can be set using :func:`~scanpy.set_figure_params`.",
                "optional_value": false
            },
            "palette": {
                "type": "Union[Cycler, ListedColormap, ColorLike, Sequence[ColorLike]]",
                "default": "None",
                "optional": true,
                "description": "Colors to use for plotting categorical annotation groups.\nThe palette can be a valid :class:`~matplotlib.colors.ListedColormap` name\n(`'Set2'`, `'tab20'`, \u2026), a :class:`~cycler.Cycler` object, a dict mapping\ncategories to colors, or a sequence of colors. Colors must be valid to\nmatplotlib. (see :func:`~matplotlib.colors.is_color_like`).\nIf `None`, `mpl.rcParams[\"axes.prop_cycle\"]` is used unless the categorical\nvariable already has colors stored in `adata.uns[\"{var}_colors\"]`.\nIf provided, values of `adata.uns[\"{var}_colors\"]` will be set.",
                "optional_value": false
            },
            "frameon": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Draw a frame around the scatter plot. Defaults to value set in :func:`~scanpy.set_figure_params` (default: True).",
                "optional_value": false
            },
            "right_margin": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "left_margin": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "size": {
                "type": "Optional[Union[int, float]]",
                "default": "None",
                "optional": true,
                "description": "Point size. If `None`, is automatically computed as 120000 / n_features.\nCan be a sequence containing the size for each observation. The order should be the same as in adata.obs.",
                "optional_value": false
            },
            "title": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Provide title for panels either as string or list of strings, e.g. `['title1', 'title2', ...]`.",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Whether to display the figure or return axis.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[str, bool]]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.",
                "optional_value": false
            },
            "ax": {
                "type": "Optional[Axes]",
                "default": "None",
                "optional": true,
                "description": "A matplotlib axes object. Only works if plotting a single component.",
                "optional_value": true
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Scatter plot along observations or variables axes.\n\nColor the plot using annotations of observations (`.obs`), variables (`.var`) or features (`.var_names`).\n\nArgs:\n    adata: :class:`~anndata.AnnData` object object containing all observations.\n    x: x coordinate (MedCat entities currently not supported)\n    y: y coordinate (MedCat entities currently not supported)\n    color: Keys for annotations of observations/patients or features, or a hex color specification, e.g.,\n           `'ann1'`, `'#fe57a1'`, or `['ann1', 'ann2']` or extracted entities from ehrapy's MedCat tool.\n    use_raw: Whether to use `raw` attribute of `adata`. Defaults to `True` if `.raw` is present.\n    layers: Use the `layers` attribute of `adata` if present: specify the layer for `x`, `y` and `color`.\n            If `layers` is a string, then it is expanded to `(layers, layers, layers)`.\n    basis: String that denotes a plotting tool that computed coordinates.\n    sort_order: For continuous annotations used as color parameter, plot data points with higher values on top of others.\n    groups: Restrict to a few categories in categorical observation annotation.\n            The default is not to restrict to any groups.\n    components: For instance, `['1,2', '2,3']`. To plot all available components use `components='all'`.\n    projection: Projection of plot (default: `'2d'`).\n    legend_loc: Location of legend, either `'on data'`, `'right margin'` or a valid keyword for the `loc` parameter of :class:`~matplotlib.legend.Legend`.\n    legend_fontsize: Numeric size in pt or string describing the size. See :meth:`~matplotlib.text.Text.set_fontsize`.\n    legend_fontweight: Legend font weight. A numeric value in range 0-1000 or a string.\n                       Defaults to `'bold'` if `legend_loc == 'on data'`, otherwise to `'normal'`.\n                       See :meth:`~matplotlib.text.Text.set_fontweight`.\n    legend_fontoutline: Line width of the legend font outline in pt. Draws a white outline using the path effect :class:`~matplotlib.patheffects.withStroke`.\n    size: Point size. If `None`, is automatically computed as 120000 / n_features.\n          Can be a sequence containing the size for each observation. The order should be the same as in adata.obs.\n    color_map: Color map to use for continous variables. Can be a name or a\n               :class:`~matplotlib.colors.Colormap` instance (e.g. `\"magma`\", `\"viridis\"`\n               or `mpl.cm.cividis`), see :func:`~matplotlib.cm.get_cmap`.\n               If `None`, the value of `mpl.rcParams[\"image.cmap\"]` is used.\n               The default `color_map` can be set using :func:`~scanpy.set_figure_params`.\n    palette: Colors to use for plotting categorical annotation groups.\n             The palette can be a valid :class:`~matplotlib.colors.ListedColormap` name\n             (`'Set2'`, `'tab20'`, \u2026), a :class:`~cycler.Cycler` object, a dict mapping\n             categories to colors, or a sequence of colors. Colors must be valid to\n             matplotlib. (see :func:`~matplotlib.colors.is_color_like`).\n             If `None`, `mpl.rcParams[\"axes.prop_cycle\"]` is used unless the categorical\n             variable already has colors stored in `adata.uns[\"{var}_colors\"]`.\n             If provided, values of `adata.uns[\"{var}_colors\"]` will be set.\n    na_color: Color to use for null or masked values. Can be anything matplotlib accepts as a color.\n              Used for all points if `color=None`.\n    na_in_legend: If there are missing values, whether they get an entry in the legend.\n                  Currently only implemented for categorical legends.\n    frameon: Draw a frame around the scatter plot. Defaults to value set in :func:`~scanpy.set_figure_params` (default: True).\n    title: Provide title for panels either as string or list of strings, e.g. `['title1', 'title2', ...]`.\n    show: Whether to display the figure or return axis.\n    save: If `True` or a `str`, save the figure.\n          A string is appended to the default filename.\n          Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\n    ax: A matplotlib axes object. Only works if plotting a single component.\n\nReturns:\n    If `show==False` a :class:`~matplotlib.axes.Axes` or a list of it.\n\nExample:\n    .. code-block:: python\n\n        import ehrapy as ep\n\n        adata = ep.dt.mimic_2(encoded=True)\n        ep.pp.knn_impute(adata)\n        ep.pp.log_norm(adata, offset=1)\n        ep.pp.neighbors(adata)\n        ep.pl.scatter(adata, x=\"age\", y=\"icu_los_day\", color=\"icu_los_day\")\n\nPreview:\n    .. image:: /_static/docstring_previews/scatter.png",
        "description": "Scatter plot along observations or variables axes.Color the plot using annotations of observations (`.obs`), variables (`.var`) or features (`.var_names`).",
        "example": ".. code-block:: python\n\n        import ehrapy as ep\n\n        adata = ep.dt.mimic_2(encoded=True)\n        ep.pp.knn_impute(adata)\n        ep.pp.log_norm(adata, offset=1)\n        ep.pp.neighbors(adata)\n        ep.pl.scatter(adata, x=\"age\", y=\"icu_los_day\", color=\"icu_los_day\")\n\nPreview:\n    .. image:: /_static/docstring_previews/scatter.png",
        "api_type": "function",
        "api_calling": [
            "ehrapy.plot.scatter(adata=$, x=@, y=@, color=@, use_raw=@, layers=@, sort_order=@, alpha=@, basis=$, groups=@, components=@, projection=$, legend_loc=@, legend_fontsize=@, legend_fontweight=@, legend_fontoutline=@, color_map=@, palette=@, frameon=@, right_margin=@, left_margin=@, size=@, title=@, show=@, save=@, ax=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.anndata.move_to_x": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "The AnnData object",
                "optional_value": true
            },
            "to_x": {
                "type": "Union[list[str], str]",
                "default": null,
                "optional": false,
                "description": "The columns to move to X",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": ""
        },
        "Docstring": "Move features from obs to X inplace.\n\nArgs:\n    adata: The AnnData object\n    to_x: The columns to move to X\n    copy: Whether to return a copy or not\n\nReturns:\n    A new AnnData object with moved columns from obs to X. This should not be used for datetime columns currently.\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.ad.move_to_obs(adata, ['age'], copy_obs=False)\n    >>> new_adata = ep.ad.move_to_x(adata, ['age'])",
        "description": "Move features from obs to X inplace.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.ad.move_to_obs(adata, ['age'], copy_obs=False)\n    >>> new_adata = ep.ad.move_to_x(adata, ['age'])",
        "api_type": "function",
        "api_calling": [
            "ehrapy.anndata.move_to_x(adata=$, to_x=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.preprocessing.qc_lab_measurements": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "reference_table": {
                "type": "pd.DataFrame",
                "default": "None",
                "optional": true,
                "description": "A custom DataFrame with reference values. Defaults to the laposata table if not specified.",
                "optional_value": true
            },
            "measurements": {
                "type": "list[str]",
                "default": "None",
                "optional": true,
                "description": "A list of measurements to check.",
                "optional_value": false
            },
            "unit": {
                "type": "Literal['traditional', 'SI']",
                "default": "None",
                "optional": true,
                "description": "The unit of the measurements. Defaults to 'traditional'.",
                "optional_value": true
            },
            "layer": {
                "type": "str",
                "default": "None",
                "optional": true,
                "description": "Layer containing the matrix to calculate the metrics for.",
                "optional_value": false
            },
            "threshold": {
                "type": "int",
                "default": "20",
                "optional": true,
                "description": "Minimum required matching confidence score of the fuzzysearch.\n0 = no matches, 100 = all must match. Defaults to 20.",
                "optional_value": false
            },
            "age_col": {
                "type": "str",
                "default": "None",
                "optional": true,
                "description": "Column containing age values.",
                "optional_value": false
            },
            "age_range": {
                "type": "str",
                "default": "None",
                "optional": true,
                "description": "The inclusive age-range to filter for such as 5-99.",
                "optional_value": false
            },
            "sex_col": {
                "type": "str",
                "default": "None",
                "optional": true,
                "description": "Column containing sex values. Column must contain 'U', 'M' or 'F'.",
                "optional_value": false
            },
            "sex": {
                "type": "str",
                "default": "None",
                "optional": true,
                "description": "Sex to filter the reference values for. Use U for unisex which uses male values when male and female conflict.\nDefaults to 'U|M'.",
                "optional_value": false
            },
            "ethnicity_col": {
                "type": "str",
                "default": "None",
                "optional": true,
                "description": "Column containing ethnicity values.",
                "optional_value": false
            },
            "ethnicity": {
                "type": "str",
                "default": "None",
                "optional": true,
                "description": "Ethnicity to filter for.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to return a copy. Defaults to False.",
                "optional_value": false
            },
            "verbose": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to have verbose stdout. Notifies user of matched columns and value ranges.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": ""
        },
        "Docstring": "Examines lab measurements for reference ranges and outliers.\n\nSource:\n    The used reference values were obtained from https://accessmedicine.mhmedical.com/content.aspx?bookid=1069&sectionid=60775149 .\n    This table is compiled from data in the following sources:\n\n    * Tietz NW, ed. Clinical Guide to Laboratory Tests. 3rd ed. Philadelphia: WB Saunders Co; 1995;\n    * Laposata M. SI Unit Conversion Guide. Boston: NEJM Books; 1992;\n    * American Medical Association Manual of Style: A Guide for Authors and Editors. 9th ed. Chicago: AMA; 1998:486\u2013503. Copyright 1998, American Medical Association;\n    * Jacobs DS, DeMott WR, Oxley DK, eds. Jacobs & DeMott Laboratory Test Handbook With Key Word Index. 5th ed. Hudson, OH: Lexi-Comp Inc; 2001;\n    * Henry JB, ed. Clinical Diagnosis and Management by Laboratory Methods. 20th ed. Philadelphia: WB Saunders Co; 2001;\n    * Kratz A, et al. Laboratory reference values. N Engl J Med. 2006;351:1548\u20131563; 7) Burtis CA, ed. Tietz Textbook of Clinical Chemistry and Molecular Diagnostics. 5th ed. St. Louis: Elsevier; 2012.\n\n    This version of the table of reference ranges was reviewed and updated by Jessica Franco-Colon, PhD, and Kay Brooks.\n\nLimitations:\n    * Reference ranges differ between continents, countries and even laboratories (https://informatics.bmj.com/content/28/1/e100419).\n      The default values used here are only one of many options.\n    * Ensure that the values used as input are provided with the correct units. We recommend the usage of SI values.\n    * The reference values pertain to adults. Many of the reference ranges need to be adapted for children.\n    * By default if no gender is provided and no unisex values are available, we use the **male** reference ranges.\n    * The used reference ranges may be biased for ethnicity. Please examine the primary sources if required.\n    * We recommend a glance at https://www.nature.com/articles/s41591-021-01468-6 for the effect of such covariates.\n\nAdditional values:\n    * Interleukin-6 based on https://pubmed.ncbi.nlm.nih.gov/33155686/\n\nIf you want to specify your own table as a Pandas DataFrame please examine the existing default table.\nEthnicity and age columns can be added.\nhttps://github.com/theislab/ehrapy/blob/main/ehrapy/preprocessing/laboratory_reference_tables/laposata.tsv\n\nArgs:\n    adata: Annotated data matrix.\n    reference_table: A custom DataFrame with reference values. Defaults to the laposata table if not specified.\n    measurements: A list of measurements to check.\n    unit: The unit of the measurements. Defaults to 'traditional'.\n    layer: Layer containing the matrix to calculate the metrics for.\n    threshold: Minimum required matching confidence score of the fuzzysearch.\n               0 = no matches, 100 = all must match. Defaults to 20.\n    age_col: Column containing age values.\n    age_range: The inclusive age-range to filter for such as 5-99.\n    sex_col: Column containing sex values. Column must contain 'U', 'M' or 'F'.\n    sex: Sex to filter the reference values for. Use U for unisex which uses male values when male and female conflict.\n         Defaults to 'U|M'.\n    ethnicity_col: Column containing ethnicity values.\n    ethnicity: Ethnicity to filter for.\n    copy: Whether to return a copy. Defaults to False.\n    verbose: Whether to have verbose stdout. Notifies user of matched columns and value ranges.\n\nReturns:\n    A modified AnnData object (copy if specified).\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.qc_lab_measurements(adata, measurements=[\"potassium_first\"], verbose=True)",
        "description": "Examines lab measurements for reference ranges and outliers.Source:\n    The used reference values were obtained from https://accessmedicine.mhmedical.com/content.aspx?bookid=1069&sectionid=60775149 .\n    This table is compiled from data in the following sources:\n\n    * Tietz NW, ed. Clinical Guide to Laboratory Tests. 3rd ed. Philadelphia: WB Saunders Co; 1995;\n    * Laposata M. SI Unit Conversion Guide. Boston: NEJM Books; 1992;\n    * American Medical Association Manual of Style: A Guide for Authors and Editors. 9th ed. Chicago: AMA; 1998:486\u2013503. Copyright 1998, American Medical Association;\n    * Jacobs DS, DeMott WR, Oxley DK, eds. Jacobs & DeMott Laboratory Test Handbook With Key Word Index. 5th ed. Hudson, OH: Lexi-Comp Inc; 2001;\n    * Henry JB, ed. Clinical Diagnosis and Management by Laboratory Methods. 20th ed. Philadelphia: WB Saunders Co; 2001;\n    * Kratz A, et al. Laboratory reference values. N Engl J Med. 2006;351:1548\u20131563; 7) Burtis CA, ed. Tietz Textbook of Clinical Chemistry and Molecular Diagnostics. 5th ed. St. Louis: Elsevier; 2012.\n\n    This version of the table of reference ranges was reviewed and updated by Jessica Franco-Colon, PhD, and Kay Brooks.\n\nLimitations:\n    * Reference ranges differ between continents, countries and even laboratories (https://informatics.bmj.com/content/28/1/e100419).\n      The default values used here are only one of many options.\n    * Ensure that the values used as input are provided with the correct units. We recommend the usage of SI values.\n    * The reference values pertain to adults. Many of the reference ranges need to be adapted for children.\n    * By default if no gender is provided and no unisex values are available, we use the **male** reference ranges.\n    * The used reference ranges may be biased for ethnicity. Please examine the primary sources if required.\n    * We recommend a glance at https://www.nature.com/articles/s41591-021-01468-6 for the effect of such covariates.\n\nAdditional values:\n    * Interleukin-6 based on https://pubmed.ncbi.nlm.nih.gov/33155686/\n\nIf you want to specify your own table as a Pandas DataFrame please examine the existing default table.\nEthnicity and age columns can be added.\nhttps://github.com/theislab/ehrapy/blob/main/ehrapy/preprocessing/laboratory_reference_tables/laposata.tsv",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.qc_lab_measurements(adata, measurements=[\"potassium_first\"], verbose=True)",
        "api_type": "function",
        "api_calling": [
            "ehrapy.preprocessing.qc_lab_measurements(adata=$, reference_table=$, measurements=@, unit=$, layer=@, threshold=@, age_col=@, age_range=@, sex_col=@, sex=@, ethnicity_col=@, ethnicity=@, copy=@, verbose=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.tl.rank_features_groups": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "groupby": {
                "type": "str",
                "default": null,
                "optional": false,
                "description": "The key of the observations grouping to consider.",
                "optional_value": false
            },
            "groups": {
                "type": "Union[Literal['all'], Iterable[str]]",
                "default": "all",
                "optional": true,
                "description": "Subset of groups, e.g. [`'g1'`, `'g2'`, `'g3'`], to which comparison\nshall be restricted, or `'all'` (default), for all groups.",
                "optional_value": false
            },
            "reference": {
                "type": "str",
                "default": "rest",
                "optional": true,
                "description": "If `'rest'`, compare each group to the union of the rest of the group.\nIf a group identifier, compare with respect to this group.",
                "optional_value": false
            },
            "n_features": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "The number of features that appear in the returned tables. Defaults to all features.",
                "optional_value": false
            },
            "rankby_abs": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Rank genes by the absolute value of the score, not by the score.\nThe returned scores are never the absolute values.",
                "optional_value": false
            },
            "pts": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Compute the fraction of observations containing the features.",
                "optional_value": false
            },
            "key_added": {
                "type": "Optional[str]",
                "default": "rank_features_groups",
                "optional": true,
                "description": "The key in `adata.uns` information is saved to.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to return a copy of the AnnData object.",
                "optional_value": false
            },
            "num_cols_method": {
                "type": "_method_options._rank_features_groups_method",
                "default": "None",
                "optional": true,
                "description": "Statistical method to rank numerical features. The default method is `'t-test'`,\n`'t-test_overestim_var'` overestimates variance of each group,\n`'wilcoxon'` uses Wilcoxon rank-sum,\n`'logreg'` uses logistic regression.",
                "optional_value": true
            },
            "cat_cols_method": {
                "type": "_method_options._rank_features_groups_cat_method",
                "default": "g-test",
                "optional": true,
                "description": "Statistical method to calculate differences between categorical features. The default method is `'g-test'`,\n`'Chi-square'` tests goodness-of-fit test for categorical data,\n`'Freeman-Tukey'` tests comparing frequency distributions,\n`'Mod-log-likelihood'` maximum likelihood estimation,\n`'Neyman'` tests hypotheses using asymptotic theory,\n`'Cressie-Read'` is a generalized likelihood test,",
                "optional_value": true
            },
            "correction_method": {
                "type": "_method_options._correction_method",
                "default": "benjamini-hochberg",
                "optional": true,
                "description": "p-value correction method.\nUsed only for statistical tests (e.g. doesn't work for \"logreg\" `num_cols_method`)",
                "optional_value": true
            },
            "tie_correct": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Use tie correction for `'wilcoxon'` scores. Used only for `'wilcoxon'`.",
                "optional_value": false
            },
            "layer": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Key from `adata.layers` whose value will be used to perform tests on.",
                "optional_value": false
            },
            "field_to_rank": {
                "type": "Union[Literal['layer'], Literal['obs'], Literal['layer_and_obs']]",
                "default": "layer",
                "optional": true,
                "description": "Set to `layer` to rank variables in `adata.X` or `adata.layers[layer]` (default), `obs` to rank `adata.obs`, or `layer_and_obs` to rank both.\nLayer needs to be None if this is not 'layer'.",
                "optional_value": true
            },
            "columns_to_rank": {
                "type": "Union[dict[str, Iterable[str]], Literal['all']]",
                "default": "all",
                "optional": true,
                "description": "Subset of columns to rank. If 'all', all columns are used.\nIf a dictionary, it must have keys 'var_names' and/or 'obs_names' and values must be iterables of strings\nsuch as {'var_names': ['glucose'], 'obs_names': ['age', 'height']}.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Rank features for characterizing groups.\n\nExpects logarithmized data.\n\nArgs:\n    adata: Annotated data matrix.\n    groupby: The key of the observations grouping to consider.\n    groups: Subset of groups, e.g. [`'g1'`, `'g2'`, `'g3'`], to which comparison\n            shall be restricted, or `'all'` (default), for all groups.\n    reference: If `'rest'`, compare each group to the union of the rest of the group.\n               If a group identifier, compare with respect to this group.\n    n_features: The number of features that appear in the returned tables. Defaults to all features.\n    rankby_abs: Rank genes by the absolute value of the score, not by the score.\n                The returned scores are never the absolute values.\n    pts: Compute the fraction of observations containing the features.\n    key_added: The key in `adata.uns` information is saved to.\n    copy: Whether to return a copy of the AnnData object.\n    num_cols_method:  Statistical method to rank numerical features. The default method is `'t-test'`,\n                      `'t-test_overestim_var'` overestimates variance of each group,\n                      `'wilcoxon'` uses Wilcoxon rank-sum,\n                      `'logreg'` uses logistic regression.\n    cat_cols_method: Statistical method to calculate differences between categorical features. The default method is `'g-test'`,\n                         `'Chi-square'` tests goodness-of-fit test for categorical data,\n                         `'Freeman-Tukey'` tests comparing frequency distributions,\n                         `'Mod-log-likelihood'` maximum likelihood estimation,\n                         `'Neyman'` tests hypotheses using asymptotic theory,\n                         `'Cressie-Read'` is a generalized likelihood test,\n    correction_method:  p-value correction method.\n                        Used only for statistical tests (e.g. doesn't work for \"logreg\" `num_cols_method`)\n    tie_correct: Use tie correction for `'wilcoxon'` scores. Used only for `'wilcoxon'`.\n    layer: Key from `adata.layers` whose value will be used to perform tests on.\n    field_to_rank: Set to `layer` to rank variables in `adata.X` or `adata.layers[layer]` (default), `obs` to rank `adata.obs`, or `layer_and_obs` to rank both.\n                   Layer needs to be None if this is not 'layer'.\n    columns_to_rank: Subset of columns to rank. If 'all', all columns are used.\n                     If a dictionary, it must have keys 'var_names' and/or 'obs_names' and values must be iterables of strings\n                     such as {'var_names': ['glucose'], 'obs_names': ['age', 'height']}.\n    **kwds: Are passed to test methods. Currently this affects only parameters that\n            are passed to :class:`sklearn.linear_model.LogisticRegression`.\n            For instance, you can pass `penalty='l1'` to try to come up with a\n            minimal set of genes that are good predictors (sparse solution meaning few non-zero fitted coefficients).\n\nReturns:\n    *names* structured `np.ndarray` (`.uns['rank_features_groups']`)\n              Structured array to be indexed by group id storing the gene\n              names. Ordered according to scores.\n    *scores* structured `np.ndarray` (`.uns['rank_features_groups']`)\n              Structured array to be indexed by group id storing the z-score\n              underlying the computation of a p-value for each gene for each group.\n              Ordered according to scores.\n    *logfoldchanges* structured `np.ndarray` (`.uns['rank_features_groups']`)\n                      Structured array to be indexed by group id storing the log2\n                      fold change for each gene for each group. Ordered according to scores.\n                      Only provided if method is 't-test' like.\n                      Note: this is an approximation calculated from mean-log values.\n    *pvals* structured `np.ndarray` (`.uns['rank_features_groups']`) p-values.\n    *pvals_adj* structured `np.ndarray` (`.uns['rank_features_groups']`) Corrected p-values.\n    *pts*: `pandas.DataFrame` (`.uns['rank_features_groups']`)\n           Fraction of cells expressing the genes for each group.\n    *pts_rest* `pandas.DataFrame` (`.uns['rank_features_groups']`)\n                Only if `reference` is set to `'rest'`.\n                Fraction of observations from the union of the rest of each group containing the features.\n\n Examples:\n     >>> import ehrapy as ep\n     >>> adata = ep.dt.mimic_2(encoded=False)\n     >>> # want to move some metadata to the obs field\n     >>> ep.anndata.move_to_obs(adata, to_obs=[\"service_unit\", \"service_num\", \"age\", \"mort_day_censored\"])\n     >>> ep.tl.rank_features_groups(adata, \"service_unit\")\n     >>> ep.pl.rank_features_groups(adata)\n\n     >>> import ehrapy as ep\n     >>> adata = ep.dt.mimic_2(encoded=False)\n     >>> # want to move some metadata to the obs field\n     >>> ep.anndata.move_to_obs(adata, to_obs=[\"service_unit\", \"service_num\", \"age\", \"mort_day_censored\"])\n     >>> ep.tl.rank_features_groups(adata, \"service_unit\", field_to_rank=\"obs\", columns_to_rank={\"obs_names\": [\"age\", \"mort_day_censored\"]})\n     >>> ep.pl.rank_features_groups(adata)\n\n     >>> import ehrapy as ep\n     >>> adata = ep.dt.mimic_2(encoded=False)\n     >>> # want to move some metadata to the obs field\n     >>> ep.anndata.move_to_obs(adata, to_obs=[\"service_unit\", \"service_num\", \"age\", \"mort_day_censored\"])\n     >>> ep.tl.rank_features_groups(adata, \"service_unit\", field_to_rank=\"layer_and_obs\", columns_to_rank={\"var_names\": ['copd_flg', 'renal_flg'], \"obs_names\": [\"age\", \"mort_day_censored\"]})\n     >>> ep.pl.rank_features_groups(adata)",
        "description": "Rank features for characterizing groups.Expects logarithmized data.",
        "example": ">>> import ehrapy as ep\n     >>> adata = ep.dt.mimic_2(encoded=False)\n     >>> # want to move some metadata to the obs field\n     >>> ep.anndata.move_to_obs(adata, to_obs=[\"service_unit\", \"service_num\", \"age\", \"mort_day_censored\"])\n     >>> ep.tl.rank_features_groups(adata, \"service_unit\")\n     >>> ep.pl.rank_features_groups(adata)\n\n     >>> import ehrapy as ep\n     >>> adata = ep.dt.mimic_2(encoded=False)\n     >>> # want to move some metadata to the obs field\n     >>> ep.anndata.move_to_obs(adata, to_obs=[\"service_unit\", \"service_num\", \"age\", \"mort_day_censored\"])\n     >>> ep.tl.rank_features_groups(adata, \"service_unit\", field_to_rank=\"obs\", columns_to_rank={\"obs_names\": [\"age\", \"mort_day_censored\"]})\n     >>> ep.pl.rank_features_groups(adata)\n\n     >>> import ehrapy as ep\n     >>> adata = ep.dt.mimic_2(encoded=False)\n     >>> # want to move some metadata to the obs field\n     >>> ep.anndata.move_to_obs(adata, to_obs=[\"service_unit\", \"service_num\", \"age\", \"mort_day_censored\"])\n     >>> ep.tl.rank_features_groups(adata, \"service_unit\", field_to_rank=\"layer_and_obs\", columns_to_rank={\"var_names\": ['copd_flg', 'renal_flg'], \"obs_names\": [\"age\", \"mort_day_censored\"]})\n     >>> ep.pl.rank_features_groups(adata)",
        "api_type": "function",
        "api_calling": [
            "ehrapy.tl.rank_features_groups(adata=$, groupby=@, groups=@, reference=@, n_features=@, rankby_abs=@, pts=@, key_added=@, copy=@, num_cols_method=$, cat_cols_method=$, correction_method=$, tie_correct=@, layer=@, field_to_rank=$, columns_to_rank=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.data.thyroid": {
        "Parameters": {
            "encoded": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to return an already encoded object.",
                "optional_value": false
            },
            "columns_obs_only": {
                "type": "Optional[Union[dict[str, list[str]], list[str]]]",
                "default": "None",
                "optional": true,
                "description": "Columns to include in obs only and not X.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": ""
        },
        "Docstring": "Loads the Thyroid Data Set\n\nMore details: http://archive.ics.uci.edu/ml/datasets/Thyroid+Disease\nPreprocessing: https://github.com/theislab/ehrapy-datasets/blob/main/thyroid/thyroid.ipynb\n\nArgs:\n    encoded: Whether to return an already encoded object.\n    columns_obs_only: Columns to include in obs only and not X.\n\nReturns:\n    :class:`~anndata.AnnData` object of the Thyroid Data Set\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.thyroid(encoded=True)",
        "description": "Loads the Thyroid Data SetMore details: http://archive.ics.uci.edu/ml/datasets/Thyroid+Disease\nPreprocessing: https://github.com/theislab/ehrapy-datasets/blob/main/thyroid/thyroid.ipynb",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.thyroid(encoded=True)",
        "api_type": "function",
        "api_calling": [
            "ehrapy.data.thyroid(encoded=@, columns_obs_only=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.tools.filter_rank_features_groups": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "key": {
                "type": null,
                "default": "rank_features_groups",
                "optional": true,
                "description": "Key previously added by :func:`~ehrapy.tl.rank_features_groups`",
                "optional_value": true
            },
            "groupby": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "The key of the observations grouping to consider.",
                "optional_value": true
            },
            "key_added": {
                "type": null,
                "default": "rank_features_groups_filtered",
                "optional": true,
                "description": "The key in `adata.uns` information is saved to.",
                "optional_value": true
            },
            "min_in_group_fraction": {
                "type": null,
                "default": "0.25",
                "optional": true,
                "description": "Minimum in group fraction (default: 0.25).",
                "optional_value": true
            },
            "min_fold_change": {
                "type": null,
                "default": "1",
                "optional": true,
                "description": "Miniumum fold change (default: 1).",
                "optional_value": true
            },
            "max_out_group_fraction": {
                "type": null,
                "default": "0.5",
                "optional": true,
                "description": "Maximum out group fraction (default: 0.5).",
                "optional_value": true
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Filters out features based on fold change and fraction of features containing the feature within and outside the `groupby` categories.\n\nSee :func:`~ehrapy.tl.rank_features_groups`.\n\nResults are stored in `adata.uns[key_added]`\n(default: 'rank_genes_groups_filtered').\n\nTo preserve the original structure of adata.uns['rank_genes_groups'],\nfiltered genes are set to `NaN`.\n\nArgs:\n    adata: Annotated data matrix.\n    key: Key previously added by :func:`~ehrapy.tl.rank_features_groups`\n    groupby: The key of the observations grouping to consider.\n    key_added: The key in `adata.uns` information is saved to.\n    min_in_group_fraction: Minimum in group fraction (default: 0.25).\n    min_fold_change: Miniumum fold change (default: 1).\n    max_out_group_fraction: Maximum out group fraction (default: 0.5).\n\nReturns:\n    Same output as :func:`ehrapy.tl.rank_features_groups` but with filtered feature names set to `nan`\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.tl.rank_features_groups(adata, \"service_unit\")\n    >>> ep.pl.rank_features_groups(adata)",
        "description": "Filters out features based on fold change and fraction of features containing the feature within and outside the `groupby` categories.See :func:`~ehrapy.tl.rank_features_groups`.\n\nResults are stored in `adata.uns[key_added]`\n(default: 'rank_genes_groups_filtered').\n\nTo preserve the original structure of adata.uns['rank_genes_groups'],\nfiltered genes are set to `NaN`.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.tl.rank_features_groups(adata, \"service_unit\")\n    >>> ep.pl.rank_features_groups(adata)",
        "api_type": "function",
        "api_calling": [
            "ehrapy.tools.filter_rank_features_groups(adata=$, key=$, groupby=$, key_added=$, min_in_group_fraction=$, min_fold_change=$, max_out_group_fraction=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.preprocessing.offset_negative_values": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object containing X to normalize values in.",
                "optional_value": true
            },
            "layer": {
                "type": "str",
                "default": "None",
                "optional": true,
                "description": "The layer to offset.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to return a modified copy of the AnnData object.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": ""
        },
        "Docstring": "Offsets negative values into positive ones with the lowest negative value becoming 0.\n\nThis is primarily used to enable the usage of functions such as log_norm that\ndo not allow negative values for mathematical or technical reasons.\n\nArgs:\n    adata: :class:`~anndata.AnnData` object containing X to normalize values in.\n    layer: The layer to offset.\n    copy: Whether to return a modified copy of the AnnData object.\n\nReturns:\n    Copy of AnnData object if copy is True.",
        "description": "Offsets negative values into positive ones with the lowest negative value becoming 0.This is primarily used to enable the usage of functions such as log_norm that\ndo not allow negative values for mathematical or technical reasons.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "ehrapy.preprocessing.offset_negative_values(adata=$, layer=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.plot.missing_values_matrix": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object object containing all observations.",
                "optional_value": true
            },
            "filter": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "The filter to apply to the matrix. Should be one of \"top\", \"bottom\", or None. Defaults to None .",
                "optional_value": false
            },
            "max_cols": {
                "type": "int",
                "default": "0",
                "optional": true,
                "description": "The max number of columns from the AnnData object to include.",
                "optional_value": false
            },
            "max_percentage": {
                "type": "float",
                "default": "0",
                "optional": true,
                "description": "The max percentage fill of the columns from the AnnData object.",
                "optional_value": false
            },
            "sort": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "The row sort order to apply. Can be \"ascending\", \"descending\", or None.",
                "optional_value": false
            },
            "figsize": {
                "type": "tuple",
                "default": "(25, 10)",
                "optional": true,
                "description": "The size of the figure to display.",
                "optional_value": false
            },
            "width_ratios": {
                "type": "tuple",
                "default": "(15, 1)",
                "optional": true,
                "description": "The ratio of the width of the matrix to the width of the sparkline.",
                "optional_value": false
            },
            "color": {
                "type": "tuple",
                "default": "(0.25, 0.25, 0.25)",
                "optional": true,
                "description": "The color of the filled columns.",
                "optional_value": false
            },
            "fontsize": {
                "type": "float",
                "default": "16",
                "optional": true,
                "description": "The figure's font size.",
                "optional_value": false
            },
            "labels": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether or not to display the column names.",
                "optional_value": false
            },
            "label_rotation": {
                "type": "float",
                "default": "45",
                "optional": true,
                "description": "What angle to rotate the text labels to.",
                "optional_value": false
            },
            "sparkline": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether or not to display the sparkline.",
                "optional_value": false
            },
            "categoricals": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to include \"ehrapycat\" columns to the plot.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "A matrix visualization of the nullity of the given AnnData object.\n\nArgs:\n    adata: :class:`~anndata.AnnData` object object containing all observations.\n    filter: The filter to apply to the matrix. Should be one of \"top\", \"bottom\", or None. Defaults to None .\n    max_cols: The max number of columns from the AnnData object to include.\n    max_percentage: The max percentage fill of the columns from the AnnData object.\n    sort: The row sort order to apply. Can be \"ascending\", \"descending\", or None.\n    figsize: The size of the figure to display.\n    width_ratios: The ratio of the width of the matrix to the width of the sparkline.\n    color: The color of the filled columns.\n    fontsize: The figure's font size.\n    labels: Whether or not to display the column names.\n    label_rotation: What angle to rotate the text labels to.\n    sparkline: Whether or not to display the sparkline.\n    categoricals: Whether to include \"ehrapycat\" columns to the plot.\n\nReturns:\n    The plot axis.\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.data.mimic_2(encoded=True)\n    >>> ep.pl.missing_values_matrix(adata, filter='bottom', max_cols=15, max_percentage=0.999)\n\nPreview:\n    .. image:: /_static/docstring_previews/missingno_matrix.png",
        "description": "A matrix visualization of the nullity of the given AnnData object.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.data.mimic_2(encoded=True)\n    >>> ep.pl.missing_values_matrix(adata, filter='bottom', max_cols=15, max_percentage=0.999)\n\nPreview:\n    .. image:: /_static/docstring_previews/missingno_matrix.png",
        "api_type": "function",
        "api_calling": [
            "ehrapy.plot.missing_values_matrix(adata=$, filter=@, max_cols=@, max_percentage=@, sort=@, figsize=@, width_ratios=@, color=@, fontsize=@, labels=@, label_rotation=@, sparkline=@, categoricals=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.anndata.get_obs_df": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "AnnData object to get values from.",
                "optional_value": true
            },
            "keys": {
                "type": "Iterable[str]",
                "default": "()",
                "optional": true,
                "description": "Keys from either `.var_names`, `.var[gene_symbols]`, or `.obs.columns`.",
                "optional_value": false
            },
            "obsm_keys": {
                "type": "Iterable[tuple[str, int]]",
                "default": "()",
                "optional": true,
                "description": "Tuple of `(key from obsm, column index of obsm[key])`.",
                "optional_value": false
            },
            "layer": {
                "type": "str",
                "default": "None",
                "optional": true,
                "description": "Layer of `adata`.",
                "optional_value": false
            },
            "features": {
                "type": "str",
                "default": "None",
                "optional": true,
                "description": "Column of `adata.var` to search for `keys` in.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Return values for observations in adata.\n\nArgs:\n    adata: AnnData object to get values from.\n    keys: Keys from either `.var_names`, `.var[gene_symbols]`, or `.obs.columns`.\n    obsm_keys: Tuple of `(key from obsm, column index of obsm[key])`.\n    layer: Layer of `adata`.\n    features: Column of `adata.var` to search for `keys` in.\n\nReturns:\n    A dataframe with `adata.obs_names` as index, and values specified by `keys` and `obsm_keys`.\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ages = ep.ad.get_obs_df(adata, keys = ['age'])",
        "description": "Return values for observations in adata.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ages = ep.ad.get_obs_df(adata, keys = ['age'])",
        "api_type": "function",
        "api_calling": [
            "ehrapy.anndata.get_obs_df(adata=$, keys=@, obsm_keys=@, layer=@, features=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.plot.rank_features_groups_violin": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "groups": {
                "type": "Optional[Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "List of group names.",
                "optional_value": false
            },
            "n_features": {
                "type": "int",
                "default": "20",
                "optional": true,
                "description": "Number of features to show. Is ignored if `feature_names` is passed.",
                "optional_value": false
            },
            "feature_names": {
                "type": "Optional[Iterable[str]]",
                "default": "None",
                "optional": true,
                "description": "List of features to plot. Is only useful if interested in a custom feature list,\nwhich is not the result of :func:`ehrapy.tl.rank_features_groups`.",
                "optional_value": false
            },
            "feature_symbols": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Key for field in `.var` that stores feature symbols if you do not want to\nuse `.var_names` displayed in the plot.",
                "optional_value": false
            },
            "key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "The key of the calculated feature group rankings (default: 'rank_features_groups').",
                "optional_value": false
            },
            "split": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to split the violins or not.",
                "optional_value": false
            },
            "scale": {
                "type": "str",
                "default": "width",
                "optional": true,
                "description": "See :func:`~seaborn.violinplot`.",
                "optional_value": false
            },
            "strip": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Show a strip plot on top of the violin plot.",
                "optional_value": false
            },
            "jitter": {
                "type": "Union[int, float, bool]",
                "default": "True",
                "optional": true,
                "description": "If set to 0, no points are drawn. See :func:`~seaborn.stripplot`.",
                "optional_value": false
            },
            "size": {
                "type": "int",
                "default": "1",
                "optional": true,
                "description": "Size of the jitter points.",
                "optional_value": false
            },
            "ax": {
                "type": "Optional[Axes]",
                "default": "None",
                "optional": true,
                "description": "A matplotlib axes object. Only works if plotting a single component.",
                "optional_value": true
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Whether to display the figure or return axis.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Plot ranking of features for all tested comparisons as violin plots.\n\nArgs:\n    adata: Annotated data matrix.\n    groups: List of group names.\n    n_features: Number of features to show. Is ignored if `feature_names` is passed.\n    feature_names: List of features to plot. Is only useful if interested in a custom feature list,\n                   which is not the result of :func:`ehrapy.tl.rank_features_groups`.\n    feature_symbols: Key for field in `.var` that stores feature symbols if you do not want to\n                     use `.var_names` displayed in the plot.\n    key: The key of the calculated feature group rankings (default: 'rank_features_groups').\n    split: Whether to split the violins or not.\n    scale: See :func:`~seaborn.violinplot`.\n    strip: Show a strip plot on top of the violin plot.\n    jitter: If set to 0, no points are drawn. See :func:`~seaborn.stripplot`.\n    size: Size of the jitter points.\n    show: Whether to display the figure or return axis.\n    save: If `True` or a `str`, save the figure.\n          A string is appended to the default filename.\n          Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\n    ax: A matplotlib axes object. Only works if plotting a single component.\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.knn_impute(adata)\n    >>> ep.pp.log_norm(adata, offset=1)\n    >>> ep.pp.neighbors(adata)\n    >>> ep.tl.leiden(adata, resolution=0.15, key_added=\"leiden_0_5\")\n    >>> ep.tl.rank_features_groups(adata, groupby=\"leiden_0_5\")\n    >>> ep.pl.rank_features_groups_violin(adata, key=\"rank_features_groups\", n_features=5)\n\nPreview:\n    .. image:: /_static/docstring_previews/rank_features_groups_violin_1.png\n\n    .. image:: /_static/docstring_previews/rank_features_groups_violin_2.png\n\n    .. image:: /_static/docstring_previews/rank_features_groups_violin_3.png\n\n    .. image:: /_static/docstring_previews/rank_features_groups_violin_4.png",
        "description": "Plot ranking of features for all tested comparisons as violin plots.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.knn_impute(adata)\n    >>> ep.pp.log_norm(adata, offset=1)\n    >>> ep.pp.neighbors(adata)\n    >>> ep.tl.leiden(adata, resolution=0.15, key_added=\"leiden_0_5\")\n    >>> ep.tl.rank_features_groups(adata, groupby=\"leiden_0_5\")\n    >>> ep.pl.rank_features_groups_violin(adata, key=\"rank_features_groups\", n_features=5)\n\nPreview:\n    .. image:: /_static/docstring_previews/rank_features_groups_violin_1.png\n\n    .. image:: /_static/docstring_previews/rank_features_groups_violin_2.png\n\n    .. image:: /_static/docstring_previews/rank_features_groups_violin_3.png\n\n    .. image:: /_static/docstring_previews/rank_features_groups_violin_4.png",
        "api_type": "function",
        "api_calling": [
            "ehrapy.plot.rank_features_groups_violin(adata=$, groups=@, n_features=@, feature_names=@, feature_symbols=@, key=@, split=@, scale=@, strip=@, jitter=@, size=@, ax=$, show=@, save=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.data.cervical_cancer_risk_factors": {
        "Parameters": {
            "encoded": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to return an already encoded object",
                "optional_value": false
            },
            "columns_obs_only": {
                "type": "Optional[Union[dict[str, list[str]], list[str]]]",
                "default": "None",
                "optional": true,
                "description": "Columns to include in obs only and not X.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": ""
        },
        "Docstring": "Loads the Cervical cancer (Risk Factors) Data Set\n\nMore details: http://archive.ics.uci.edu/ml/datasets/Cervical+cancer+%28Risk+Factors%29\nPreprocessing: https://github.com/theislab/ehrapy-datasets/blob/main/cervical_cancer_risk_factors/cervical_cancer_risk_factors.ipynb\n\nArgs:\n    encoded: Whether to return an already encoded object\n    columns_obs_only: Columns to include in obs only and not X.\n\nReturns:\n    :class:`~anndata.AnnData` object of the Cervical cancer (Risk Factors) Data Set\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.cervical_cancer_risk_factors(encoded=True)",
        "description": "Loads the Cervical cancer (Risk Factors) Data SetMore details: http://archive.ics.uci.edu/ml/datasets/Cervical+cancer+%28Risk+Factors%29\nPreprocessing: https://github.com/theislab/ehrapy-datasets/blob/main/cervical_cancer_risk_factors/cervical_cancer_risk_factors.ipynb",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.cervical_cancer_risk_factors(encoded=True)",
        "api_type": "function",
        "api_calling": [
            "ehrapy.data.cervical_cancer_risk_factors(encoded=@, columns_obs_only=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.data.breast_tissue": {
        "Parameters": {
            "encoded": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to return an already encoded object",
                "optional_value": false
            },
            "columns_obs_only": {
                "type": "Optional[Union[dict[str, list[str]], list[str]]]",
                "default": "None",
                "optional": true,
                "description": "Columns to include in obs only and not X.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": ""
        },
        "Docstring": "Loads the Breast Tissue Data Set\n\nMore details: http://archive.ics.uci.edu/ml/datasets/Breast+Tissue\nPreprocessing: https://github.com/theislab/ehrapy-datasets/blob/main/breast_tissue/breast_tissue.ipynb\n\nArgs:\n    encoded: Whether to return an already encoded object\n    columns_obs_only: Columns to include in obs only and not X.\n\nReturns:\n    :class:`~anndata.AnnData` object of the Breast Tissue Data Set\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.breast_tissue(encoded=True)",
        "description": "Loads the Breast Tissue Data SetMore details: http://archive.ics.uci.edu/ml/datasets/Breast+Tissue\nPreprocessing: https://github.com/theislab/ehrapy-datasets/blob/main/breast_tissue/breast_tissue.ipynb",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.breast_tissue(encoded=True)",
        "api_type": "function",
        "api_calling": [
            "ehrapy.data.breast_tissue(encoded=@, columns_obs_only=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.plot.embedding_density": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object object containing all observations.",
                "optional_value": true
            },
            "basis": {
                "type": "str",
                "default": "umap",
                "optional": true,
                "description": "The embedding over which the density was calculated.\nThis embedded representation should be found in `adata.obsm['X_[basis]']``.",
                "optional_value": false
            },
            "key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Name of the `.obs` covariate that contains the density estimates. Alternatively, pass `groupby`.",
                "optional_value": false
            },
            "groupby": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Name of the condition used in `tl.embedding_density`. Alternatively, pass `key`.",
                "optional_value": false
            },
            "group": {
                "type": "Optional[Union[str, list[str]]]",
                "default": "all",
                "optional": true,
                "description": "The category in the categorical observation annotation to be plotted.\nIf all categories are to be plotted use group='all' (default), If multiple categories\nwant to be plotted use a list (e.g.: ['G1', 'S']. If the overall density wants to be ploted set group to 'None'.",
                "optional_value": false
            },
            "color_map": {
                "type": "Union[Colormap, str]",
                "default": "YlOrRd",
                "optional": true,
                "description": "Matplolib color map to use for density plotting.",
                "optional_value": false
            },
            "bg_dotsize": {
                "type": "Optional[int]",
                "default": "80",
                "optional": true,
                "description": "Dot size for background data points not in the `group`.",
                "optional_value": false
            },
            "fg_dotsize": {
                "type": "Optional[int]",
                "default": "180",
                "optional": true,
                "description": "Dot size for foreground data points in the `group`.",
                "optional_value": false
            },
            "vmax": {
                "type": "Optional[int]",
                "default": "1",
                "optional": true,
                "description": "The value representing the upper limit of the color scale. The format is the same as for `vmin`.",
                "optional_value": false
            },
            "vmin": {
                "type": "Optional[int]",
                "default": "0",
                "optional": true,
                "description": "The value representing the lower limit of the color scale. Values smaller than vmin are plotted\nwith the same color as vmin. vmin can be a number, a string, a function or `None`. If\nvmin is a string and has the format `pN`, this is interpreted as a vmin=percentile(N).\nFor example vmin='p1.5' is interpreted as the 1.5 percentile. If vmin is function, then\nvmin is interpreted as the return value of the function over the list of values to plot.\nFor example to set vmin tp the mean of the values to plot, `def my_vmin(values): return\nnp.mean(values)` and then set `vmin=my_vmin`. If vmin is None (default) an automatic\nminimum value is used as defined by matplotlib `scatter` function. When making multiple\nplots, vmin can be a list of values, one for each plot. For example `vmin=[0.1, 'p1', None, my_vmin]`",
                "optional_value": false
            },
            "vcenter": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "The value representing the center of the color scale. Useful for diverging colormaps.\nThe format is the same as for `vmin`.\nExample: sc.pl.umap(adata, color='TREM2', vcenter='p50', cmap='RdBu_r')",
                "optional_value": false
            },
            "norm": {
                "type": "Optional[Normalize]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "ncols": {
                "type": "Optional[int]",
                "default": "4",
                "optional": true,
                "description": "Number of panels per row.",
                "optional_value": false
            },
            "hspace": {
                "type": "Optional[float]",
                "default": "0.25",
                "optional": true,
                "description": "Adjust the height of the space between multiple panels.",
                "optional_value": false
            },
            "wspace": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "Adjust the width of the space between multiple panels.",
                "optional_value": true
            },
            "title": {
                "type": "str",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[bool, str]]",
                "default": "None",
                "optional": true,
                "description": "If `True` or a `str`, save the figure.\nA string is appended to the default filename.\nInfer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.",
                "optional_value": false
            },
            "ax": {
                "type": "Optional[Axes]",
                "default": "None",
                "optional": true,
                "description": "A matplotlib axes object. Only works if plotting a single component.",
                "optional_value": true
            },
            "return_fig": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Return the matplotlib figure.        show: Whether to display the figure or return axis.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[Union[Figure, Axes]]",
            "description": ""
        },
        "Docstring": "Plot the density of observations in an embedding (per condition).\n\nPlots the gaussian kernel density estimates (over condition) from the `sc.tl.embedding_density()` output. This currently\ndoes not support extracted medcat entities.\n\nArgs:\n    adata: :class:`~anndata.AnnData` object object containing all observations.\n    basis: The embedding over which the density was calculated.\n           This embedded representation should be found in `adata.obsm['X_[basis]']``.\n    key: Name of the `.obs` covariate that contains the density estimates. Alternatively, pass `groupby`.\n    groupby: Name of the condition used in `tl.embedding_density`. Alternatively, pass `key`.\n    group: The category in the categorical observation annotation to be plotted.\n           If all categories are to be plotted use group='all' (default), If multiple categories\n           want to be plotted use a list (e.g.: ['G1', 'S']. If the overall density wants to be ploted set group to 'None'.\n    color_map: Matplolib color map to use for density plotting.\n    bg_dotsize: Dot size for background data points not in the `group`.\n    fg_dotsize: Dot size for foreground data points in the `group`.\n    vmin: The value representing the lower limit of the color scale. Values smaller than vmin are plotted\n          with the same color as vmin. vmin can be a number, a string, a function or `None`. If\n          vmin is a string and has the format `pN`, this is interpreted as a vmin=percentile(N).\n          For example vmin='p1.5' is interpreted as the 1.5 percentile. If vmin is function, then\n          vmin is interpreted as the return value of the function over the list of values to plot.\n          For example to set vmin tp the mean of the values to plot, `def my_vmin(values): return\n          np.mean(values)` and then set `vmin=my_vmin`. If vmin is None (default) an automatic\n          minimum value is used as defined by matplotlib `scatter` function. When making multiple\n          plots, vmin can be a list of values, one for each plot. For example `vmin=[0.1, 'p1', None, my_vmin]`\n    vmax: The value representing the upper limit of the color scale. The format is the same as for `vmin`.\n    vcenter: The value representing the center of the color scale. Useful for diverging colormaps.\n             The format is the same as for `vmin`.\n             Example: sc.pl.umap(adata, color='TREM2', vcenter='p50', cmap='RdBu_r')\n    ncols: Number of panels per row.\n    wspace: Adjust the width of the space between multiple panels.\n    hspace: Adjust the height of the space between multiple panels.\n    return_fig: Return the matplotlib figure.        show: Whether to display the figure or return axis.\n    save: If `True` or a `str`, save the figure.\n          A string is appended to the default filename.\n          Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\n    ax: A matplotlib axes object. Only works if plotting a single component.\n\nReturns:\n    If `show==False` a :class:`~matplotlib.axes.Axes` or a list of it.\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.knn_impute(adata)\n    >>> ep.pp.log_norm(adata, offset=1)\n    >>> ep.pp.neighbors(adata)\n    >>> ep.tl.umap(adata)\n    >>> ep.tl.leiden(adata, resolution=0.5, key_added=\"leiden_0_5\")\n    >>> ep.tl.embedding_density(adata, groupby='leiden_0_5', key_added='icu_exp_flg')\n    >>> ep.pl.embedding_density(adata, key='icu_exp_flg')\n\nPreview:\n    .. image:: /_static/docstring_previews/embedding_density.png",
        "description": "Plot the density of observations in an embedding (per condition).Plots the gaussian kernel density estimates (over condition) from the `sc.tl.embedding_density()` output. This currently\ndoes not support extracted medcat entities.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.knn_impute(adata)\n    >>> ep.pp.log_norm(adata, offset=1)\n    >>> ep.pp.neighbors(adata)\n    >>> ep.tl.umap(adata)\n    >>> ep.tl.leiden(adata, resolution=0.5, key_added=\"leiden_0_5\")\n    >>> ep.tl.embedding_density(adata, groupby='leiden_0_5', key_added='icu_exp_flg')\n    >>> ep.pl.embedding_density(adata, key='icu_exp_flg')\n\nPreview:\n    .. image:: /_static/docstring_previews/embedding_density.png",
        "api_type": "function",
        "api_calling": [
            "ehrapy.plot.embedding_density(adata=$, basis=@, key=@, groupby=@, group=@, color_map=@, bg_dotsize=@, fg_dotsize=@, vmax=@, vmin=@, vcenter=@, norm=$, ncols=@, hspace=@, wspace=$, title=@, show=@, save=@, ax=$, return_fig=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.tools.causal_inference": {
        "Parameters": {
            "adata": {
                "type": "anndata.AnnData",
                "default": null,
                "optional": false,
                "description": "An AnnData object containing the input data.",
                "optional_value": true
            },
            "graph": {
                "type": "Union[nx.DiGraph, str]",
                "default": null,
                "optional": false,
                "description": "A str representing the causal graph to use.",
                "optional_value": false
            },
            "treatment": {
                "type": "str",
                "default": null,
                "optional": false,
                "description": "A str representing the treatment variable in the causal graph.",
                "optional_value": false
            },
            "outcome": {
                "type": "str",
                "default": null,
                "optional": false,
                "description": "A str representing the outcome variable in the causal graph.",
                "optional_value": false
            },
            "estimation_method": {
                "type": "Literal['backdoor.propensity_score_matching', 'backdoor.propensity_score_stratification', 'backdoor.propensity_score_weighting', 'backdoor.linear_regression', 'backdoor.generalized_linear_model', 'iv.instrumental_variable', 'iv.regression_discontinuity', 'backdoor.econml.linear_model.LinearDML', 'backdoor.econml.nonparametric_model.NonParamDML', 'backdoor.econml.causal_forest.CausalForestDML', 'backdoor.econml.forecast_model.ForestDML', 'backdoor.econml.dml.DML', 'backdoor.econml.dml.DMLCate', 'backdoor.econml.xgboost.XGBTRegressor', 'backdoor.econml.xgboost.XGBTEstimator', 'backdoor.econml.metalearners.XLearner']",
                "default": null,
                "optional": false,
                "description": "An optional Literal specifying the estimation method to use. Defaults to \"backdoor.propensity_score_stratification\".",
                "optional_value": false
            },
            "refute_methods": {
                "type": "Optional[Union[list[str], list[Literal['placebo_treatment_refuter', 'random_common_cause', 'data_subset_refuter', 'add_unobserved_common_cause']]]]",
                "default": "None",
                "optional": true,
                "description": "An optional List of Literal specifying the methods to use for refutation tests. Defaults to [\"placebo_treatment_refuter\", \"random_common_cause\", \"data_subset_refuter\"].",
                "optional_value": false
            },
            "print_causal_estimate": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to print the causal estimate or not, default is False.",
                "optional_value": false
            },
            "print_summary": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to print the causal model summary or not, default is True.",
                "optional_value": false
            },
            "return_as": {
                "type": "Literal['estimate', 'refute', 'estimate+refute']",
                "default": "estimate",
                "optional": true,
                "description": "An optional Literal specifying the type of output to return. Defaults to \"summary\".",
                "optional_value": true
            },
            "show_graph": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to display the graph or not, default is False.",
                "optional_value": false
            },
            "show_refute_plots": {
                "type": "Optional[Union[bool, Literal['colormesh', 'contour', 'line']]]",
                "default": "None",
                "optional": true,
                "description": "Whether to display the refutation plots or not, default is False.",
                "optional_value": false
            },
            "attempts": {
                "type": "int",
                "default": "10",
                "optional": true,
                "description": "Number of attempts to try to generate a valid causal estimate, default is 10.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "tuple[dowhy.CausalEstimate, dict[str, str | dict[str, float]]]",
            "description": ""
        },
        "Docstring": "Performs causal inference on an AnnData object using the specified causal model and returns a tuple containing the causal estimate and the results of any refutation tests.\n\nArgs:\n    adata: An AnnData object containing the input data.\n    graph: A str representing the causal graph to use.\n    treatment: A str representing the treatment variable in the causal graph.\n    outcome: A str representing the outcome variable in the causal graph.\n    estimation_method: An optional Literal specifying the estimation method to use. Defaults to \"backdoor.propensity_score_stratification\".\n    refute_methods: An optional List of Literal specifying the methods to use for refutation tests. Defaults to [\"placebo_treatment_refuter\", \"random_common_cause\", \"data_subset_refuter\"].\n    print_causal_estimate: Whether to print the causal estimate or not, default is False.\n    print_summary: Whether to print the causal model summary or not, default is True.\n    return_as: An optional Literal specifying the type of output to return. Defaults to \"summary\".\n    show_graph: Whether to display the graph or not, default is False.\n    show_refute_plots: Whether to display the refutation plots or not, default is False.\n    attempts: Number of attempts to try to generate a valid causal estimate, default is 10.\n    identify_kwargs: Optional keyword arguments for dowhy.CausalModel.identify_effect().\n    estimate_kwargs: Optional keyword arguments for dowhy.CausalModel.estimate_effect().\n    refute_kwargs: Optional keyword arguments for dowhy.CausalModel.refute_estimate().\n\nReturns:\n    A tuple containing the causal estimate and a dictionary of the results of any refutation tests.\n\nRaises:\n    TypeError: If adata, graph, treatment, outcome, refute_methods, estimation_method, or return_as is not of the expected type.\n    ValueError: If refute_methods or estimation_method contains an unknown value, or if return_as is an unknown value.\n\nExamples:\n    >>> data = dowhy.datasets.linear_dataset(\n    >>>     beta=10,\n    >>>     num_common_causes=5,\n    >>>     num_instruments=2,\n    >>>     num_samples=1000,\n    >>>     treatment_is_binary=True,\n    >>> )\n    >>>\n    >>> ep.tl.causal_inference(\n    >>>     adata=anndata.AnnData(data[\"df\"]),\n    >>>     graph=data[\"gml_graph\"],\n    >>>     treatment=\"v0\",\n    >>>     outcome=\"y\",\n    >>>     estimation_method=\"backdoor.propensity_score_stratification\",\n    >>> )\n    >>>\n    >>> estimate = ep.tl.causal_inference(\n    >>>     adata=self.linear_data,\n    >>>     graph=self.linear_graph,\n    >>>     treatment=\"treatment\",\n    >>>     outcome=\"outcome\",\n    >>>     estimation_method=\"backdoor.linear_regression\",\n    >>>     return_as=\"estimate\",\n    >>>     show_graph=True,\n    >>>     show_refute_plots=True,\n    >>> )\n    >>> ep.tl.plot_causal_effect(estimate)",
        "description": "Performs causal inference on an AnnData object using the specified causal model and returns a tuple containing the causal estimate and the results of any refutation tests.",
        "example": ">>> data = dowhy.datasets.linear_dataset(\n    >>>     beta=10,\n    >>>     num_common_causes=5,\n    >>>     num_instruments=2,\n    >>>     num_samples=1000,\n    >>>     treatment_is_binary=True,\n    >>> )\n    >>>\n    >>> ep.tl.causal_inference(\n    >>>     adata=anndata.AnnData(data[\"df\"]),\n    >>>     graph=data[\"gml_graph\"],\n    >>>     treatment=\"v0\",\n    >>>     outcome=\"y\",\n    >>>     estimation_method=\"backdoor.propensity_score_stratification\",\n    >>> )\n    >>>\n    >>> estimate = ep.tl.causal_inference(\n    >>>     adata=self.linear_data,\n    >>>     graph=self.linear_graph,\n    >>>     treatment=\"treatment\",\n    >>>     outcome=\"outcome\",\n    >>>     estimation_method=\"backdoor.linear_regression\",\n    >>>     return_as=\"estimate\",\n    >>>     show_graph=True,\n    >>>     show_refute_plots=True,\n    >>> )\n    >>> ep.tl.plot_causal_effect(estimate)",
        "api_type": "function",
        "api_calling": [
            "ehrapy.tools.causal_inference(adata=$, graph=@, treatment=@, outcome=@, estimation_method=@, refute_methods=@, print_causal_estimate=@, print_summary=@, return_as=$, show_graph=@, show_refute_plots=@, attempts=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.preprocessing.log_norm": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object containing X to normalize values in. Must already be encoded using :func:`~ehrapy.preprocessing.encode`.",
                "optional_value": true
            },
            "vars": {
                "type": "Optional[Union[str, Sequence[str]]]",
                "default": "None",
                "optional": true,
                "description": "List of the names of the numeric variables to normalize.\nIf None all numeric variables will be normalized. Defaults to None.",
                "optional_value": false
            },
            "base": {
                "type": "Optional[Union[int, float]]",
                "default": "None",
                "optional": true,
                "description": "Numeric base for logarithm. If None the natural logarithm is used.",
                "optional_value": false
            },
            "offset": {
                "type": "Union[int, float]",
                "default": "1",
                "optional": true,
                "description": "Offset added to values before computing the logarithm. Defaults to 1 .",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to return a copy or act in place. Defaults to False .",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[AnnData]",
            "description": ""
        },
        "Docstring": "Apply log normalization.\n\nComputes :math:`x = \\log(x + offset)`, where :math:`log` denotes the natural logarithm\nunless a different base is given and the default :math:`offset` is :math:`1`\n\nArgs:\n    adata: :class:`~anndata.AnnData` object containing X to normalize values in. Must already be encoded using :func:`~ehrapy.preprocessing.encode`.\n    vars: List of the names of the numeric variables to normalize.\n          If None all numeric variables will be normalized. Defaults to None.\n    base: Numeric base for logarithm. If None the natural logarithm is used.\n    offset: Offset added to values before computing the logarithm. Defaults to 1 .\n    copy: Whether to return a copy or act in place. Defaults to False .\n\nReturns:\n    :class:`~anndata.AnnData` object with normalized X.\n    Also stores a record of applied normalizations as a dictionary in adata.uns[\"normalization\"].\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> adata_norm = ep.pp.log_norm(adata, copy=True)",
        "description": "Apply log normalization.Computes :math:`x = \\log(x + offset)`, where :math:`log` denotes the natural logarithm\nunless a different base is given and the default :math:`offset` is :math:`1`",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> adata_norm = ep.pp.log_norm(adata, copy=True)",
        "api_type": "function",
        "api_calling": [
            "ehrapy.preprocessing.log_norm(adata=$, vars=@, base=@, offset=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.preprocessing.explicit_impute": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object containing X to impute values in.",
                "optional_value": true
            },
            "replacement": {
                "type": "Union[str, int, dict[str, str, int]]",
                "default": null,
                "optional": false,
                "description": "The value to replace missing values with. If a dictionary is provided, the keys represent column\nnames and the values represent replacement values for those columns.",
                "optional_value": false
            },
            "impute_empty_strings": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "If True, empty strings are also replaced. Defaults to True.",
                "optional_value": false
            },
            "warning_threshold": {
                "type": "int",
                "default": "70",
                "optional": true,
                "description": "Threshold of percentage of missing values to display a warning for. Defaults to 30.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If True, returns a modified copy of the original AnnData object. If False, modifies the object in place.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": ""
        },
        "Docstring": "Replaces all missing values in all columns or a subset of columns specified by the user with the passed replacement value.\n\nThere are two scenarios to cover:\n1. Replace all missing values with the specified value.\n2. Replace all missing values in a subset of columns with a specified value per column.\n\nArgs:\n    adata: :class:`~anndata.AnnData` object containing X to impute values in.\n    replacement: The value to replace missing values with. If a dictionary is provided, the keys represent column\n                 names and the values represent replacement values for those columns.\n    impute_empty_strings: If True, empty strings are also replaced. Defaults to True.\n    warning_threshold: Threshold of percentage of missing values to display a warning for. Defaults to 30.\n    copy: If True, returns a modified copy of the original AnnData object. If False, modifies the object in place.\n\nReturns:\n    If copy is True, a modified copy of the original AnnData object with imputed X.\n    If copy is False, the original AnnData object is modified in place.\n\nExamples:\n    Replace all missing values in adata with the value 0:\n\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.explicit_impute(adata, replacement=0)",
        "description": "Replaces all missing values in all columns or a subset of columns specified by the user with the passed replacement value.There are two scenarios to cover:\n1. Replace all missing values with the specified value.\n2. Replace all missing values in a subset of columns with a specified value per column.",
        "example": "Replace all missing values in adata with the value 0:\n\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.explicit_impute(adata, replacement=0)",
        "api_type": "function",
        "api_calling": [
            "ehrapy.preprocessing.explicit_impute(adata=$, replacement=@, impute_empty_strings=@, warning_threshold=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.preprocessing.robust_scale_norm": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object containing X to normalize values in.\nMust already be encoded using :func:`~ehrapy.preprocessing.encode`.",
                "optional_value": true
            },
            "vars": {
                "type": "Optional[Union[str, Sequence[str]]]",
                "default": "None",
                "optional": true,
                "description": "List of the names of the numeric variables to normalize.\nIf None all numeric variables will be normalized. Defaults to None .",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to return a copy or act in place. Defaults to False .",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[AnnData]",
            "description": ""
        },
        "Docstring": "Apply robust scaling normalization.\n\nFunctionality is provided by :func:`~sklearn.preprocessing.robust_scale`,\nsee https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.robust_scale.html for details.\n\nArgs:\n    adata: :class:`~anndata.AnnData` object containing X to normalize values in.\n           Must already be encoded using :func:`~ehrapy.preprocessing.encode`.\n    vars: List of the names of the numeric variables to normalize.\n          If None all numeric variables will be normalized. Defaults to None .\n    copy: Whether to return a copy or act in place. Defaults to False .\n    **kwargs: Additional arguments passed to :func:`~sklearn.preprocessing.robust_scale`\n\nReturns:\n    :class:`~anndata.AnnData` object with normalized X.\n    Also stores a record of applied normalizations as a dictionary in adata.uns[\"normalization\"].\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> adata_norm = ep.pp.robust_scale_norm(adata, copy=True)",
        "description": "Apply robust scaling normalization.Functionality is provided by :func:`~sklearn.preprocessing.robust_scale`,\nsee https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.robust_scale.html for details.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> adata_norm = ep.pp.robust_scale_norm(adata, copy=True)",
        "api_type": "function",
        "api_calling": [
            "ehrapy.preprocessing.robust_scale_norm(adata=$, vars=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.io.read_csv": {
        "Parameters": {
            "dataset_path": {
                "type": "Union[Path, str]",
                "default": null,
                "optional": false,
                "description": "Path to the file or directory to read.",
                "optional_value": false
            },
            "sep": {
                "type": "str",
                "default": ",",
                "optional": true,
                "description": "Separator in the file. One of either , (comma) or   (tab). Defaults to , (comma)",
                "optional_value": false
            },
            "index_column": {
                "type": "Optional[Union[dict[str, str, int], str, int]]",
                "default": "None",
                "optional": true,
                "description": "The index column of obs. Usually the patient visit ID or the patient ID.",
                "optional_value": false
            },
            "columns_obs_only": {
                "type": "Optional[Union[dict[str, list[str]], list[str]]]",
                "default": "None",
                "optional": true,
                "description": "These columns will be added to obs only and not X.",
                "optional_value": false
            },
            "columns_x_only": {
                "type": "Optional[Union[dict[str, list[str]], list[str]]]",
                "default": "None",
                "optional": true,
                "description": "These columns will be added to X only and all remaining columns to obs.\nNote that datetime columns will always be added to .obs though.",
                "optional_value": false
            },
            "return_dfs": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to return one or several Pandas DataFrames.",
                "optional_value": false
            },
            "cache": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to write to cache when reading or not. Defaults to False .",
                "optional_value": false
            },
            "backup_url": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "URL to download the data file(s) from, if the dataset is not yet on disk.",
                "optional_value": false
            },
            "download_dataset_name": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Name of the file or directory after download.",
                "optional_value": false
            },
            "archive_format": {
                "type": "Literal['zip', 'tar', 'tar.gz', 'tgz']",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            }
        },
        "Returns": {
            "type": "Union[AnnData, dict[str, AnnData]]",
            "description": ""
        },
        "Docstring": "Reads or downloads a desired directory of csv/tsv files or a single csv/tsv file.\n\nArgs:\n    dataset_path: Path to the file or directory to read.\n    sep: Separator in the file. One of either , (comma) or   (tab). Defaults to , (comma)\n    index_column: The index column of obs. Usually the patient visit ID or the patient ID.\n    columns_obs_only: These columns will be added to obs only and not X.\n    columns_x_only: These columns will be added to X only and all remaining columns to obs.\n                    Note that datetime columns will always be added to .obs though.\n    return_dfs: Whether to return one or several Pandas DataFrames.\n    cache: Whether to write to cache when reading or not. Defaults to False .\n    download_dataset_name: Name of the file or directory after download.\n    backup_url: URL to download the data file(s) from, if the dataset is not yet on disk.\n    is_archive: Whether the downloaded file is an archive.\n\nReturns:\n    An :class:`~anndata.AnnData` object or a dict with an identifier (the filename, without extension)\n    for each :class:`~anndata.AnnData` object in the dict\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.io.read_csv(\"myfile.csv\")",
        "description": "Reads or downloads a desired directory of csv/tsv files or a single csv/tsv file.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.io.read_csv(\"myfile.csv\")",
        "api_type": "function",
        "api_calling": [
            "ehrapy.io.read_csv(dataset_path=@, sep=@, index_column=@, columns_obs_only=@, columns_x_only=@, return_dfs=@, cache=@, backup_url=@, download_dataset_name=@, archive_format=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.preprocessing.miss_forest_impute": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "The AnnData object to use MissForest Imputation on.",
                "optional_value": true
            },
            "var_names": {
                "type": "Optional[Union[dict[str, list[str]], list[str]]]",
                "default": "None",
                "optional": true,
                "description": "List of columns to impute or a dict with two keys ('numerical' and 'non_numerical') indicating which var\ncontain mixed data and which numerical data only.",
                "optional_value": false
            },
            "num_initial_strategy": {
                "type": "Literal['mean', 'median', 'most_frequent', 'constant']",
                "default": "mean",
                "optional": true,
                "description": "The initial strategy to replace all missing numerical values with. Defaults to 'mean'.",
                "optional_value": true
            },
            "max_iter": {
                "type": "int",
                "default": "10",
                "optional": true,
                "description": "The maximum number of iterations if the stop criterion has not been met yet.",
                "optional_value": false
            },
            "n_estimators": {
                "type": null,
                "default": "100",
                "optional": true,
                "description": "The number of trees to fit for every missing variable. Has a big effect on the run time.\nDecrease for faster computations. Defaults to 100.",
                "optional_value": true
            },
            "random_state": {
                "type": "int",
                "default": "0",
                "optional": true,
                "description": "The random seed for the initialization. Defaults to 0.",
                "optional_value": false
            },
            "warning_threshold": {
                "type": "int",
                "default": "70",
                "optional": true,
                "description": "Threshold of percentage of missing values to display a warning for. Defaults to 30 .",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to return a copy or act in place. Defaults to False.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": ""
        },
        "Docstring": "Impute data using the MissForest strategy.\n\nThis function uses the MissForest strategy to impute missing values in the data matrix of an AnnData object.\nThe strategy works by fitting a random forest model on each feature containing missing values,\nand using the trained model to predict the missing values.\n\nSee https://academic.oup.com/bioinformatics/article/28/1/112/219101.\nThis requires the computation of which columns in X contain numerical only (including NaNs) and which contain non-numerical data.\n\nArgs:\n    adata: The AnnData object to use MissForest Imputation on.\n    var_names: List of columns to impute or a dict with two keys ('numerical' and 'non_numerical') indicating which var\n               contain mixed data and which numerical data only.\n    num_initial_strategy: The initial strategy to replace all missing numerical values with. Defaults to 'mean'.\n    max_iter: The maximum number of iterations if the stop criterion has not been met yet.\n    n_estimators: The number of trees to fit for every missing variable. Has a big effect on the run time.\n                  Decrease for faster computations. Defaults to 100.\n    random_state: The random seed for the initialization. Defaults to 0.\n    warning_threshold: Threshold of percentage of missing values to display a warning for. Defaults to 30 .\n    copy: Whether to return a copy or act in place. Defaults to False.\n\nReturns:\n    The imputed (but unencoded) AnnData object.\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.miss_forest_impute(adata)",
        "description": "Impute data using the MissForest strategy.This function uses the MissForest strategy to impute missing values in the data matrix of an AnnData object.\nThe strategy works by fitting a random forest model on each feature containing missing values,\nand using the trained model to predict the missing values.\n\nSee https://academic.oup.com/bioinformatics/article/28/1/112/219101.\nThis requires the computation of which columns in X contain numerical only (including NaNs) and which contain non-numerical data.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.miss_forest_impute(adata)",
        "api_type": "function",
        "api_calling": [
            "ehrapy.preprocessing.miss_forest_impute(adata=$, var_names=@, num_initial_strategy=$, max_iter=@, n_estimators=$, random_state=@, warning_threshold=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.tools.draw_graph": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object object containing all observations.",
                "optional_value": true
            },
            "layout": {
                "type": "Literal[fr, drl, kk, grid_fr, lgl, rt, rt_circular, fa]",
                "default": "fa",
                "optional": true,
                "description": "'fa' (`ForceAtlas2`) or any valid `igraph layout\n<http://igraph.org/c/doc/igraph-Layout.html>`__. Of particular interest\nare 'fr' (Fruchterman Reingold), 'grid_fr' (Grid Fruchterman Reingold,\nfaster than 'fr'), 'kk' (Kamadi Kawai', slower than 'fr'), 'lgl' (Large\nGraph, very fast), 'drl' (Distributed Recursive Layout, pretty fast) and\n'rt' (Reingold Tilford tree layout).",
                "optional_value": true
            },
            "init_pos": {
                "type": "Optional[Union[str, bool]]",
                "default": "None",
                "optional": true,
                "description": "`'paga'`/`True`, `None`/`False`, or any valid 2d-`.obsm` key.\nUse precomputed coordinates for initialization.\nIf `False`/`None` (the default), initialize randomly.",
                "optional_value": false
            },
            "root": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Root for tree layouts.",
                "optional_value": false
            },
            "random_state": {
                "type": "Optional[Union[int, RandomState]]",
                "default": "0",
                "optional": true,
                "description": "For layouts with random initialization like 'fr', change this to use\ndifferent intial states for the optimization. If `None`, no seed is set.",
                "optional_value": false
            },
            "n_jobs": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Number of jobs for parallel computation.\n`None` means using :attr:`scanpy._settings.ScanpyConfig.n_jobs`.",
                "optional_value": false
            },
            "adjacency": {
                "type": "Optional[spmatrix]",
                "default": "None",
                "optional": true,
                "description": "Sparse adjacency matrix of the graph, defaults to neighbors connectivities.",
                "optional_value": true
            },
            "key_added_ext": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "By default, append `layout`.",
                "optional_value": false
            },
            "neighbors_key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "If not specified, draw_graph looks .obsp['connectivities'] for connectivities\n(default storage place for pp.neighbors).\nIf specified, draw_graph looks .obsp[.uns[neighbors_key]['connectivities_key']] for connectivities.",
                "optional_value": false
            },
            "obsp": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Use .obsp[obsp] as adjacency. You can't specify both `obsp` and `neighbors_key` at the same time.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to return a copy instead of writing to adata.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[AnnData]",
            "description": ""
        },
        "Docstring": "Force-directed graph drawing [Islam11]_ [Jacomy14]_ [Chippada18]_.\n\n.. _fa2: https://github.com/bhargavchippada/forceatlas2\n.. _Force-directed graph drawing: https://en.wikipedia.org/wiki/Force-directed_graph_drawing\n.. _fruchterman-reingold: http://igraph.org/python/doc/igraph.Graph-class.html#layout_fruchterman_reingold\n\nAn alternative to tSNE that often preserves the topology of the data\nbetter. This requires to run :func:`~ehrapy.pp.neighbors`, first.\nThe default layout ('fa', `ForceAtlas2`) [Jacomy14]_ uses the package `fa2`_\n[Chippada18]_, which can be installed via `pip install fa2`.\n`Force-directed graph drawing`_ describes a class of long-established\nalgorithms for visualizing graphs.\nIt has been suggested for visualizing single-cell data by [Islam11]_.\nMany other layouts as implemented in igraph [Csardi06]_ are available.\nSimilar approaches have been used by [Zunder15]_ or [Weinreb17]_.\n\nArgs:\n    adata: :class:`~anndata.AnnData` object object containing all observations.\n    layout: 'fa' (`ForceAtlas2`) or any valid `igraph layout\n            <http://igraph.org/c/doc/igraph-Layout.html>`__. Of particular interest\n            are 'fr' (Fruchterman Reingold), 'grid_fr' (Grid Fruchterman Reingold,\n            faster than 'fr'), 'kk' (Kamadi Kawai', slower than 'fr'), 'lgl' (Large\n            Graph, very fast), 'drl' (Distributed Recursive Layout, pretty fast) and\n            'rt' (Reingold Tilford tree layout).\n    init_pos: `'paga'`/`True`, `None`/`False`, or any valid 2d-`.obsm` key.\n              Use precomputed coordinates for initialization.\n              If `False`/`None` (the default), initialize randomly.\n    root: Root for tree layouts.\n    random_state: For layouts with random initialization like 'fr', change this to use\n                  different intial states for the optimization. If `None`, no seed is set.\n    n_jobs: Number of jobs for parallel computation.\n            `None` means using :attr:`scanpy._settings.ScanpyConfig.n_jobs`.\n    adjacency: Sparse adjacency matrix of the graph, defaults to neighbors connectivities.\n    key_added_ext: By default, append `layout`.\n    neighbors_key: If not specified, draw_graph looks .obsp['connectivities'] for connectivities\n                   (default storage place for pp.neighbors).\n                   If specified, draw_graph looks .obsp[.uns[neighbors_key]['connectivities_key']] for connectivities.\n    obsp:  Use .obsp[obsp] as adjacency. You can't specify both `obsp` and `neighbors_key` at the same time.\n    copy: Whether to return a copy instead of writing to adata.\n    **kwds: Parameters of chosen igraph layout. See e.g. `fruchterman-reingold`_\n            [Fruchterman91]_. One of the most important ones is `maxiter`.\n\nReturns:\n      Depending on `copy`, returns or updates `adata` with the following field.\n\n      **X_draw_graph_layout** : `adata.obsm`\n      Coordinates of graph layout. E.g. for layout='fa' (the default), the field is called 'X_draw_graph_fa'",
        "description": "Force-directed graph drawing [Islam11]_ [Jacomy14]_ [Chippada18]_... _fa2: https://github.com/bhargavchippada/forceatlas2\n.. _Force-directed graph drawing: https://en.wikipedia.org/wiki/Force-directed_graph_drawing\n.. _fruchterman-reingold: http://igraph.org/python/doc/igraph.Graph-class.html#layout_fruchterman_reingold\n\nAn alternative to tSNE that often preserves the topology of the data\nbetter. This requires to run :func:`~ehrapy.pp.neighbors`, first.\nThe default layout ('fa', `ForceAtlas2`) [Jacomy14]_ uses the package `fa2`_\n[Chippada18]_, which can be installed via `pip install fa2`.\n`Force-directed graph drawing`_ describes a class of long-established\nalgorithms for visualizing graphs.\nIt has been suggested for visualizing single-cell data by [Islam11]_.\nMany other layouts as implemented in igraph [Csardi06]_ are available.\nSimilar approaches have been used by [Zunder15]_ or [Weinreb17]_.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "ehrapy.tools.draw_graph(adata=$, layout=$, init_pos=@, root=@, random_state=@, n_jobs=@, adjacency=$, key_added_ext=@, neighbors_key=@, obsp=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.anndata.delete_from_obs": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "The AnnData object",
                "optional_value": true
            },
            "to_delete": {
                "type": "list[str]",
                "default": null,
                "optional": false,
                "description": "The columns to delete from obs",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": ""
        },
        "Docstring": "Delete features from obs.\n\nArgs:\n    adata: The AnnData object\n    to_delete: The columns to delete from obs\n\nReturns:\n    The original AnnData object with deleted columns from obs.\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.ad.move_to_obs(adata, ['age'], copy_obs=True)\n    >>> ep.ad.delete_from_obs(adata, ['age'])",
        "description": "Delete features from obs.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.ad.move_to_obs(adata, ['age'], copy_obs=True)\n    >>> ep.ad.delete_from_obs(adata, ['age'])",
        "api_type": "function",
        "api_calling": [
            "ehrapy.anndata.delete_from_obs(adata=$, to_delete=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.tools.paga": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object object containing all observations.",
                "optional_value": true
            },
            "groups": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Key for categorical in `adata.obs`. You can pass your predefined groups\nby choosing any categorical annotation of observations. Default:\nThe first present key of `'leiden'` or `'louvain'`.",
                "optional_value": false
            },
            "use_rna_velocity": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "model": {
                "type": "Literal[v1.2, v1.0]",
                "default": "v1.2",
                "optional": true,
                "description": "The PAGA connectivity model.",
                "optional_value": true
            },
            "neighbors_key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "If not specified, paga looks `.uns['neighbors']` for neighbors settings\nand `.obsp['connectivities']`, `.obsp['distances']` for connectivities and\ndistances respectively (default storage places for `pp.neighbors`).\nIf specified, paga looks `.uns[neighbors_key]` for neighbors settings and\n`.obsp[.uns[neighbors_key]['connectivities_key']]`,\n`.obsp[.uns[neighbors_key]['distances_key']]` for connectivities and distances respectively.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Copy `adata` before computation and return a copy. Otherwise, perform computation in place and return `None`.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[AnnData]",
            "description": ""
        },
        "Docstring": "Mapping out the coarse-grained connectivity structures of complex manifolds [Wolf19]_.\n\nBy quantifying the connectivity of partitions (groups, clusters),\npartition-based graph abstraction (PAGA) generates a much\nsimpler abstracted graph (*PAGA graph*) of partitions, in which edge weights\nrepresent confidence in the presence of connections. By tresholding this\nconfidence in :func:`~ehrapy.pl.paga`, a much simpler representation of the\nmanifold data is obtained, which is nonetheless faithful to the topology of\nthe manifold.\nThe confidence should be interpreted as the ratio of the actual versus the\nexpected value of connections under the null model of randomly connecting\npartitions. We do not provide a p-value as this null model does not\nprecisely capture what one would consider \"connected\" in real data, hence it\nstrongly overestimates the expected value. See an extensive discussion of this in [Wolf19]_.\n\n.. note::\n    Note that you can use the result of :func:`~ehrapy.pl.paga` in\n    :func:`~ehrapy.tl.umap` and :func:`~ehrapy.tl.draw_graph` via\n    `init_pos='paga'` to get embeddings that are typically more faithful to the global topology.\n\nArgs:\n    adata: :class:`~anndata.AnnData` object object containing all observations.\n    groups: Key for categorical in `adata.obs`. You can pass your predefined groups\n            by choosing any categorical annotation of observations. Default:\n            The first present key of `'leiden'` or `'louvain'`.\n    model: The PAGA connectivity model.\n    neighbors_key: If not specified, paga looks `.uns['neighbors']` for neighbors settings\n                   and `.obsp['connectivities']`, `.obsp['distances']` for connectivities and\n                   distances respectively (default storage places for `pp.neighbors`).\n                   If specified, paga looks `.uns[neighbors_key]` for neighbors settings and\n                   `.obsp[.uns[neighbors_key]['connectivities_key']]`,\n                   `.obsp[.uns[neighbors_key]['distances_key']]` for connectivities and distances respectively.\n    copy: Copy `adata` before computation and return a copy. Otherwise, perform computation in place and return `None`.\n\nReturns:\n    **connectivities** :class:`numpy.ndarray` (adata.uns['connectivities'])\n    The full adjacency matrix of the abstracted graph, weights correspond to confidence in the connectivities of partitions.\n\n   **connectivities_tree** :class:`scipy.sparse.csr_matrix` (adata.uns['connectivities_tree'])\n    The adjacency matrix of the tree-like subgraph that best explains the topology.\n\nNotes:\nTogether with a random walk-based distance measure (e.g. :func:`ehrapy.tl.dpt`)\nthis generates a partial coordinatization of data useful for exploring and explaining its variation.",
        "description": "Mapping out the coarse-grained connectivity structures of complex manifolds [Wolf19]_.By quantifying the connectivity of partitions (groups, clusters),\npartition-based graph abstraction (PAGA) generates a much\nsimpler abstracted graph (*PAGA graph*) of partitions, in which edge weights\nrepresent confidence in the presence of connections. By tresholding this\nconfidence in :func:`~ehrapy.pl.paga`, a much simpler representation of the\nmanifold data is obtained, which is nonetheless faithful to the topology of\nthe manifold.\nThe confidence should be interpreted as the ratio of the actual versus the\nexpected value of connections under the null model of randomly connecting\npartitions. We do not provide a p-value as this null model does not\nprecisely capture what one would consider \"connected\" in real data, hence it\nstrongly overestimates the expected value. See an extensive discussion of this in [Wolf19]_.\n\n.. note::\n    Note that you can use the result of :func:`~ehrapy.pl.paga` in\n    :func:`~ehrapy.tl.umap` and :func:`~ehrapy.tl.draw_graph` via\n    `init_pos='paga'` to get embeddings that are typically more faithful to the global topology.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "ehrapy.tools.paga(adata=$, groups=@, use_rna_velocity=@, model=$, neighbors_key=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.plot.missing_values_barplot": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object object containing all observations.",
                "optional_value": true
            },
            "log": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether or not to display a logarithmic plot.",
                "optional_value": false
            },
            "filter": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "The filter to apply to the barplot. Should be one of \"top\", \"bottom\", or None. Defaults to None .",
                "optional_value": false
            },
            "max_cols": {
                "type": "int",
                "default": "0",
                "optional": true,
                "description": "The max number of columns from the AnnData object to include.",
                "optional_value": false
            },
            "max_percentage": {
                "type": "float",
                "default": "0",
                "optional": true,
                "description": "The max percentage fill of the columns from the AnnData object.",
                "optional_value": false
            },
            "sort": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "The row sort order to apply. Can be \"ascending\", \"descending\", or None.",
                "optional_value": false
            },
            "figsize": {
                "type": "Optional[tuple]",
                "default": "None",
                "optional": true,
                "description": "The size of the figure to display.",
                "optional_value": false
            },
            "color": {
                "type": "str",
                "default": "dimgray",
                "optional": true,
                "description": "The color of the filled columns.",
                "optional_value": false
            },
            "fontsize": {
                "type": "float",
                "default": "16",
                "optional": true,
                "description": "The figure's font size.",
                "optional_value": false
            },
            "labels": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Whether or not to display the column names.",
                "optional_value": false
            },
            "label_rotation": {
                "type": "float",
                "default": "45",
                "optional": true,
                "description": "What angle to rotate the text labels to.",
                "optional_value": false
            },
            "orientation": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "The way the bar plot is oriented.",
                "optional_value": false
            },
            "categoricals": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to include \"ehrapycat\" columns to the plot.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "A bar chart visualization of the nullity of the given AnnData object.\n\nArgs:\n    adata: :class:`~anndata.AnnData` object object containing all observations.\n    log: Whether or not to display a logarithmic plot.\n    filter: The filter to apply to the barplot. Should be one of \"top\", \"bottom\", or None. Defaults to None .\n    max_cols: The max number of columns from the AnnData object to include.\n    max_percentage: The max percentage fill of the columns from the AnnData object.\n    sort: The row sort order to apply. Can be \"ascending\", \"descending\", or None.\n    figsize: The size of the figure to display.\n    color: The color of the filled columns.\n    fontsize: The figure's font size.\n    labels: Whether or not to display the column names.\n    label_rotation: What angle to rotate the text labels to.\n    orientation: The way the bar plot is oriented.\n    categoricals: Whether to include \"ehrapycat\" columns to the plot.\n\nReturns:\n    The plot axis.\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.data.mimic_2(encoded=True)\n    >>> ep.pl.missing_values_barplot(adata, filter='bottom', max_cols=15, max_percentage=0.999)\n\nPreview:\n    .. image:: /_static/docstring_previews/missingno_barplot.png",
        "description": "A bar chart visualization of the nullity of the given AnnData object.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.data.mimic_2(encoded=True)\n    >>> ep.pl.missing_values_barplot(adata, filter='bottom', max_cols=15, max_percentage=0.999)\n\nPreview:\n    .. image:: /_static/docstring_previews/missingno_barplot.png",
        "api_type": "function",
        "api_calling": [
            "ehrapy.plot.missing_values_barplot(adata=$, log=@, filter=@, max_cols=@, max_percentage=@, sort=@, figsize=@, color=@, fontsize=@, labels=@, label_rotation=@, orientation=@, categoricals=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.plot.rank_features_groups_stacked_violin": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "groups": {
                "type": "Union[str, Sequence[str]]",
                "default": "None",
                "optional": true,
                "description": "List of group names.",
                "optional_value": false
            },
            "n_features": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Number of features to show. Is ignored if `feature_names` is passed.",
                "optional_value": false
            },
            "groupby": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Which key to group the features by.",
                "optional_value": false
            },
            "feature_symbols": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Key for field in `.var` that stores feature symbols if you do not want to\nuse `.var_names` displayed in the plot.",
                "optional_value": false
            },
            "var_names": {
                "type": "Optional[Union[Sequence[str], Mapping[str, Sequence[str]]]]",
                "default": "None",
                "optional": true,
                "description": "Feature names.",
                "optional_value": false
            },
            "min_logfoldchange": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Minimum log fold change to consider.",
                "optional_value": false
            },
            "key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "The key of the calculated feature group rankings (default: 'rank_features_groups').",
                "optional_value": false
            },
            "show": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Whether to show the plot.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "Where to save the plot.",
                "optional_value": false
            },
            "return_fig": {
                "type": "Optional[bool]",
                "default": "False",
                "optional": true,
                "description": "Returns :class:`StackedViolin` object. Useful for fine-tuning the plot.\nTakes precedence over `show=False`.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Plot ranking of genes using stacked_violin plot.\n\nArgs:\n    adata: Annotated data matrix.\n    groups: List of group names.\n    n_features: Number of features to show. Is ignored if `feature_names` is passed.\n    groupby: Which key to group the features by.\n    feature_symbols: Key for field in `.var` that stores feature symbols if you do not want to\n                     use `.var_names` displayed in the plot.\n    var_names: Feature names.\n    min_logfoldchange: Minimum log fold change to consider.\n    key: The key of the calculated feature group rankings (default: 'rank_features_groups').\n    show: Whether to show the plot.\n    save: Where to save the plot.\n    return_fig: Returns :class:`StackedViolin` object. Useful for fine-tuning the plot.\n                Takes precedence over `show=False`.\n\nReturns:\n    If `return_fig` is `True`, returns a :class:`StackedViolin` object,\n    else if `show` is false, return axes dict\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.knn_impute(adata)\n    >>> ep.pp.log_norm(adata, offset=1)\n    >>> ep.pp.neighbors(adata)\n    >>> ep.tl.leiden(adata, resolution=0.15, key_added=\"leiden_0_5\")\n    >>> ep.tl.rank_features_groups(adata, groupby=\"leiden_0_5\")\n    >>> ep.pl.rank_features_groups_stacked_violin(adata, key=\"rank_features_groups\", n_features=5)\n\nPreview:\n    .. image:: /_static/docstring_previews/rank_features_groups_stacked_violin.png",
        "description": "Plot ranking of genes using stacked_violin plot.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.knn_impute(adata)\n    >>> ep.pp.log_norm(adata, offset=1)\n    >>> ep.pp.neighbors(adata)\n    >>> ep.tl.leiden(adata, resolution=0.15, key_added=\"leiden_0_5\")\n    >>> ep.tl.rank_features_groups(adata, groupby=\"leiden_0_5\")\n    >>> ep.pl.rank_features_groups_stacked_violin(adata, key=\"rank_features_groups\", n_features=5)\n\nPreview:\n    .. image:: /_static/docstring_previews/rank_features_groups_stacked_violin.png",
        "api_type": "function",
        "api_calling": [
            "ehrapy.plot.rank_features_groups_stacked_violin(adata=$, groups=@, n_features=@, groupby=@, feature_symbols=@, var_names=@, min_logfoldchange=@, key=@, show=@, save=@, return_fig=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.plot.diffmap": {
        "Parameters": {
            "adata": {
                "type": null,
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object object containing all observations.",
                "optional_value": true
            }
        },
        "Returns": {
            "type": "Optional[Union[Axes, list[Axes]]]",
            "description": ""
        },
        "Docstring": "Scatter plot in Diffusion Map basis.\n\nArgs:\n    adata: :class:`~anndata.AnnData` object object containing all observations.\n    color: Keys for annotations of observations/patients or features, e.g., `'ann1'` or `['ann1', 'ann2']`.\n    feature_symbols: Column name in `.var` DataFrame that stores feature symbols. By default `var_names`\n                     refer to the index column of the `.var` DataFrame. Setting this option allows alternative names to be used.\n    use_raw: Use `.raw` attribute of `adata` for coloring with feature values. If `None`,\n             defaults to `True` if `layer` isn't provided and `adata.raw` is present.\n    layer: Name of the AnnData object layer that wants to be plotted. By default\n           adata.raw.X is plotted. If `use_raw=False` is set, then `adata.X` is plotted.\n           If `layer` is set to a valid layer name, then the layer is plotted. `layer` takes precedence over `use_raw`.\n    sort_order: For continuous annotations used as color parameter, plot data points with higher values on top of others.\n    groups: Restrict to a few categories in categorical observation annotation.\n            The default is not to restrict to any groups.\n    components: For instance, `['1,2', '2,3']`. To plot all available components use `components='all'`.\n    projection: Projection of plot (default: `'2d'`).\n    legend_loc: Location of legend, either `'on data'`, `'right margin'` or a valid keyword for the `loc` parameter of :class:`~matplotlib.legend.Legend`.\n    legend_fontsize: Numeric size in pt or string describing the size. See :meth:`~matplotlib.text.Text.set_fontsize`.\n    legend_fontweight: Legend font weight. A numeric value in range 0-1000 or a string.\n                       Defaults to `'bold'` if `legend_loc == 'on data'`, otherwise to `'normal'`.\n                       See :meth:`~matplotlib.text.Text.set_fontweight`.\n    legend_fontoutline: Line width of the legend font outline in pt. Draws a white outline using the path effect :class:`~matplotlib.patheffects.withStroke`.\n    size: Point size. If `None`, is automatically computed as 120000 / n_features.\n          Can be a sequence containing the size for each observation. The order should be the same as in adata.obs.\n    color_map: Color map to use for continous variables. Can be a name or a\n               :class:`~matplotlib.colors.Colormap` instance (e.g. `\"magma`\", `\"viridis\"`\n               or `mpl.cm.cividis`), see :func:`~matplotlib.cm.get_cmap`.\n               If `None`, the value of `mpl.rcParams[\"image.cmap\"]` is used.\n               The default `color_map` can be set using :func:`~scanpy.set_figure_params`.\n    palette: Colors to use for plotting categorical annotation groups.\n             The palette can be a valid :class:`~matplotlib.colors.ListedColormap` name\n             (`'Set2'`, `'tab20'`, \u2026), a :class:`~cycler.Cycler` object, a dict mapping\n             categories to colors, or a sequence of colors. Colors must be valid to\n             matplotlib. (see :func:`~matplotlib.colors.is_color_like`).\n             If `None`, `mpl.rcParams[\"axes.prop_cycle\"]` is used unless the categorical\n             variable already has colors stored in `adata.uns[\"{var}_colors\"]`.\n             If provided, values of `adata.uns[\"{var}_colors\"]` will be set.\n    na_color: Color to use for null or masked values. Can be anything matplotlib accepts as a color.\n              Used for all points if `color=None`.\n    na_in_legend: If there are missing values, whether they get an entry in the legend.\n                  Currently only implemented for categorical legends.\n    frameon: Draw a frame around the scatter plot. Defaults to value set in :func:`~scanpy.set_figure_params` (default: True).\n    title: Provide title for panels either as string or list of strings, e.g. `['title1', 'title2', ...]`.\n    vmin: The value representing the lower limit of the color scale. Values smaller than vmin are plotted\n          with the same color as vmin. vmin can be a number, a string, a function or `None`. If\n          vmin is a string and has the format `pN`, this is interpreted as a vmin=percentile(N).\n          For example vmin='p1.5' is interpreted as the 1.5 percentile. If vmin is function, then\n          vmin is interpreted as the return value of the function over the list of values to plot.\n          For example to set vmin tp the mean of the values to plot, `def my_vmin(values): return\n          np.mean(values)` and then set `vmin=my_vmin`. If vmin is None (default) an automatic\n          minimum value is used as defined by matplotlib `scatter` function. When making multiple\n          plots, vmin can be a list of values, one for each plot. For example `vmin=[0.1, 'p1', None, my_vmin]`\n    vmax: The value representing the upper limit of the color scale. The format is the same as for `vmin`.\n    vcenter: The value representing the center of the color scale. Useful for diverging colormaps.\n             The format is the same as for `vmin`.\n             Example: sc.pl.umap(adata, color='TREM2', vcenter='p50', cmap='RdBu_r')\n    add_outline: If set to True, this will add a thin border around groups of dots. In some situations\n                 this can enhance the aesthetics of the resulting image\n    outline_color: Tuple with two valid color names used to adjust the add_outline. The first color is the\n                   border color (default: black), while the second color is a gap color between the\n                   border color and the scatter dot (default: white).\n    outline_width: Tuple with two width numbers used to adjust the outline. The first value is the width\n                   of the border color as a fraction of the scatter dot size (default: 0.3). The second value is\n                   width of the gap color (default: 0.05).\n    ncols: Number of panels per row.\n           wspace: Adjust the width of the space between multiple panels.\n           hspace: Adjust the height of the space between multiple panels.\n           return_fig: Return the matplotlib figure.\n    kwargs: Arguments to pass to :func:`matplotlib.pyplot.scatter`,\n            for instance: the maximum and minimum values (e.g. `vmin=-2, vmax=5`).\n    show: Whether to display the figure or return axis.\n    save: If `True` or a `str`, save the figure.\n          A string is appended to the default filename.\n          Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.\n    ax: A matplotlib axes object. Only works if plotting a single component.\n\nReturns:\n    If `show==False` a :class:`~matplotlib.axes.Axes` or a list of it.\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.knn_impute(adata)\n    >>> ep.pp.log_norm(adata, offset=1)\n    >>> ep.pp.neighbors(adata)\n    >>> ep.tl.diffmap(adata)\n    >>> ep.pl.diffmap(adata, color='day_icu_intime')\n\nPreview:\n    .. image:: /_static/docstring_previews/diffmap.png",
        "description": "Scatter plot in Diffusion Map basis.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.pp.knn_impute(adata)\n    >>> ep.pp.log_norm(adata, offset=1)\n    >>> ep.pp.neighbors(adata)\n    >>> ep.tl.diffmap(adata)\n    >>> ep.pl.diffmap(adata, color='day_icu_intime')\n\nPreview:\n    .. image:: /_static/docstring_previews/diffmap.png",
        "api_type": "function",
        "api_calling": [
            "ehrapy.plot.diffmap(adata=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.data.breast_cancer_coimbra": {
        "Parameters": {
            "encoded": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to return an already encoded object.",
                "optional_value": false
            },
            "columns_obs_only": {
                "type": "Optional[Union[dict[str, list[str]], list[str]]]",
                "default": "None",
                "optional": true,
                "description": "Columns to include in obs only and not X.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": ""
        },
        "Docstring": "Loads the Breast Cancer Coimbra Data Set\n\nMore details: http://archive.ics.uci.edu/ml/datasets/Breast+Cancer+Coimbra\nPreprocessing: https://github.com/theislab/ehrapy-datasets/blob/main/breast_cancer_coimbra/breast_cancer_coimbra.ipynb\n\nArgs:\n    encoded: Whether to return an already encoded object.\n    columns_obs_only: Columns to include in obs only and not X.\n\nReturns:\n    :class:`~anndata.AnnData` object of the Breast Cancer Coimbra Data Set\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.breast_cancer_coimbra(encoded=True)",
        "description": "Loads the Breast Cancer Coimbra Data SetMore details: http://archive.ics.uci.edu/ml/datasets/Breast+Cancer+Coimbra\nPreprocessing: https://github.com/theislab/ehrapy-datasets/blob/main/breast_cancer_coimbra/breast_cancer_coimbra.ipynb",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.breast_cancer_coimbra(encoded=True)",
        "api_type": "function",
        "api_calling": [
            "ehrapy.data.breast_cancer_coimbra(encoded=@, columns_obs_only=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.preprocessing.undo_encoding": {
        "Parameters": {
            "data": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "The :class:`~anndata.AnnData` object",
                "optional_value": true
            },
            "columns": {
                "type": "str",
                "default": "all",
                "optional": true,
                "description": "The names of the columns to reset encoding for. Defaults to all columns.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[AnnData]",
            "description": ""
        },
        "Docstring": "Undo the current encodings applied to all columns in X.\n\nThis currently resets the AnnData object to its initial state.\n\nArgs:\n    data: The :class:`~anndata.AnnData` object\n    columns: The names of the columns to reset encoding for. Defaults to all columns.\n\nReturns:\n    A (partially) encoding reset :class:`~anndata.AnnData`\n\nExamples:\n    >>> import ehrapy as ep\n    >>> # adata_encoded is an encoded AnnData object\n    >>> adata_undone = ep.pp.encode.undo_encoding(adata_encoded)",
        "description": "Undo the current encodings applied to all columns in X.This currently resets the AnnData object to its initial state.",
        "example": ">>> import ehrapy as ep\n    >>> # adata_encoded is an encoded AnnData object\n    >>> adata_undone = ep.pp.encode.undo_encoding(adata_encoded)",
        "api_type": "function",
        "api_calling": [
            "ehrapy.preprocessing.undo_encoding(data=$, columns=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.plot.paga_compare": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object object containing all observations.",
                "optional_value": true
            },
            "basis": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "String that denotes a plotting tool that computed coordinates.",
                "optional_value": true
            },
            "edges": {
                "type": null,
                "default": "False",
                "optional": true,
                "description": "Whether to display edges.",
                "optional_value": true
            },
            "color": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "Keys for annotations of observations/patients or features, or a hex color specification, e.g.,\n`'ann1'`, `'#fe57a1'`, or `['ann1', 'ann2']`.",
                "optional_value": true
            },
            "alpha": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "Alpha value for the image",
                "optional_value": true
            },
            "groups": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "Key of the grouping used to run PAGA. If `None`, defaults to `adata.uns['paga']['groups']`.",
                "optional_value": true
            },
            "components": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "For example, ``'1,2,3'`` means ``[1, 2, 3]``, first, second, third principal component.",
                "optional_value": true
            },
            "projection": {
                "type": "Literal['2d', '3d']",
                "default": "2d",
                "optional": true,
                "description": "One of '2d' or '3d'",
                "optional_value": true
            },
            "legend_loc": {
                "type": null,
                "default": "on data",
                "optional": true,
                "description": "Location of the legend.",
                "optional_value": true
            },
            "legend_fontsize": {
                "type": "Optional[Union[int, float, _FontSize]]",
                "default": "None",
                "optional": true,
                "description": "Font size of the legend.",
                "optional_value": false
            },
            "legend_fontweight": {
                "type": "Union[int, _FontWeight]",
                "default": "bold",
                "optional": true,
                "description": "Font weight of the legend.",
                "optional_value": false
            },
            "legend_fontoutline": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "Font outline of the legend.",
                "optional_value": true
            },
            "color_map": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "Matplotlib color map.",
                "optional_value": true
            },
            "palette": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "Matplotlib color palette.",
                "optional_value": true
            },
            "frameon": {
                "type": null,
                "default": "False",
                "optional": true,
                "description": "Whether to display the labels frameon.",
                "optional_value": true
            },
            "size": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "Size of the plot.",
                "optional_value": true
            },
            "title": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "Title of the plot.",
                "optional_value": true
            },
            "right_margin": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "Margin to the right of the plot.",
                "optional_value": true
            },
            "left_margin": {
                "type": null,
                "default": "0.05",
                "optional": true,
                "description": "Margin to the left of the plot.",
                "optional_value": true
            },
            "show": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "Whether to show the plot.",
                "optional_value": true
            },
            "save": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "Whether or where to save the plot.",
                "optional_value": true
            },
            "title_graph": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "The title of the graph.",
                "optional_value": true
            },
            "groups_graph": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "Graph labels.",
                "optional_value": true
            },
            "pos": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "Position of the plot.",
                "optional_value": true
            },
            "paga_graph_params": {
                "type": null,
                "default": null,
                "optional": false,
                "description": "",
                "optional_value": true
            }
        },
        "Returns": {
            "type": "Optional[Axes]",
            "description": ""
        },
        "Docstring": "Scatter and PAGA graph side-by-side.\n\nConsists in a scatter plot and the abstracted graph. See :func:`~ehrapy.pl.paga` for all related parameters.\n\nArgs:\n    adata: :class:`~anndata.AnnData` object object containing all observations.\n    basis: String that denotes a plotting tool that computed coordinates.\n    edges: Whether to display edges.\n    color: Keys for annotations of observations/patients or features, or a hex color specification, e.g.,\n           `'ann1'`, `'#fe57a1'`, or `['ann1', 'ann2']`.\n    alpha: Alpha value for the image\n    groups: Key of the grouping used to run PAGA. If `None`, defaults to `adata.uns['paga']['groups']`.\n    components: For example, ``'1,2,3'`` means ``[1, 2, 3]``, first, second, third principal component.\n    projection: One of '2d' or '3d'\n    legend_loc: Location of the legend.\n    legend_fontsize: Font size of the legend.\n    legend_fontweight: Font weight of the legend.\n    legend_fontoutline: Font outline of the legend.\n    color_map: Matplotlib color map.\n    palette: Matplotlib color palette.\n    frameon: Whether to display the labels frameon.\n    size: Size of the plot.\n    title: Title of the plot.\n    right_margin: Margin to the right of the plot.\n    left_margin: Margin to the left of the plot.\n    show: Whether to show the plot.\n    save: Whether or where to save the plot.\n    title_graph: The title of the graph.\n    groups_graph: Graph labels.\n    pos: Position of the plot.\n    **paga_graph_params: Keywords for :func:`~ehrapy.pl.paga` and keywords for :func:`~ehrapy.pl.scatter`.\n\nReturns:\n    Matplotlib axes.",
        "description": "Scatter and PAGA graph side-by-side.Consists in a scatter plot and the abstracted graph. See :func:`~ehrapy.pl.paga` for all related parameters.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "ehrapy.plot.paga_compare(adata=$, basis=$, edges=$, color=$, alpha=$, groups=$, components=$, projection=$, legend_loc=$, legend_fontsize=@, legend_fontweight=@, legend_fontoutline=$, color_map=$, palette=$, frameon=$, size=$, title=$, right_margin=$, left_margin=$, show=$, save=$, title_graph=$, groups_graph=$, pos=$, paga_graph_params=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.tools.diffmap": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object object containing all observations.",
                "optional_value": true
            },
            "n_comps": {
                "type": "int",
                "default": "15",
                "optional": true,
                "description": "The number of dimensions of the representation.\nneighbors_key: If not specified, diffmap looks .uns['neighbors'] for neighbors settings\nand .obsp['connectivities'], .obsp['distances'] for connectivities and\ndistances respectively (default storage places for pp.neighbors).\nIf specified, diffmap looks .uns[neighbors_key] for neighbors settings and\n.obsp[.uns[neighbors_key]['connectivities_key']],\n.obsp[.uns[neighbors_key]['distances_key']] for connectivities and distances respectively.",
                "optional_value": false
            },
            "neighbors_key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "random_state": {
                "type": "Optional[Union[int, RandomState]]",
                "default": "0",
                "optional": true,
                "description": "Random seed for the initialization.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to return a copy of the :class:`~anndata.AnnData` object.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[AnnData]",
            "description": ""
        },
        "Docstring": "Diffusion Maps [Coifman05]_ [Haghverdi15]_ [Wolf18]_.\n\nDiffusion maps [Coifman05]_ has been proposed for visualizing single-cell\ndata by [Haghverdi15]_. The tool uses the adapted Gaussian kernel suggested\nby [Haghverdi16]_ in the implementation of [Wolf18]_.\nThe width (\"sigma\") of the connectivity kernel is implicitly determined by\nthe number of neighbors used to compute the single-cell graph in\n:func:`~ehrapy.pp.neighbors`. To reproduce the original implementation\nusing a Gaussian kernel, use `method=='gauss'` in\n:func:`~ehrapy.pp.neighbors`. To use an exponential kernel, use the default\n`method=='umap'`. Differences between these options shouldn't usually be dramatic.\n\nArgs:\n    adata: :class:`~anndata.AnnData` object object containing all observations.\n    n_comps: The number of dimensions of the representation.\n             neighbors_key: If not specified, diffmap looks .uns['neighbors'] for neighbors settings\n             and .obsp['connectivities'], .obsp['distances'] for connectivities and\n             distances respectively (default storage places for pp.neighbors).\n             If specified, diffmap looks .uns[neighbors_key] for neighbors settings and\n             .obsp[.uns[neighbors_key]['connectivities_key']],\n             .obsp[.uns[neighbors_key]['distances_key']] for connectivities and distances respectively.\n    random_state: Random seed for the initialization.\n    copy: Whether to return a copy of the :class:`~anndata.AnnData` object.\n\nReturns:\n    Depending on `copy`, returns or updates `adata` with the following fields.\n\n    `X_diffmap` : :class:`numpy.ndarray` (`adata.obsm`)\n    Diffusion map representation of data, which is the right eigen basis of the transition matrix with eigenvectors as columns.\n\n    `diffmap_evals` : :class:`numpy.ndarray` (`adata.uns`)\n    Array of size (number of eigen vectors). Eigenvalues of transition matrix.",
        "description": "Diffusion Maps [Coifman05]_ [Haghverdi15]_ [Wolf18]_.Diffusion maps [Coifman05]_ has been proposed for visualizing single-cell\ndata by [Haghverdi15]_. The tool uses the adapted Gaussian kernel suggested\nby [Haghverdi16]_ in the implementation of [Wolf18]_.\nThe width (\"sigma\") of the connectivity kernel is implicitly determined by\nthe number of neighbors used to compute the single-cell graph in\n:func:`~ehrapy.pp.neighbors`. To reproduce the original implementation\nusing a Gaussian kernel, use `method=='gauss'` in\n:func:`~ehrapy.pp.neighbors`. To use an exponential kernel, use the default\n`method=='umap'`. Differences between these options shouldn't usually be dramatic.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "ehrapy.tools.diffmap(adata=$, n_comps=@, neighbors_key=@, random_state=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.preprocessing.power_norm": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": ":class:`~anndata.AnnData` object containing X to normalize values in.\nMust already be encoded using :func:`~ehrapy.preprocessing.encode`.",
                "optional_value": true
            },
            "vars": {
                "type": "Optional[Union[str, Sequence[str]]]",
                "default": "None",
                "optional": true,
                "description": "List of the names of the numeric variables to normalize.\nIf None all numeric variables will be normalized. Defaults to None .",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to return a copy or act in place. Defaults to False .",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[AnnData]",
            "description": ""
        },
        "Docstring": "Apply power transformation normalization.\n\nFunctionality is provided by :func:`~sklearn.preprocessing.power_transform`,\nsee https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.power_transform.html for details.\n\nArgs:\n    adata: :class:`~anndata.AnnData` object containing X to normalize values in.\n           Must already be encoded using :func:`~ehrapy.preprocessing.encode`.\n    vars: List of the names of the numeric variables to normalize.\n          If None all numeric variables will be normalized. Defaults to None .\n    copy: Whether to return a copy or act in place. Defaults to False .\n    **kwargs: Additional arguments passed to :func:`~sklearn.preprocessing.power_transform`\n\nReturns:\n    :class:`~anndata.AnnData` object with normalized X.\n    Also stores a record of applied normalizations as a dictionary in adata.uns[\"normalization\"].\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> adata_norm = ep.pp.power_norm(adata, copy=True)",
        "description": "Apply power transformation normalization.Functionality is provided by :func:`~sklearn.preprocessing.power_transform`,\nsee https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.power_transform.html for details.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> adata_norm = ep.pp.power_norm(adata, copy=True)",
        "api_type": "function",
        "api_calling": [
            "ehrapy.preprocessing.power_norm(adata=$, vars=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.io.read_h5ad": {
        "Parameters": {
            "dataset_path": {
                "type": "Union[Path, str]",
                "default": null,
                "optional": false,
                "description": "Path to the file or directory to read.",
                "optional_value": false
            },
            "backup_url": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "URL to download the data file(s) from if not yet existing.",
                "optional_value": false
            },
            "download_dataset_name": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Name of the file or directory in case the dataset is downloaded",
                "optional_value": false
            },
            "archive_format": {
                "type": "Literal['zip', 'tar', 'tar.gz', 'tgz']",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            }
        },
        "Returns": {
            "type": "Union[AnnData, dict[str, AnnData]]",
            "description": ""
        },
        "Docstring": "Reads or downloads a desired directory of h5ad files or a single h5ad file.\n\nArgs:\n    dataset_path: Path to the file or directory to read.\n    download_dataset_name: Name of the file or directory in case the dataset is downloaded\n    backup_url: URL to download the data file(s) from if not yet existing.\n\nReturns:\n    An :class:`~anndata.AnnData` object or a dict with an identifier (the filename, without extension)\n    for each :class:`~anndata.AnnData` object in the dict\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.io.write(\"mimic_2.h5ad\", adata)\n    >>> adata_2 = ep.io.read_h5ad(\"mimic_2.h5ad\")",
        "description": "Reads or downloads a desired directory of h5ad files or a single h5ad file.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=True)\n    >>> ep.io.write(\"mimic_2.h5ad\", adata)\n    >>> adata_2 = ep.io.read_h5ad(\"mimic_2.h5ad\")",
        "api_type": "function",
        "api_calling": [
            "ehrapy.io.read_h5ad(dataset_path=@, backup_url=@, download_dataset_name=@, archive_format=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "ehrapy.tools.ols": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "The AnnData object for the OLS model.",
                "optional_value": true
            },
            "var_names": {
                "type": "Optional[list[str]]",
                "default": "None",
                "optional": true,
                "description": "A list of var names indicating which columns are for the OLS model.",
                "optional_value": false
            },
            "formula": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "The formula specifying the model.",
                "optional_value": false
            },
            "missing": {
                "type": "Optional[Literal['none', 'drop', 'raise']]",
                "default": "none",
                "optional": true,
                "description": "Available options are 'none', 'drop', and 'raise'. If 'none', no nan checking is done. If 'drop', any observations with nans are dropped. If 'raise', an error is raised. Default is 'none'.",
                "optional_value": true
            }
        },
        "Returns": {
            "type": "sm.OLS",
            "description": ""
        },
        "Docstring": "Create a Ordinary Least Squares (OLS) Model from a formula and AnnData.\n\nSee https://www.statsmodels.org/stable/generated/statsmodels.formula.api.ols.html#statsmodels.formula.api.ols\nInternally use the statsmodel to create a OLS Model from a formula and dataframe.\n\nArgs:\n    adata: The AnnData object for the OLS model.\n    var_names: A list of var names indicating which columns are for the OLS model.\n    formula: The formula specifying the model.\n    missing: Available options are 'none', 'drop', and 'raise'. If 'none', no nan checking is done. If 'drop', any observations with nans are dropped. If 'raise', an error is raised. Default is 'none'.\n\nReturns:\n    The OLS model instance.\n\nExamples:\n    >>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=False)\n    >>> formula = 'tco2_first ~ pco2_first'\n    >>> var_names = ['tco2_first', 'pco2_first']\n    >>> ols = ep.tl.ols(adata, var_names, formula, missing = 'drop')",
        "description": "Create a Ordinary Least Squares (OLS) Model from a formula and AnnData.See https://www.statsmodels.org/stable/generated/statsmodels.formula.api.ols.html#statsmodels.formula.api.ols\nInternally use the statsmodel to create a OLS Model from a formula and dataframe.",
        "example": ">>> import ehrapy as ep\n    >>> adata = ep.dt.mimic_2(encoded=False)\n    >>> formula = 'tco2_first ~ pco2_first'\n    >>> var_names = ['tco2_first', 'pco2_first']\n    >>> ols = ep.tl.ols(adata, var_names, formula, missing = 'drop')",
        "api_type": "function",
        "api_calling": [
            "ehrapy.tools.ols(adata=$, var_names=@, formula=@, missing=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    }
}
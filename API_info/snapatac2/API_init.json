{
    "snapatac2.pl.umap": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "color": {
                "type": "Optional[Union[str, np.ndarray]]",
                "default": "None",
                "optional": true,
                "description": "If the input is a string, it will be used the key to retrieve values from\n`obs`.",
                "optional_value": false
            },
            "use_rep": {
                "type": "str",
                "default": "X_umap",
                "optional": true,
                "description": "Use the indicated representation in `.obsm`.",
                "optional_value": false
            },
            "marker_size": {
                "type": "float",
                "default": "None",
                "optional": true,
                "description": "Size of the dots.",
                "optional_value": false
            },
            "marker_opacity": {
                "type": "float",
                "default": "1",
                "optional": true,
                "description": "Opacity of the dots.",
                "optional_value": false
            },
            "sample_size": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "If the number of cells is larger than `sample_size`, a random sample of\n`sample_size` cells will be used for plotting.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional['plotly.graph_objects.Figure']",
            "description": "'plotly.graph_objects.Figure' | None\nIf `show=False` and `out_file=None`, an `plotly.graph_objects.Figure` will be\nreturned, which can then be further customized using the plotly API."
        },
        "Docstring": "Plot the UMAP embedding.\n\nParameters\n----------\nadata\n    Annotated data matrix.\ncolor\n    If the input is a string, it will be used the key to retrieve values from\n    `obs`.\nuse_rep\n    Use the indicated representation in `.obsm`.\nmarker_size\n    Size of the dots.\nmarker_opacity\n    Opacity of the dots.\nsample_size\n    If the number of cells is larger than `sample_size`, a random sample of\n    `sample_size` cells will be used for plotting.\nkwargs        \n    Additional arguments passed to :func:`~snapatac2.pl.render_plot` to\n    control the final plot output. Please see :func:`~snapatac2.pl.render_plot`\n    for details.\n\nReturns\n-------\n'plotly.graph_objects.Figure' | None\n    If `show=False` and `out_file=None`, an `plotly.graph_objects.Figure` will be \n    returned, which can then be further customized using the plotly API.",
        "description": "Plot the UMAP embedding.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "snapatac2.pl.umap(adata=$, color=@, use_rep=@, marker_size=@, marker_opacity=@, sample_size=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.pp.make_gene_matrix": {
        "Parameters": {
            "adata": {
                "type": "Union[internal.AnnData, internal.AnnDataSet]",
                "default": null,
                "optional": false,
                "description": "The (annotated) data matrix of shape `n_obs` x `n_vars`.\nRows correspond to cells and columns to regions.",
                "optional_value": false
            },
            "gene_anno": {
                "type": "Union[Genome, Path]",
                "default": null,
                "optional": false,
                "description": "Either a Genome object or the path of a gene annotation file in GFF or GTF format.",
                "optional_value": true
            },
            "inplace": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to add the gene matrix to the AnnData object or return a new AnnData object.",
                "optional_value": false
            },
            "file": {
                "type": "Optional[Path]",
                "default": "None",
                "optional": true,
                "description": "File name of the h5ad file used to store the result. This has no effect when `inplace=True`.",
                "optional_value": true
            },
            "backend": {
                "type": "Optional[Literal['hdf5']]",
                "default": "hdf5",
                "optional": true,
                "description": "The backend to use for storing the result. If `None`, the default backend will be used.",
                "optional_value": true
            },
            "chunk_size": {
                "type": "int",
                "default": "500",
                "optional": true,
                "description": "Chunk size",
                "optional_value": false
            },
            "use_x": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If True, use the matrix stored in `.X` to compute the gene activity.\nOtherwise the `.obsm['insertion']` is used.",
                "optional_value": false
            },
            "id_type": {
                "type": "Literal['gene', 'transcript']",
                "default": "gene",
                "optional": true,
                "description": "\"gene\" or \"transcript\".",
                "optional_value": true
            },
            "transcript_name_key": {
                "type": "str",
                "default": "transcript_name",
                "optional": true,
                "description": "The key of the transcript name in the gene annotation file.",
                "optional_value": false
            },
            "transcript_id_key": {
                "type": "str",
                "default": "transcript_id",
                "optional": true,
                "description": "The key of the transcript id in the gene annotation file.",
                "optional_value": false
            },
            "gene_name_key": {
                "type": "str",
                "default": "gene_name",
                "optional": true,
                "description": "The key of the gene name in the gene annotation file.",
                "optional_value": false
            },
            "gene_id_key": {
                "type": "str",
                "default": "gene_id",
                "optional": true,
                "description": "The key of the gene id in the gene annotation file.",
                "optional_value": false
            },
            "min_frag_size": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Minimum fragment size to include.",
                "optional_value": false
            },
            "max_frag_size": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Maximum fragment size to include.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "internal.AnnData",
            "description": "AnnData\nAn annotated data matrix of shape `n_obs` x `n_vars`. Rows correspond to\ncells and columns to genes. If `file=None`, an in-memory AnnData will be\nreturned, otherwise a backed AnnData is returned.\nSee Also\nadd_tile_matrix\nmake_peak_matrix"
        },
        "Docstring": "Generate cell by gene activity matrix.\n\nGenerate cell by gene activity matrix by counting the TN5 insertions in gene\nbody regions. The result will be stored in a new file and a new AnnData object\nwill be created.\n\n:func:`~snapatac2.pp.import_data` must be ran first in order to use this function.\n\nParameters\n----------\nadata\n    The (annotated) data matrix of shape `n_obs` x `n_vars`.\n    Rows correspond to cells and columns to regions.\ngene_anno\n    Either a Genome object or the path of a gene annotation file in GFF or GTF format.\ninplace\n    Whether to add the gene matrix to the AnnData object or return a new AnnData object.\nfile\n    File name of the h5ad file used to store the result. This has no effect when `inplace=True`.\nbackend\n    The backend to use for storing the result. If `None`, the default backend will be used.\nchunk_size\n    Chunk size\nuse_x\n    If True, use the matrix stored in `.X` to compute the gene activity.\n    Otherwise the `.obsm['insertion']` is used.\nid_type\n    \"gene\" or \"transcript\".\ntranscript_name_key\n    The key of the transcript name in the gene annotation file.\ntranscript_id_key\n    The key of the transcript id in the gene annotation file.\ngene_name_key\n    The key of the gene name in the gene annotation file.\ngene_id_key\n    The key of the gene id in the gene annotation file.\nmin_frag_size\n    Minimum fragment size to include.\nmax_frag_size\n    Maximum fragment size to include.\n\nReturns\n-------\nAnnData\n    An annotated data matrix of shape `n_obs` x `n_vars`. Rows correspond to\n    cells and columns to genes. If `file=None`, an in-memory AnnData will be\n    returned, otherwise a backed AnnData is returned.\n\nSee Also\n--------\nadd_tile_matrix\nmake_peak_matrix\n\nExamples\n--------\n>>> import snapatac2 as snap\n>>> data = snap.pp.import_data(snap.datasets.pbmc500(downsample=True), chrom_sizes=snap.genome.hg38, sorted_by_barcode=False)\n>>> gene_mat = snap.pp.make_gene_matrix(data, gene_anno=snap.genome.hg38)\n>>> print(gene_mat)\nAnnData object with n_obs \u00d7 n_vars = 585 \u00d7 60606\n    obs: 'n_fragment', 'frac_dup', 'frac_mito'",
        "description": "Generate cell by gene activity matrix.Generate cell by gene activity matrix by counting the TN5 insertions in gene\nbody regions. The result will be stored in a new file and a new AnnData object\nwill be created.\n\n:func:`~snapatac2.pp.import_data` must be ran first in order to use this function.",
        "example": "Examples\n--------\n>>> import snapatac2 as snap\n>>> data = snap.pp.import_data(snap.datasets.pbmc500(downsample=True), chrom_sizes=snap.genome.hg38, sorted_by_barcode=False)\n>>> gene_mat = snap.pp.make_gene_matrix(data, gene_anno=snap.genome.hg38)\n>>> print(gene_mat)\nAnnData object with n_obs \u00d7 n_vars = 585 \u00d7 60606\n    obs: 'n_fragment', 'frac_dup', 'frac_mito'",
        "api_type": "function",
        "api_calling": [
            "snapatac2.pp.make_gene_matrix(adata=@, gene_anno=$, inplace=@, file=$, backend=$, chunk_size=@, use_x=@, id_type=$, transcript_name_key=@, transcript_id_key=@, gene_name_key=@, gene_id_key=@, min_frag_size=@, max_frag_size=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.pp.scrublet": {
        "Parameters": {
            "adata": {
                "type": "Union[internal.AnnData, list[internal.AnnData]]",
                "default": null,
                "optional": false,
                "description": "The (annotated) data matrix of shape `n_obs` x `n_vars`.\nRows correspond to cells and columns to regions.\n`adata` can also be a list of AnnData objects.\nIn this case, the function will be applied to each AnnData object in parallel.",
                "optional_value": false
            },
            "features": {
                "type": "Optional[Union[str, np.ndarray]]",
                "default": "selected",
                "optional": true,
                "description": "Boolean index mask, where `True` means that the feature is kept, and\n`False` means the feature is removed.",
                "optional_value": false
            },
            "n_comps": {
                "type": "int",
                "default": "15",
                "optional": true,
                "description": "Number of components. 15 is usually sufficient. The algorithm is not sensitive\nto this parameter.",
                "optional_value": false
            },
            "sim_doublet_ratio": {
                "type": "float",
                "default": "2.0",
                "optional": true,
                "description": "Number of doublets to simulate relative to the number of observed cells.",
                "optional_value": false
            },
            "expected_doublet_rate": {
                "type": "float",
                "default": "0.1",
                "optional": true,
                "description": "Expected doublet rate.",
                "optional_value": false
            },
            "n_neighbors": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Number of neighbors used to construct the KNN graph of observed\ncells and simulated doublets. If `None`, this is \nset to round(0.5 * sqrt(n_cells))",
                "optional_value": false
            },
            "use_approx_neighbors": {
                "type": null,
                "default": "False",
                "optional": true,
                "description": "Whether to use approximate search.",
                "optional_value": true
            },
            "random_state": {
                "type": "int",
                "default": "0",
                "optional": true,
                "description": "Random state.",
                "optional_value": false
            },
            "inplace": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether update the AnnData object inplace",
                "optional_value": false
            },
            "n_jobs": {
                "type": "int",
                "default": "8",
                "optional": true,
                "description": "Number of jobs to run in parallel.",
                "optional_value": false
            },
            "verbose": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to print progress messages.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": "tuple[np.ndarray, np.ndarray] | None:\nif ``inplace = True``, it updates adata with the following fields:\n- ``adata.obs[\"doublet_probability\"]``: probability of being a doublet\n- ``adata.obs[\"doublet_score\"]``: doublet score"
        },
        "Docstring": "Compute probability of being a doublet using the scrublet algorithm.\n\nThis function identifies doublets by generating simulated doublets using\nrandomly pairing chromatin accessibility profiles of individual cells.\nThe simulated doublets are then embedded alongside the original cells using\nthe spectral embedding algorithm in this package.\nA k-nearest-neighbor classifier is trained to distinguish between the simulated\ndoublets and the authentic cells.\nThis trained classifier produces a \"doublet score\" for each cell.\nThe doublet scores are then converted into probabilities using a Gaussian mixture model.\n\nParameters\n----------\nadata\n    The (annotated) data matrix of shape `n_obs` x `n_vars`.\n    Rows correspond to cells and columns to regions.\n    `adata` can also be a list of AnnData objects.\n    In this case, the function will be applied to each AnnData object in parallel.\nfeatures\n    Boolean index mask, where `True` means that the feature is kept, and\n    `False` means the feature is removed.\nn_comps\n    Number of components. 15 is usually sufficient. The algorithm is not sensitive\n    to this parameter.\nsim_doublet_ratio\n    Number of doublets to simulate relative to the number of observed cells.\nexpected_doublet_rate\n    Expected doublet rate.\nn_neighbors\n    Number of neighbors used to construct the KNN graph of observed\n    cells and simulated doublets. If `None`, this is \n    set to round(0.5 * sqrt(n_cells))\nuse_approx_neighbors\n    Whether to use approximate search.\nrandom_state\n    Random state.\ninplace\n    Whether update the AnnData object inplace\nn_jobs\n    Number of jobs to run in parallel.\nverbose\n    Whether to print progress messages.\n\nReturns\n-------\ntuple[np.ndarray, np.ndarray] | None:\n    if ``inplace = True``, it updates adata with the following fields:\n        - ``adata.obs[\"doublet_probability\"]``: probability of being a doublet\n        - ``adata.obs[\"doublet_score\"]``: doublet score",
        "description": "Compute probability of being a doublet using the scrublet algorithm.This function identifies doublets by generating simulated doublets using\nrandomly pairing chromatin accessibility profiles of individual cells.\nThe simulated doublets are then embedded alongside the original cells using\nthe spectral embedding algorithm in this package.\nA k-nearest-neighbor classifier is trained to distinguish between the simulated\ndoublets and the authentic cells.\nThis trained classifier produces a \"doublet score\" for each cell.\nThe doublet scores are then converted into probabilities using a Gaussian mixture model.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "snapatac2.pp.scrublet(adata=@, features=@, n_comps=@, sim_doublet_ratio=@, expected_doublet_rate=@, n_neighbors=@, use_approx_neighbors=$, random_state=@, inplace=@, n_jobs=@, verbose=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.genome.GRCm38": {
        "Parameters": {},
        "Returns": {
            "type": "snapatac2.genome.Genome",
            "description": null
        },
        "Value": "<snapatac2.genome.Genome object at 0x7f4f676a3190>",
        "Docstring": "\n    A class that encapsulates information about a genome, including its FASTA sequence,\n    its annotation, and chromosome sizes.\n\n    Attributes\n    ----------\n    fasta\n        The path to the FASTA file.\n    annotation\n        The path to the annotation file.\n    chrom_sizes\n        A dictionary containing chromosome names and sizes.\n\n    Raises\n    ------\n    ValueError\n        If `fasta` or `annotation` are not a Path, a string, or a callable.\n    ",
        "description": "A class that encapsulates information about a genome, including its FASTA sequence,its annotation, and chromosome sizes.",
        "example": "",
        "api_type": "unknown",
        "api_calling": [
            "snapatac2.genome.GRCm38()"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.pp.import_data": {
        "Parameters": {
            "fragment_file": {
                "type": "Union[Path, list[Path]]",
                "default": null,
                "optional": false,
                "description": "File name of the fragment file, optionally compressed with gzip or zstd.\nThis can be a single file or a list of files.\nIf it is a list of files, a separate AnnData object will be created for each file.\nA fragment file must contain at least 5 columns:\nchromosome, start, end, barcode, count.\nOptionally it can contain one more column indicating the strand of the fragment.\nWhen strand is provided, the fragments are considered single-ended.",
                "optional_value": false
            },
            "chrom_sizes": {
                "type": "Union[Genome, dict[str, int]]",
                "default": null,
                "optional": false,
                "description": "A Genome object or a dictionary containing chromosome sizes, for example,\n`{\"chr1\": 2393, \"chr2\": 2344, ...}`.",
                "optional_value": false
            },
            "file": {
                "type": "Optional[Union[Path, list[Path]]]",
                "default": "None",
                "optional": true,
                "description": "File name of the output h5ad file used to store the result. If provided,\nresult will be saved to a backed AnnData, otherwise an in-memory AnnData\nis used.\nIf `fragment_file` is a list of files, `file` must also be a list of files if provided.",
                "optional_value": false
            },
            "min_num_fragments": {
                "type": "int",
                "default": "200",
                "optional": true,
                "description": "Number of unique fragments threshold used to filter cells",
                "optional_value": false
            },
            "sorted_by_barcode": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether the fragment file has been sorted by cell barcodes.\nThis function will be faster if `sorted_by_barcode==True`.\nNote the :func:`~snapatac2.pp.make_fragment_file` will always sort the\nfragment file by barcode.",
                "optional_value": false
            },
            "whitelist": {
                "type": "Optional[Union[Path, list[str]]]",
                "default": "None",
                "optional": true,
                "description": "File name or a list of barcodes. If it is a file name, each line\nmust contain a valid barcode. When provided, only barcodes in the whitelist\nwill be retained.",
                "optional_value": false
            },
            "chrM": {
                "type": "list[str]",
                "default": "['chrM', 'M']",
                "optional": true,
                "description": "A list of chromosome names that are considered mitochondrial DNA. This is\nused to compute the fraction of mitochondrial DNA.",
                "optional_value": false
            },
            "shift_left": {
                "type": "int",
                "default": "0",
                "optional": true,
                "description": "Insertion site correction for the left end. This is set to 0 by default,\nas shift correction is usually done in the fragment file generation step.",
                "optional_value": false
            },
            "shift_right": {
                "type": "int",
                "default": "0",
                "optional": true,
                "description": "Insertion site correction for the right end. Note this has no effect on single-end reads.\nFor single-end reads, `shift_right` will be set using the value of `shift_left`.\nThis is set to 0 by default, as shift correction is usually done in the fragment\nfile generation step.",
                "optional_value": false
            },
            "chunk_size": {
                "type": "int",
                "default": "2000",
                "optional": true,
                "description": "Increasing the chunk_size may speed up I/O but will use more memory.\nThe speed gain is usually not significant.",
                "optional_value": false
            },
            "tempdir": {
                "type": "Optional[Path]",
                "default": "None",
                "optional": true,
                "description": "Location to store temporary files. If `None`, system temporary directory\nwill be used.",
                "optional_value": true
            },
            "backend": {
                "type": "Literal['hdf5']",
                "default": "hdf5",
                "optional": true,
                "description": "The backend.",
                "optional_value": true
            },
            "n_jobs": {
                "type": "int",
                "default": "8",
                "optional": true,
                "description": "Number of jobs to run in parallel when `fragment_file` is a list.\nIf `n_jobs=-1`, all CPUs will be used.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "internal.AnnData",
            "description": "AnnData | ad.AnnData\nAn annotated data matrix of shape `n_obs` x `n_vars`. Rows correspond to\ncells and columns to regions. If `file=None`, an in-memory AnnData will be\nreturned, otherwise a backed AnnData is returned.\nSee Also\nmake_fragment_file\n:func:`~snapatac2.ex.export_fragments`"
        },
        "Docstring": "Import data fragment files and compute basic QC metrics.\n\nA fragment refers to the sequence data originating from a distinct location\nin the genome. In single-ended sequencing, one read equates to a fragment.\nHowever, in paired-ended sequencing, a fragment is defined by a pair of reads.\nThis function is designed to handle, store, and process input files with\nfragment data, further yielding a range of basic Quality Control (QC) metrics.\nThese metrics include the total number of unique fragments, duplication rates,\nand the percentage of mitochondrial DNA detected.\n\nHow fragments are stored is dependent on the sequencing approach utilized.\nFor single-ended sequencing, fragments are found in `.obsm['fragment_single']`.\nIn contrast, for paired-ended sequencing, they are located in\n`.obsm['fragment_paired']`.\n\nDiving deeper technically, the fragments are internally structured within a\nCompressed Sparse Row (CSR) matrix. In this configuration, each row signifies\na specific cell, while each column represents a unique genomic position.\nFragment starting positions dictate the column indices. Matrix values\ncapture the lengths of the fragments for paired-end reads or the lengths of\nthe reads for single-ended scenarios. It's important to note that for\nsingle-ended reads, the values are signed, with the sign providing information\non the fragment's strand orientation. Additionally, it is worth noting that\ncells may harbor duplicate fragments, leading to the presence of duplicate\ncolumn indices within the matrix. As a result, the matrix deviates from\nthe standard CSR format, and it is not advisable to use the matrix for linear\nalgebra operations.\n\n.. image:: /_static/images/func+import_data.svg\n    :align: center\n\nNote\n----\nThis function accepts both single-end and paired-end reads. \nIf the records in the fragment file contain 6 columns with the last column\nrepresenting the strand of the fragment, the fragments are considered single-ended.\nOtherwise, the fragments are considered paired-ended.\n\nParameters\n----------\nfragment_file\n    File name of the fragment file, optionally compressed with gzip or zstd.\n    This can be a single file or a list of files.\n    If it is a list of files, a separate AnnData object will be created for each file.\n    A fragment file must contain at least 5 columns:\n    chromosome, start, end, barcode, count.\n    Optionally it can contain one more column indicating the strand of the fragment.\n    When strand is provided, the fragments are considered single-ended.\nchrom_sizes\n    A Genome object or a dictionary containing chromosome sizes, for example,\n    `{\"chr1\": 2393, \"chr2\": 2344, ...}`.\nfile\n    File name of the output h5ad file used to store the result. If provided,\n    result will be saved to a backed AnnData, otherwise an in-memory AnnData\n    is used.\n    If `fragment_file` is a list of files, `file` must also be a list of files if provided.\nmin_num_fragments\n    Number of unique fragments threshold used to filter cells\nsorted_by_barcode\n    Whether the fragment file has been sorted by cell barcodes.\n    This function will be faster if `sorted_by_barcode==True`.\n    Note the :func:`~snapatac2.pp.make_fragment_file` will always sort the\n    fragment file by barcode.\nwhitelist\n    File name or a list of barcodes. If it is a file name, each line\n    must contain a valid barcode. When provided, only barcodes in the whitelist\n    will be retained.\nshift_left\n    Insertion site correction for the left end. This is set to 0 by default,\n    as shift correction is usually done in the fragment file generation step.\nchrM\n    A list of chromosome names that are considered mitochondrial DNA. This is\n    used to compute the fraction of mitochondrial DNA.\nshift_right\n    Insertion site correction for the right end. Note this has no effect on single-end reads.\n    For single-end reads, `shift_right` will be set using the value of `shift_left`.\n    This is set to 0 by default, as shift correction is usually done in the fragment\n    file generation step.\nchunk_size\n    Increasing the chunk_size may speed up I/O but will use more memory.\n    The speed gain is usually not significant.\ntempdir\n    Location to store temporary files. If `None`, system temporary directory\n    will be used.\nbackend\n    The backend.\nn_jobs\n    Number of jobs to run in parallel when `fragment_file` is a list.\n    If `n_jobs=-1`, all CPUs will be used.\n\nReturns\n-------\nAnnData | ad.AnnData\n    An annotated data matrix of shape `n_obs` x `n_vars`. Rows correspond to\n    cells and columns to regions. If `file=None`, an in-memory AnnData will be\n    returned, otherwise a backed AnnData is returned.\n\nSee Also\n--------\nmake_fragment_file\n:func:`~snapatac2.ex.export_fragments` \n\nExamples\n--------\n>>> import snapatac2 as snap\n>>> data = snap.pp.import_data(snap.datasets.pbmc500(downsample=True), chrom_sizes=snap.genome.hg38, sorted_by_barcode=False)\n>>> print(data)\nAnnData object with n_obs \u00d7 n_vars = 585 \u00d7 0\n    obs: 'n_fragment', 'frac_dup', 'frac_mito'\n    uns: 'reference_sequences'\n    obsm: 'fragment_paired'",
        "description": "Import data fragment files and compute basic QC metrics.A fragment refers to the sequence data originating from a distinct location\nin the genome. In single-ended sequencing, one read equates to a fragment.\nHowever, in paired-ended sequencing, a fragment is defined by a pair of reads.\nThis function is designed to handle, store, and process input files with\nfragment data, further yielding a range of basic Quality Control (QC) metrics.\nThese metrics include the total number of unique fragments, duplication rates,\nand the percentage of mitochondrial DNA detected.\n\nHow fragments are stored is dependent on the sequencing approach utilized.\nFor single-ended sequencing, fragments are found in `.obsm['fragment_single']`.\nIn contrast, for paired-ended sequencing, they are located in\n`.obsm['fragment_paired']`.\n\nDiving deeper technically, the fragments are internally structured within a\nCompressed Sparse Row (CSR) matrix. In this configuration, each row signifies\na specific cell, while each column represents a unique genomic position.\nFragment starting positions dictate the column indices. Matrix values\ncapture the lengths of the fragments for paired-end reads or the lengths of\nthe reads for single-ended scenarios. It's important to note that for\nsingle-ended reads, the values are signed, with the sign providing information\non the fragment's strand orientation. Additionally, it is worth noting that\ncells may harbor duplicate fragments, leading to the presence of duplicate\ncolumn indices within the matrix. As a result, the matrix deviates from\nthe standard CSR format, and it is not advisable to use the matrix for linear\nalgebra operations.\n\n.. image:: /_static/images/func+import_data.svg\n    :align: center",
        "example": "Examples\n--------\n>>> import snapatac2 as snap\n>>> data = snap.pp.import_data(snap.datasets.pbmc500(downsample=True), chrom_sizes=snap.genome.hg38, sorted_by_barcode=False)\n>>> print(data)\nAnnData object with n_obs \u00d7 n_vars = 585 \u00d7 0\n    obs: 'n_fragment', 'frac_dup', 'frac_mito'\n    uns: 'reference_sequences'\n    obsm: 'fragment_paired'",
        "api_type": "function",
        "api_calling": [
            "snapatac2.pp.import_data(fragment_file=@, chrom_sizes=@, file=@, min_num_fragments=@, sorted_by_barcode=@, whitelist=@, chrM=@, shift_left=@, shift_right=@, chunk_size=@, tempdir=$, backend=$, n_jobs=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.AnnData.to_memory": {
        "Parameters": {},
        "Returns": {
            "type": null,
            "description": "AnnData"
        },
        "Docstring": "Return a new AnnData object with all backed arrays loaded into memory.\n\nReturns\n-------\nAnnData",
        "description": "Return a new AnnData object with all backed arrays loaded into memory.",
        "example": "",
        "api_type": "method",
        "api_calling": [
            "snapatac2.AnnData.to_memory()"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.tl.motif_enrichment": {
        "Parameters": {
            "motifs": {
                "type": "list[PyDNAMotif]",
                "default": null,
                "optional": false,
                "description": "A list of transcription factor motifs.",
                "optional_value": false
            },
            "regions": {
                "type": "dict[str, list[str]]",
                "default": null,
                "optional": false,
                "description": "Groups of regions. Each group will be tested independently against the background.",
                "optional_value": false
            },
            "genome_fasta": {
                "type": "Union[Path, Genome]",
                "default": null,
                "optional": false,
                "description": "A fasta file containing the genome sequences or a Genome object.",
                "optional_value": true
            },
            "background": {
                "type": "Optional[list[str]]",
                "default": "None",
                "optional": true,
                "description": "A list of regions to be used as the background. If None, the union of elements\nin `regions` will be used as the background.",
                "optional_value": false
            },
            "method": {
                "type": "Optional[Literal['binomial', 'hypergeometric']]",
                "default": "None",
                "optional": true,
                "description": "Statistical testing method: \"binomial\" or \"hypergeometric\".\nTo use \"hypergeometric\", the testing regions must be a subset of\nbackground regions.",
                "optional_value": true
            }
        },
        "Returns": {
            "type": "dict[str, 'polars.DataFrame']",
            "description": "dict[str, pl.DataFrame]:\nDataframes containing the enrichment analysis results for different groups."
        },
        "Docstring": "Identify enriched transcription factor motifs.\n\nParameters\n----------\nmotifs\n    A list of transcription factor motifs.\nregions\n    Groups of regions. Each group will be tested independently against the background.\ngenome_fasta\n    A fasta file containing the genome sequences or a Genome object.\nbackground\n    A list of regions to be used as the background. If None, the union of elements\n    in `regions` will be used as the background.\nmethod\n    Statistical testing method: \"binomial\" or \"hypergeometric\".\n    To use \"hypergeometric\", the testing regions must be a subset of\n    background regions.\n\nReturns\n-------\ndict[str, pl.DataFrame]:\n    Dataframes containing the enrichment analysis results for different groups.",
        "description": "Identify enriched transcription factor motifs.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "snapatac2.tl.motif_enrichment(motifs=@, regions=@, genome_fasta=$, background=@, method=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.read_10x_mtx": {
        "Parameters": {
            "path": {
                "type": "Path",
                "default": null,
                "optional": false,
                "description": "Path to directory for `.mtx` and `.tsv` files. The directory should contain\nthree files:\n\n1. count matrix: \"matrix.mtx\" or \"matrix.mtx.gz\".\n2. features: \"genes.tsv\", or \"genes.tsv.gz\", or \"features.tsv\", or \"features.tsv.gz\".\n3. barcodes: \"barcodes.tsv\", or \"barcodes.tsv.gz\".",
                "optional_value": true
            },
            "file": {
                "type": "Optional[Path]",
                "default": "None",
                "optional": true,
                "description": "File name of the \".h5ad\" file used to save the AnnData object. If `None`,\nan in-memory AnnData object is returned.",
                "optional_value": true
            },
            "prefix": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Any prefix before `matrix.mtx`, `genes.tsv` and `barcodes.tsv`. For instance,\nif the files are named `patientA_matrix.mtx`, `patientA_genes.tsv` and\n`patientA_barcodes.tsv`, then the prefix is `patientA_`.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": "AnnData\nAn AnnData object."
        },
        "Docstring": "Read 10x-Genomics-formatted mtx directory.\n\nParameters\n----------\npath\n    Path to directory for `.mtx` and `.tsv` files. The directory should contain\n    three files:\n\n    1. count matrix: \"matrix.mtx\" or \"matrix.mtx.gz\".\n    2. features: \"genes.tsv\", or \"genes.tsv.gz\", or \"features.tsv\", or \"features.tsv.gz\".\n    3. barcodes: \"barcodes.tsv\", or \"barcodes.tsv.gz\".\nfile\n    File name of the \".h5ad\" file used to save the AnnData object. If `None`,\n    an in-memory AnnData object is returned.\nprefix\n    Any prefix before `matrix.mtx`, `genes.tsv` and `barcodes.tsv`. For instance,\n    if the files are named `patientA_matrix.mtx`, `patientA_genes.tsv` and\n    `patientA_barcodes.tsv`, then the prefix is `patientA_`.\n\nReturns\n-------\nAnnData\n    An AnnData object.",
        "description": "Read 10x-Genomics-formatted mtx directory.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "snapatac2.read_10x_mtx(path=$, file=$, prefix=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.AnnDataSet.is_closed": {
        "Parameters": {},
        "Returns": {
            "type": null,
            "description": "bool"
        },
        "Docstring": "If the AnnDataSet object has been closed.\n\nReturns\n-------\nbool",
        "description": "If the AnnDataSet object has been closed.",
        "example": "",
        "api_type": "method",
        "api_calling": [
            "snapatac2.AnnDataSet.is_closed()"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.AnnData.chunked_X": {
        "Parameters": {
            "chunk_size": {
                "type": "int",
                "default": "500",
                "optional": true,
                "description": "Row size of a single chunk. Default: 500.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": "PyChunkedMatrix"
        },
        "Docstring": "Return an iterator over the rows of the data matrix X.\n\nParameters\n----------\nchunk_size : int\n    Row size of a single chunk. Default: 500.\n\nReturns\n-------\nPyChunkedMatrix",
        "description": "Return an iterator over the rows of the data matrix X.",
        "example": "",
        "api_type": "method",
        "api_calling": [
            "snapatac2.AnnData.chunked_X(chunk_size=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.tl.aggregate_cells": {
        "Parameters": {
            "adata": {
                "type": "Union[internal.AnnData, internal.AnnDataSet, np.ndarray]",
                "default": null,
                "optional": false,
                "description": "AnnData or AnnDataSet object or matrix.",
                "optional_value": false
            },
            "use_rep": {
                "type": "str",
                "default": "X_spectral",
                "optional": true,
                "description": "`adata.obs` key for retrieving the input matrix.",
                "optional_value": false
            },
            "target_num_cells": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "If None, `target_num_cells = num_cells / min_cluster_size`.",
                "optional_value": false
            },
            "min_cluster_size": {
                "type": "int",
                "default": "50",
                "optional": true,
                "description": "The minimum size of clusters.",
                "optional_value": false
            },
            "random_state": {
                "type": "int",
                "default": "0",
                "optional": true,
                "description": "Change the initialization of the optimization.",
                "optional_value": false
            },
            "key_added": {
                "type": "str",
                "default": "pseudo_cell",
                "optional": true,
                "description": "`adata.obs` key under which to add the cluster labels.",
                "optional_value": false
            },
            "inplace": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to store the result in the anndata object.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[np.ndarray]",
            "description": "np.ndarray | None\nIf `inplace=False`, return the result as a numpy array.\nOtherwise, store the result in `adata.obs[`key_added`]`."
        },
        "Docstring": "Aggregate cells into pseudo-cells.\n\nAggregate cells into pseudo-cells by iterative clustering.\n\nParameters\n----------\nadata\n    AnnData or AnnDataSet object or matrix.\nuse_rep\n    `adata.obs` key for retrieving the input matrix.\ntarget_num_cells\n    If None, `target_num_cells = num_cells / min_cluster_size`.\nmin_cluster_size\n    The minimum size of clusters.\nrandom_state\n    Change the initialization of the optimization.\nkey_added\n    `adata.obs` key under which to add the cluster labels.\ninplace\n    Whether to store the result in the anndata object.\n\nReturns\n-------\nnp.ndarray | None\n    If `inplace=False`, return the result as a numpy array.\n    Otherwise, store the result in `adata.obs[`key_added`]`.",
        "description": "Aggregate cells into pseudo-cells.Aggregate cells into pseudo-cells by iterative clustering.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "snapatac2.tl.aggregate_cells(adata=@, use_rep=@, target_num_cells=@, min_cluster_size=@, random_state=@, key_added=@, inplace=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.pl.tsse": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "min_fragment": {
                "type": "int",
                "default": "500",
                "optional": true,
                "description": "The cells' unique fragments lower than it should be removed",
                "optional_value": false
            },
            "width": {
                "type": "int",
                "default": "500",
                "optional": true,
                "description": "The width of the plot",
                "optional_value": false
            },
            "height": {
                "type": "int",
                "default": "400",
                "optional": true,
                "description": "The height of the plot",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional['plotly.graph_objects.Figure']",
            "description": "'plotly.graph_objects.Figure' | None\nIf `show=False` and `out_file=None`, an `plotly.graph_objects.Figure` will be\nreturned, which can then be further customized using the plotly API.\nSee Also\nrender_plot"
        },
        "Docstring": "Plot the TSS enrichment vs. number of fragments density figure.\n\nParameters\n----------\nadata\n    Annotated data matrix.\nmin_fragment\n    The cells' unique fragments lower than it should be removed\nwidth\n    The width of the plot\nheight\n    The height of the plot\nkwargs        \n    Additional arguments passed to :func:`~snapatac2.pl.render_plot` to\n    control the final plot output. Please see :func:`~snapatac2.pl.render_plot`\n    for details.\n\nReturns\n-------\n'plotly.graph_objects.Figure' | None\n    If `show=False` and `out_file=None`, an `plotly.graph_objects.Figure` will be \n    returned, which can then be further customized using the plotly API.\n\nSee Also\n--------\nrender_plot\n\nExamples\n--------\n.. plotly::\n\n    >>> import snapatac2 as snap\n    >>> data = snap.read(snap.datasets.pbmc5k(type='h5ad'))\n    >>> fig = snap.pl.tsse(data, show=False, out_file=None)\n    >>> fig.show()",
        "description": "Plot the TSS enrichment vs. number of fragments density figure.",
        "example": "Examples\n--------\n.. plotly::\n\n    >>> import snapatac2 as snap\n    >>> data = snap.read(snap.datasets.pbmc5k(type='h5ad'))\n    >>> fig = snap.pl.tsse(data, show=False, out_file=None)\n    >>> fig.show()",
        "api_type": "function",
        "api_calling": [
            "snapatac2.pl.tsse(adata=$, min_fragment=@, width=@, height=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.AnnData.subset": {
        "Parameters": {
            "obs_indices": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "obs indices",
                "optional_value": true
            },
            "var_indices": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "var indices",
                "optional_value": true
            },
            "out": {
                "type": "Path | None",
                "default": "None",
                "optional": true,
                "description": "File name of the output `.h5ad` file. If provided, the result will be\nsaved to a new file and the original AnnData object remains unchanged.",
                "optional_value": true
            },
            "backend": {
                "type": "str | None",
                "default": "None",
                "optional": true,
                "description": null,
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": "Optional[AnnData]"
        },
        "Docstring": "Subsetting the AnnData object.\n\nParameters\n----------\nobs_indices\n    obs indices\nvar_indices\n    var indices\nout: Path | None\n    File name of the output `.h5ad` file. If provided, the result will be\n    saved to a new file and the original AnnData object remains unchanged.\nbackend: str | None\n\nReturns\n-------\nOptional[AnnData]",
        "description": "Subsetting the AnnData object.",
        "example": "",
        "api_type": "method",
        "api_calling": [
            "snapatac2.AnnData.subset(obs_indices=$, var_indices=$, out=$, backend=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.pl.regions": {
        "Parameters": {
            "adata": {
                "type": "Union[AnnData, AnnDataSet]",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "groupby": {
                "type": "Union[str, list[str]]",
                "default": null,
                "optional": false,
                "description": "Group the cells into different groups. If a `str`, groups are obtained from\n`.obs[groupby]`.",
                "optional_value": false
            },
            "peaks": {
                "type": "dict[str, list[str]]",
                "default": null,
                "optional": false,
                "description": "Peaks of each group.",
                "optional_value": false
            },
            "width": {
                "type": "float",
                "default": "600",
                "optional": true,
                "description": "The width of the plot",
                "optional_value": false
            },
            "height": {
                "type": "float",
                "default": "400",
                "optional": true,
                "description": "The height of the plot",
                "optional_value": false
            },
            "show": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Show the figure",
                "optional_value": false
            },
            "interactive": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to make interactive plot",
                "optional_value": false
            },
            "out_file": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Path of the output file for saving the output image, end with\n'.svg' or '.pdf' or '.png' or '.html'.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional['plotly.graph_objects.Figure']",
            "description": "'plotly.graph_objects.Figure' | None\nIf `show=False` and `out_file=None`, an `plotly.graph_objects.Figure` will be\nreturned, which can then be further customized using the plotly API."
        },
        "Docstring": "Parameters\n----------\nadata\n    Annotated data matrix.\ngroupby\n    Group the cells into different groups. If a `str`, groups are obtained from\n    `.obs[groupby]`.\npeaks\n    Peaks of each group.\nwidth\n    The width of the plot\nheight\n    The height of the plot\nshow\n    Show the figure\ninteractive\n    Whether to make interactive plot\nout_file\n    Path of the output file for saving the output image, end with\n    '.svg' or '.pdf' or '.png' or '.html'.\n\nReturns\n-------\n'plotly.graph_objects.Figure' | None\n    If `show=False` and `out_file=None`, an `plotly.graph_objects.Figure` will be \n    returned, which can then be further customized using the plotly API.",
        "description": "",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "snapatac2.pl.regions(adata=$, groupby=@, peaks=@, width=@, height=@, show=@, interactive=@, out_file=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.AnnDataSet.subset": {
        "Parameters": {
            "obs_indices": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "obs indices",
                "optional_value": true
            },
            "var_indices": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "var indices",
                "optional_value": true
            },
            "out": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "Name of the directory used to store the new files. If provided,\nthe result will be saved to the directory and the original files\nremains unchanged.",
                "optional_value": true
            },
            "backend": {
                "type": "str | None",
                "default": "None",
                "optional": true,
                "description": null,
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": "Tuple[AnnDataSet, list[int] | None]\nA new AnnDataSet object will be returned.\nIf the order of input `obs_indices` has been changed, it will\nreturn the indices that would sort the `obs_indices` array."
        },
        "Docstring": "Subsetting the AnnDataSet object.\n\nNote\n----\nAnnDataSet will not move data across underlying AnnData objects. So the\norders of rows in the resultant AnnDataSet object may not be consistent\nwith the input `obs_indices`. This function will return a vector that can\nbe used to reorder the `obs_indices` to match the final order of rows in\nthe AnnDataSet.\n\nParameters\n----------\nobs_indices\n    obs indices\nvar_indices\n    var indices\nout\n    Name of the directory used to store the new files. If provided,\n    the result will be saved to the directory and the original files\n    remains unchanged.\nbackend: str | None\n\nReturns\n-------\nTuple[AnnDataSet, list[int] | None]\n    A new AnnDataSet object will be returned.\n    If the order of input `obs_indices` has been changed, it will\n    return the indices that would sort the `obs_indices` array.",
        "description": "Subsetting the AnnDataSet object.",
        "example": "",
        "api_type": "method",
        "api_calling": [
            "snapatac2.AnnDataSet.subset(obs_indices=$, var_indices=$, out=$, backend=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.tl.hdbscan": {
        "Parameters": {
            "adata": {
                "type": "internal.AnnData",
                "default": null,
                "optional": false,
                "description": "The annotated data matrix.",
                "optional_value": false
            },
            "min_cluster_size": {
                "type": "int",
                "default": "5",
                "optional": true,
                "description": "The minimum size of clusters; single linkage splits that contain\nfewer points than this will be considered points \"falling out\" of\na cluster rather than a cluster splitting into two new clusters.",
                "optional_value": false
            },
            "min_samples": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "The number of samples in a neighbourhood for a point to be considered a core point.",
                "optional_value": false
            },
            "cluster_selection_epsilon": {
                "type": "float",
                "default": "0.0",
                "optional": true,
                "description": "A distance threshold. Clusters below this value will be merged.",
                "optional_value": false
            },
            "alpha": {
                "type": "float",
                "default": "1.0",
                "optional": true,
                "description": "A distance scaling parameter as used in robust single linkage.",
                "optional_value": false
            },
            "cluster_selection_method": {
                "type": "str",
                "default": "eom",
                "optional": true,
                "description": "The method used to select clusters from the condensed tree.\nThe standard approach for HDBSCAN* is to use an Excess of Mass\nalgorithm to find the most persistent clusters.\nAlternatively you can instead select the clusters at the leaves of\nthe tree - this provides the most fine grained and homogeneous clusters.\nOptions are: \"eom\" or \"leaf\".",
                "optional_value": false
            },
            "random_state": {
                "type": "int",
                "default": "0",
                "optional": true,
                "description": "Change the initialization of the optimization.",
                "optional_value": false
            },
            "use_rep": {
                "type": "str",
                "default": "X_spectral",
                "optional": true,
                "description": "Which data in `adata.obsm` to use for clustering. Default is \"X_spectral\".",
                "optional_value": false
            },
            "key_added": {
                "type": "str",
                "default": "hdbscan",
                "optional": true,
                "description": "`adata.obs` key under which to add the cluster labels.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": "adds fields to `adata`:\n`adata.obs[key_added]`\nArray of dim (number of samples) that stores the subgroup id\n(`'0'`, `'1'`, ...) for each cell."
        },
        "Docstring": "Cluster cells into subgroups using the HDBSCAN algorithm.\n\nParameters\n----------\nadata\n    The annotated data matrix.\nmin_cluster_size\n    The minimum size of clusters; single linkage splits that contain\n    fewer points than this will be considered points \"falling out\" of\n    a cluster rather than a cluster splitting into two new clusters.\nmin_samples\n    The number of samples in a neighbourhood for a point to be considered a core point.\ncluster_selection_epsilon\n    A distance threshold. Clusters below this value will be merged.\nalpha\n    A distance scaling parameter as used in robust single linkage.\ncluster_selection_method\n    The method used to select clusters from the condensed tree.\n    The standard approach for HDBSCAN* is to use an Excess of Mass\n    algorithm to find the most persistent clusters.\n    Alternatively you can instead select the clusters at the leaves of\n    the tree - this provides the most fine grained and homogeneous clusters.\n    Options are: \"eom\" or \"leaf\".\nrandom_state\n    Change the initialization of the optimization.\nuse_rep\n    Which data in `adata.obsm` to use for clustering. Default is \"X_spectral\".\nkey_added\n    `adata.obs` key under which to add the cluster labels.\n\nReturns\n-------\nadds fields to `adata`:\n`adata.obs[key_added]`\n    Array of dim (number of samples) that stores the subgroup id\n    (`'0'`, `'1'`, ...) for each cell.",
        "description": "Cluster cells into subgroups using the HDBSCAN algorithm.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "snapatac2.tl.hdbscan(adata=@, min_cluster_size=@, min_samples=@, cluster_selection_epsilon=@, alpha=@, cluster_selection_method=@, random_state=@, use_rep=@, key_added=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.genome.mm39": {
        "Parameters": {},
        "Returns": {
            "type": "snapatac2.genome.Genome",
            "description": null
        },
        "Value": "<snapatac2.genome.Genome object at 0x7f4f676a3130>",
        "Docstring": "\n    A class that encapsulates information about a genome, including its FASTA sequence,\n    its annotation, and chromosome sizes.\n\n    Attributes\n    ----------\n    fasta\n        The path to the FASTA file.\n    annotation\n        The path to the annotation file.\n    chrom_sizes\n        A dictionary containing chromosome names and sizes.\n\n    Raises\n    ------\n    ValueError\n        If `fasta` or `annotation` are not a Path, a string, or a callable.\n    ",
        "description": "A class that encapsulates information about a genome, including its FASTA sequence,its annotation, and chromosome sizes.",
        "example": "",
        "api_type": "unknown",
        "api_calling": [
            "snapatac2.genome.mm39()"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.tl.spectral": {
        "Parameters": {
            "adata": {
                "type": "Union[internal.AnnData, internal.AnnDataSet]",
                "default": null,
                "optional": false,
                "description": "AnnData or AnnDataSet object.",
                "optional_value": false
            },
            "n_comps": {
                "type": "int",
                "default": "30",
                "optional": true,
                "description": "Number of dimensions to keep. The result is insensitive to this parameter when\n`weighted_by_sd` is set to True, as long as it is large enough, e.g. 30.",
                "optional_value": false
            },
            "features": {
                "type": "Optional[Union[str, np.ndarray]]",
                "default": "selected",
                "optional": true,
                "description": "Boolean index mask. True means that the feature is kept.\nFalse means the feature is removed. If `features=None`, all features are used.",
                "optional_value": false
            },
            "random_state": {
                "type": "int",
                "default": "0",
                "optional": true,
                "description": "Seed of the random state generator",
                "optional_value": false
            },
            "sample_size": {
                "type": "Optional[Union[int, float]]",
                "default": "None",
                "optional": true,
                "description": "Approximate the embedding using the Nystrom algorithm by selecting\na subset of cells. It could be either an integer\nindicating the number of cells to sample or a real value from 0 to 1\nindicating the fraction of cells to sample.\nUsing this only when the number of cells is too large, e.g. > 10,000,000, or\nthe `distance_metric` is \"jaccard\".",
                "optional_value": false
            },
            "sample_method": {
                "type": "Literal['random', 'degree']",
                "default": "random",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "chunk_size": {
                "type": "int",
                "default": "20000",
                "optional": true,
                "description": "Chunk size used in the Nystrom method",
                "optional_value": false
            },
            "distance_metric": {
                "type": "Literal['jaccard', 'cosine']",
                "default": "cosine",
                "optional": true,
                "description": "distance metric: \"jaccard\", \"cosine\".\nWhen \"cosine\" is used, the matrix-free spectral embedding algorithm is used.",
                "optional_value": true
            },
            "weighted_by_sd": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to weight the result eigenvectors by the square root of eigenvalues.\nThis parameter is turned on by default. When it is turned on, mannully selecting\nthe number of components is usually not necessary.",
                "optional_value": false
            },
            "feature_weights": {
                "type": "Optional[list[float]]",
                "default": "None",
                "optional": true,
                "description": "Feature weights used in the distance metric. If None, the inverse document\nfrequency (IDF) is used.",
                "optional_value": false
            },
            "inplace": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to store the result in the anndata object.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[tuple[np.ndarray, np.ndarray]]",
            "description": "tuple[np.ndarray, np.ndarray] | None\nif `inplace=True` it stores Spectral embedding of data in\n`adata.obsm[\"X_spectral\"]` and `adata.uns[\"spectral_eigenvalue\"]`.\nOtherwise, it returns the result as numpy arrays.\nSee Also\nmulti_spectral"
        },
        "Docstring": "Perform dimension reduction using Laplacian Eigenmaps.\n\nConvert the cell-by-feature count matrix into lower dimensional representations\nusing the spectrum of the normalized graph Laplacian defined by pairwise similarity\nbetween cells.\nThis function utilizes the matrix-free spectral embedding algorithm to compute\nthe embedding when `distance_metric` is \"cosine\", which scales linearly with the\nnumber of cells. For other types of similarity metrics, the time and space complexity\nscale quadratically with the number of cells.\n\nNote\n----\nDetermining the appropriate number of components is crucial when performing\ndownstream analyses to ensure optimal clustering outcomes. Utilizing components\nthat are either uninformative or irrelevant can compromise the quality of the results.\nBy default, this function adopts a strategy where all eigenvectors are weighted\naccording to the square root of their corresponding eigenvalues, rather than\nimplementing a strict cutoff threshold. This method generally provides satisfactory\nresults, circumventing the necessity for manual specification of component numbers.\nHowever, it's important to note that there might be exceptional cases with\ncertain datasets where deviating from this default setting could yield better\noutcomes. In such scenarios, you can disable the automatic weighting by\nsetting `weighted_by_sd=False`. Subsequently, you will need to manually determine\nand select the number of components to use for your specific analysis.\n\nParameters\n----------\nadata\n    AnnData or AnnDataSet object.\nn_comps\n    Number of dimensions to keep. The result is insensitive to this parameter when\n    `weighted_by_sd` is set to True, as long as it is large enough, e.g. 30.\nfeatures\n    Boolean index mask. True means that the feature is kept.\n    False means the feature is removed. If `features=None`, all features are used.\nrandom_state\n    Seed of the random state generator\nsample_size\n    Approximate the embedding using the Nystrom algorithm by selecting\n    a subset of cells. It could be either an integer\n    indicating the number of cells to sample or a real value from 0 to 1\n    indicating the fraction of cells to sample.\n    Using this only when the number of cells is too large, e.g. > 10,000,000, or\n    the `distance_metric` is \"jaccard\".\nchunk_size\n    Chunk size used in the Nystrom method\ndistance_metric\n    distance metric: \"jaccard\", \"cosine\".\n    When \"cosine\" is used, the matrix-free spectral embedding algorithm is used.\nweighted_by_sd\n    Whether to weight the result eigenvectors by the square root of eigenvalues.\n    This parameter is turned on by default. When it is turned on, mannully selecting\n    the number of components is usually not necessary.\nfeature_weights\n    Feature weights used in the distance metric. If None, the inverse document\n    frequency (IDF) is used.\ninplace\n    Whether to store the result in the anndata object.\n\nReturns\n-------\ntuple[np.ndarray, np.ndarray] | None\n    if `inplace=True` it stores Spectral embedding of data in\n    `adata.obsm[\"X_spectral\"]` and `adata.uns[\"spectral_eigenvalue\"]`.\n    Otherwise, it returns the result as numpy arrays.\n\nSee Also\n--------\nmulti_spectral",
        "description": "Perform dimension reduction using Laplacian Eigenmaps.Convert the cell-by-feature count matrix into lower dimensional representations\nusing the spectrum of the normalized graph Laplacian defined by pairwise similarity\nbetween cells.\nThis function utilizes the matrix-free spectral embedding algorithm to compute\nthe embedding when `distance_metric` is \"cosine\", which scales linearly with the\nnumber of cells. For other types of similarity metrics, the time and space complexity\nscale quadratically with the number of cells.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "snapatac2.tl.spectral(adata=@, n_comps=@, features=@, random_state=@, sample_size=@, sample_method=$, chunk_size=@, distance_metric=$, weighted_by_sd=@, feature_weights=@, inplace=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.pl.render_plot": {
        "Parameters": {
            "fig": {
                "type": "'plotly.graph_objects.Figure'",
                "default": null,
                "optional": false,
                "description": "The plotly figure to render.",
                "optional_value": true
            },
            "width": {
                "type": "int",
                "default": "600",
                "optional": true,
                "description": "The width of the plot.",
                "optional_value": false
            },
            "height": {
                "type": "int",
                "default": "400",
                "optional": true,
                "description": "The height of the plot.",
                "optional_value": false
            },
            "interactive": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to make interactive plot.",
                "optional_value": false
            },
            "show": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Show the figure.",
                "optional_value": false
            },
            "out_file": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Path of the output file for saving the output image, end with\n'.svg' or '.pdf' or '.png' or '.html'.",
                "optional_value": false
            },
            "scale": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Scale factor for the image. Only used when `out_file` is not None.\nUse scale > 1 to increase resolution and scale < 1 to decrease.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional['plotly.graph_objects.Figure']",
            "description": "'plotly.graph_objects.Figure' | None\nIf `show=False` and `out_file=None`, an `plotly.graph_objects.Figure` will be\nreturned, which can then be further customized using the plotly API."
        },
        "Docstring": "Render a plotly figure.\n\nNote that this function is not intended to be called directly. Instead, it is\ncalled by other plotting functions in this package.\n\nParameters\n----------\nfig\n    The plotly figure to render.\nwidth\n    The width of the plot.\nheight\n    The height of the plot.\ninteractive\n    Whether to make interactive plot.\nshow\n    Show the figure.\nout_file\n    Path of the output file for saving the output image, end with\n    '.svg' or '.pdf' or '.png' or '.html'.\nscale\n    Scale factor for the image. Only used when `out_file` is not None.\n    Use scale > 1 to increase resolution and scale < 1 to decrease.\n\nReturns\n-------\n'plotly.graph_objects.Figure' | None\n    If `show=False` and `out_file=None`, an `plotly.graph_objects.Figure` will be\n    returned, which can then be further customized using the plotly API.",
        "description": "Render a plotly figure.Note that this function is not intended to be called directly. Instead, it is\ncalled by other plotting functions in this package.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "snapatac2.pl.render_plot(fig=$, width=@, height=@, interactive=@, show=@, out_file=@, scale=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.pp.scanorama_integrate": {
        "Parameters": {
            "adata": {
                "type": "Union[internal.AnnData, internal.AnnDataSet, np.adarray]",
                "default": null,
                "optional": false,
                "description": "",
                "optional_value": false
            },
            "batch": {
                "type": "Union[str, list[str]]",
                "default": null,
                "optional": false,
                "description": "Batch labels for cells. If a string, labels will be obtained from `obs`.",
                "optional_value": false
            },
            "n_neighbors": {
                "type": "int",
                "default": "20",
                "optional": true,
                "description": "Number of mutual nearest neighbors.",
                "optional_value": false
            },
            "use_rep": {
                "type": "str",
                "default": "X_spectral",
                "optional": true,
                "description": "Use the indicated representation in `.obsm`.",
                "optional_value": false
            },
            "use_dims": {
                "type": "Optional[Union[int, list[int]]]",
                "default": "None",
                "optional": true,
                "description": "Use these dimensions in `use_rep`.",
                "optional_value": false
            },
            "groupby": {
                "type": "Optional[Union[str, list[str]]]",
                "default": "None",
                "optional": true,
                "description": "If specified, split the data into groups and perform batch correction\non each group separately.",
                "optional_value": false
            },
            "key_added": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "If specified, add the result to ``adata.obsm`` with this key. Otherwise,\nit will be stored in ``adata.obsm[use_rep + \"_scanorama\"]``.",
                "optional_value": false
            },
            "sigma": {
                "type": "float",
                "default": "15",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "approx": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "alpha": {
                "type": "float",
                "default": "0.1",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "batch_size": {
                "type": "int",
                "default": "5000",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "inplace": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to store the result in the anndata object.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": "np.ndarray | None\nif `inplace=True` it updates adata with the field\n``adata.obsm[`use_rep`_scanorama]``, containing adjusted principal components.\nOtherwise, it returns the result as a numpy array.\nSee Also\n:func:`~snapatac2.tl.spectral`: compute spectral embedding of the data matrix."
        },
        "Docstring": "Use Scanorama [Hie19]_ to integrate different experiments.\n\nScanorama [Hie19]_ is an algorithm for integrating single-cell\ndata from multiple experiments stored in an AnnData object. This\nfunction should be run after performing `tl.spectral` but before computing\nthe neighbor graph, as illustrated in the example below.\n\nThis uses the implementation of `scanorama\n<https://github.com/brianhie/scanorama>`__ [Hie19]_.\n\nParameters\n----------\ndata\n    Matrice or AnnData object. Matrices should be shaped like n_obs x n_vars.\nbatch\n    Batch labels for cells. If a string, labels will be obtained from `obs`.\nn_neighbors\n    Number of mutual nearest neighbors.\nuse_rep\n    Use the indicated representation in `.obsm`.\nuse_dims\n    Use these dimensions in `use_rep`.\ngroupby\n    If specified, split the data into groups and perform batch correction\n    on each group separately.\nkey_added\n    If specified, add the result to ``adata.obsm`` with this key. Otherwise,\n    it will be stored in ``adata.obsm[use_rep + \"_scanorama\"]``.\ninplace\n    Whether to store the result in the anndata object.\n\nReturns\n-------\nnp.ndarray | None\n    if `inplace=True` it updates adata with the field\n    ``adata.obsm[`use_rep`_scanorama]``, containing adjusted principal components.\n    Otherwise, it returns the result as a numpy array.\n\nSee Also\n--------\n:func:`~snapatac2.tl.spectral`: compute spectral embedding of the data matrix.\n\nExample\n-------\nFirst, load libraries and example dataset, and preprocess.\n\n>>> import snapatac2 as snap\n>>> adata = snap.read(snap.datasets.pbmc5k(type='h5ad'), backed=None)\n>>> snap.pp.select_features(adata)\n>>> snap.tl.spectral(adata)\n\nWe now arbitrarily assign a batch metadata variable to each cell\nfor the sake of example, but during real usage there would already\nbe a column in ``adata.obs`` giving the experiment each cell came\nfrom.\n\n>>> adata.obs['batch'] = 2218*['a'] + 2218*['b']\n\nFinally, run Scanorama. Afterwards, there will be a new table in\n``adata.obsm`` containing the Scanorama embeddings.\n\n>>> snap.pp.scanorama_integrate(adata, batch='batch')\n>>> 'X_spectral_scanorama' in adata.obsm\nTrue",
        "description": "Use Scanorama [Hie19]_ to integrate different experiments.Scanorama [Hie19]_ is an algorithm for integrating single-cell\ndata from multiple experiments stored in an AnnData object. This\nfunction should be run after performing `tl.spectral` but before computing\nthe neighbor graph, as illustrated in the example below.\n\nThis uses the implementation of `scanorama\n<https://github.com/brianhie/scanorama>`__ [Hie19]_.",
        "example": "Example\n-------\nFirst, load libraries and example dataset, and preprocess.\n\n>>> import snapatac2 as snap\n>>> adata = snap.read(snap.datasets.pbmc5k(type='h5ad'), backed=None)\n>>> snap.pp.select_features(adata)\n>>> snap.tl.spectral(adata)\n\nWe now arbitrarily assign a batch metadata variable to each cell\nfor the sake of example, but during real usage there would already\nbe a column in ``adata.obs`` giving the experiment each cell came\nfrom.\n\n>>> adata.obs['batch'] = 2218*['a'] + 2218*['b']\n\nFinally, run Scanorama. Afterwards, there will be a new table in\n``adata.obsm`` containing the Scanorama embeddings.\n\n>>> snap.pp.scanorama_integrate(adata, batch='batch')\n>>> 'X_spectral_scanorama' in adata.obsm\nTrue",
        "api_type": "function",
        "api_calling": [
            "snapatac2.pp.scanorama_integrate(adata=@, batch=@, n_neighbors=@, use_rep=@, use_dims=@, groupby=@, key_added=@, sigma=@, approx=@, alpha=@, batch_size=@, inplace=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.metrics.frip": {
        "Parameters": {
            "adata": {
                "type": "Union[internal.AnnData, list[internal.AnnData]]",
                "default": null,
                "optional": false,
                "description": "The (annotated) data matrix of shape `n_obs` x `n_vars`.\nRows correspond to cells and columns to regions.\n`adata` could also be a list of AnnData objects.\nIn this case, the function will be applied to each AnnData object in parallel.",
                "optional_value": false
            },
            "regions": {
                "type": "dict[str, Path | list[str]]",
                "default": null,
                "optional": false,
                "description": "A dictionary containing the peak sets to compute FRiP.\nThe keys are peak set names and the values are either a bed file name or a list of\nstrings representing genomic regions. For example,\n`{\"promoter_frac\": \"promoter.bed\", \"enhancer_frac\": [\"chr1:100-200\", \"chr2:300-400\"]}`.",
                "optional_value": false
            },
            "inplace": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to add the results to `adata.obs` or return it as a dictionary.",
                "optional_value": false
            },
            "n_jobs": {
                "type": "int",
                "default": "8",
                "optional": true,
                "description": "Number of jobs to run in parallel when `adata` is a list.\nIf `n_jobs=-1`, all CPUs will be used.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[Union[dict[str, list[float]], list[dict[str, list[float]]]]]",
            "description": "dict[str, list[float]] | list[dict[str, list[float]]] | None\nIf `inplace = True`, directly adds the results to `adata.obs`.\nOtherwise return a dictionary containing the results."
        },
        "Docstring": "Add fraction of reads in peaks (FRiP) to the AnnData object.\n\n:func:`~snapatac2.pp.import_data` must be ran first in order to use this function.\n\nParameters\n----------\nadata\n    The (annotated) data matrix of shape `n_obs` x `n_vars`.\n    Rows correspond to cells and columns to regions.\n    `adata` could also be a list of AnnData objects.\n    In this case, the function will be applied to each AnnData object in parallel.\nregions\n    A dictionary containing the peak sets to compute FRiP.\n    The keys are peak set names and the values are either a bed file name or a list of\n    strings representing genomic regions. For example,\n    `{\"promoter_frac\": \"promoter.bed\", \"enhancer_frac\": [\"chr1:100-200\", \"chr2:300-400\"]}`.\ninplace\n    Whether to add the results to `adata.obs` or return it as a dictionary.\nn_jobs\n    Number of jobs to run in parallel when `adata` is a list.\n    If `n_jobs=-1`, all CPUs will be used.\n\nReturns\n-------\ndict[str, list[float]] | list[dict[str, list[float]]] | None\n    If `inplace = True`, directly adds the results to `adata.obs`.\n    Otherwise return a dictionary containing the results.\n\nExamples\n--------\n>>> import snapatac2 as snap\n>>> data = snap.pp.import_data(snap.datasets.pbmc500(downsample=True), chrom_sizes=snap.genome.hg38, sorted_by_barcode=False)\n>>> snap.metrics.frip(data, {\"peaks_frac\": snap.datasets.cre_HEA()})\n>>> print(data.obs['peaks_frac'].head())\nAAACTGCAGACTCGGA-1    0.715930\nAAAGATGCACCTATTT-1    0.697364\nAAAGATGCAGATACAA-1    0.713615\nAAAGGGCTCGCTCTAC-1    0.678428\nAAATGAGAGTCCCGCA-1    0.724910\nName: peaks_frac, dtype: float64",
        "description": "Add fraction of reads in peaks (FRiP) to the AnnData object.:func:`~snapatac2.pp.import_data` must be ran first in order to use this function.",
        "example": "Examples\n--------\n>>> import snapatac2 as snap\n>>> data = snap.pp.import_data(snap.datasets.pbmc500(downsample=True), chrom_sizes=snap.genome.hg38, sorted_by_barcode=False)\n>>> snap.metrics.frip(data, {\"peaks_frac\": snap.datasets.cre_HEA()})\n>>> print(data.obs['peaks_frac'].head())\nAAACTGCAGACTCGGA-1    0.715930\nAAAGATGCACCTATTT-1    0.697364\nAAAGATGCAGATACAA-1    0.713615\nAAAGGGCTCGCTCTAC-1    0.678428\nAAATGAGAGTCCCGCA-1    0.724910\nName: peaks_frac, dtype: float64",
        "api_type": "function",
        "api_calling": [
            "snapatac2.metrics.frip(adata=@, regions=@, inplace=@, n_jobs=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.datasets.pbmc10k_multiome": {
        "Parameters": {
            "modality": {
                "type": "Literal['ATAC', 'RNA']",
                "default": "RNA",
                "optional": true,
                "description": "One of the following:\n    - \"ATAC\": ATAC-seq data.\n    - \"RNA\": RNA-seq data.",
                "optional_value": true
            },
            "type": {
                "type": "Literal['fragment', 'h5ad']",
                "default": "h5ad",
                "optional": true,
                "description": "One of the following:\n    - \"fragment\": the fragment file.\n    - \"h5ad\": preprocessed h5ad file.",
                "optional_value": true
            }
        },
        "Returns": {
            "type": "Path",
            "description": "Path\npath to the file."
        },
        "Docstring": "Single-cell multiome dataset of 10k PBMCs from 10x Genomics.\n\nParameters\n----------\nmodality\n    One of the following:\n        - \"ATAC\": ATAC-seq data.\n        - \"RNA\": RNA-seq data.\ntype\n    One of the following:\n        - \"fragment\": the fragment file.\n        - \"h5ad\": preprocessed h5ad file.\n\nReturns\n-------\nPath\n    path to the file.",
        "description": "Single-cell multiome dataset of 10k PBMCs from 10x Genomics.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "snapatac2.datasets.pbmc10k_multiome(modality=$, type=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.datasets.colon": {
        "Parameters": {},
        "Returns": {
            "type": "list[tuple[str, Path]]",
            "description": "list[tuple[str, Path]]\nA list of tuples, each tuple contains the sample name and the path to the fragment file."
        },
        "Docstring": "scATAC-seq datasets of five colon transverse samples from [Zhang21]_.\n\nReturns\n-------\nlist[tuple[str, Path]]\n    A list of tuples, each tuple contains the sample name and the path to the fragment file.",
        "description": "scATAC-seq datasets of five colon transverse samples from [Zhang21]_.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "snapatac2.datasets.colon()"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.tl.init_network_from_annotation": {
        "Parameters": {
            "regions": {
                "type": "list[str]",
                "default": null,
                "optional": false,
                "description": "A list of peaks/regions, e.g., `[\"chr1:100-1000\", \"chr2:55-222\"]`.",
                "optional_value": false
            },
            "anno_file": {
                "type": "Union[Path, Genome]",
                "default": null,
                "optional": false,
                "description": "The GFF file containing the transcript level annotations.",
                "optional_value": true
            },
            "upstream": {
                "type": "int",
                "default": "250000",
                "optional": true,
                "description": "Upstream extension to the transcription start site.",
                "optional_value": false
            },
            "downstream": {
                "type": "int",
                "default": "250000",
                "optional": true,
                "description": "Downstream extension to the transcription start site.",
                "optional_value": false
            },
            "id_type": {
                "type": "Literal['gene_name', 'gene_id', 'transcript_id']",
                "default": "gene_name",
                "optional": true,
                "description": "\"gene_name\", \"gene_id\" or \"transcript_id\".",
                "optional_value": true
            },
            "coding_gene_only": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Retain only coding genes in the network.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "rx.PyDiGraph",
            "description": "rx.PyDiGraph:\nA network where peaks/regions point towards genes if they are within genes'\nregulatory domains."
        },
        "Docstring": "Build CRE-gene network from gene annotations.\n\nLink CREs to genes if they are close to genes' promoter regions.\n\nParameters\n----------\nregions\n    A list of peaks/regions, e.g., `[\"chr1:100-1000\", \"chr2:55-222\"]`.\nanno_file\n    The GFF file containing the transcript level annotations.\nupstream\n    Upstream extension to the transcription start site.\ndownstream\n    Downstream extension to the transcription start site.\nid_type\n    \"gene_name\", \"gene_id\" or \"transcript_id\".\ncoding_gene_only\n    Retain only coding genes in the network.\n\nReturns\n-------\nrx.PyDiGraph:\n    A network where peaks/regions point towards genes if they are within genes'\n    regulatory domains.",
        "description": "Build CRE-gene network from gene annotations.Link CREs to genes if they are close to genes' promoter regions.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "snapatac2.tl.init_network_from_annotation(regions=@, anno_file=$, upstream=@, downstream=@, id_type=$, coding_gene_only=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.tl.dbscan": {
        "Parameters": {
            "adata": {
                "type": "internal.AnnData",
                "default": null,
                "optional": false,
                "description": "The annotated data matrix.",
                "optional_value": false
            },
            "eps": {
                "type": "float",
                "default": "0.5",
                "optional": true,
                "description": "The maximum distance between two samples for one to be considered as\nin the neighborhood of the other. This is not a maximum bound on the\ndistances of points within a cluster. This is the most important\nDBSCAN parameter to choose appropriately for your data set and distance function.",
                "optional_value": false
            },
            "min_samples": {
                "type": "int",
                "default": "5",
                "optional": true,
                "description": "The number of samples (or total weight) in a neighborhood for a point\nto be considered as a core point. This includes the point itself.",
                "optional_value": false
            },
            "leaf_size": {
                "type": "int",
                "default": "30",
                "optional": true,
                "description": "Leaf size passed to BallTree or cKDTree. This can affect the speed of\nthe construction and query, as well as the memory required to store the\ntree. The optimal value depends on the nature of the problem.",
                "optional_value": false
            },
            "n_jobs": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "The number of parallel jobs to run. None means 1 unless in a\njoblib.parallel_backend context. -1 means using all processors.",
                "optional_value": false
            },
            "use_rep": {
                "type": "str",
                "default": "X_spectral",
                "optional": true,
                "description": "Which data in `adata.obsm` to use for clustering. Default is \"X_spectral\".",
                "optional_value": false
            },
            "key_added": {
                "type": "str",
                "default": "dbscan",
                "optional": true,
                "description": "`adata.obs` key under which to add the cluster labels.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": "adds fields to `adata`:\n`adata.obs[key_added]`\nArray of dim (number of samples) that stores the subgroup id\n(`'0'`, `'1'`, ...) for each cell."
        },
        "Docstring": "Cluster cells into subgroups using the DBSCAN algorithm.\n\nParameters\n----------\nadata\n    The annotated data matrix.\neps\n    The maximum distance between two samples for one to be considered as\n    in the neighborhood of the other. This is not a maximum bound on the\n    distances of points within a cluster. This is the most important\n    DBSCAN parameter to choose appropriately for your data set and distance function.\nmin_samples\n    The number of samples (or total weight) in a neighborhood for a point\n    to be considered as a core point. This includes the point itself.\nleaf_size\n    Leaf size passed to BallTree or cKDTree. This can affect the speed of\n    the construction and query, as well as the memory required to store the\n    tree. The optimal value depends on the nature of the problem.\nn_jobs\n    The number of parallel jobs to run. None means 1 unless in a\n    joblib.parallel_backend context. -1 means using all processors.\nuse_rep\n    Which data in `adata.obsm` to use for clustering. Default is \"X_spectral\".\nkey_added\n    `adata.obs` key under which to add the cluster labels.\n\nReturns\n-------\nadds fields to `adata`:\n`adata.obs[key_added]`\n    Array of dim (number of samples) that stores the subgroup id\n    (`'0'`, `'1'`, ...) for each cell.",
        "description": "Cluster cells into subgroups using the DBSCAN algorithm.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "snapatac2.tl.dbscan(adata=@, eps=@, min_samples=@, leaf_size=@, n_jobs=@, use_rep=@, key_added=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.tl.prune_network": {
        "Parameters": {
            "network": {
                "type": "rx.PyDiGraph",
                "default": null,
                "optional": false,
                "description": "network",
                "optional_value": true
            },
            "node_filter": {
                "type": "Optional[Callable[[NodeData], bool]]",
                "default": "None",
                "optional": true,
                "description": "Node filter function.",
                "optional_value": false
            },
            "edge_filter": {
                "type": "Optional[Callable[[int, int, LinkData], bool]]",
                "default": "None",
                "optional": true,
                "description": "Edge filter function.",
                "optional_value": false
            },
            "remove_isolates": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to remove isolated nodes.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "rx.PyDiGraph",
            "description": "rx.PyDiGraph"
        },
        "Docstring": "Prune the network.\n\nParameters\n----------\nnetwork\n    network\nnode_filter\n    Node filter function.\nedge_filter\n    Edge filter function.\nremove_isolates\n    Whether to remove isolated nodes.\n\nReturns\n-------\nrx.PyDiGraph",
        "description": "Prune the network.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "snapatac2.tl.prune_network(network=$, node_filter=@, edge_filter=@, remove_isolates=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.pp.mnc_correct": {
        "Parameters": {
            "adata": {
                "type": "Union[internal.AnnData, internal.AnnDataSet, np.adarray]",
                "default": null,
                "optional": false,
                "description": "",
                "optional_value": false
            },
            "batch": {
                "type": "Union[str, list[str]]",
                "default": null,
                "optional": false,
                "description": "Batch labels for cells. If a string, labels will be obtained from `obs`.",
                "optional_value": false
            },
            "n_neighbors": {
                "type": "int",
                "default": "5",
                "optional": true,
                "description": "Number of mutual nearest neighbors.",
                "optional_value": false
            },
            "n_clusters": {
                "type": "int",
                "default": "40",
                "optional": true,
                "description": "Number of clusters",
                "optional_value": false
            },
            "n_iter": {
                "type": "int",
                "default": "1",
                "optional": true,
                "description": "Number of iterations.",
                "optional_value": false
            },
            "use_rep": {
                "type": "str",
                "default": "X_spectral",
                "optional": true,
                "description": "Use the indicated representation in `.obsm`.",
                "optional_value": false
            },
            "use_dims": {
                "type": "Optional[Union[int, list[int]]]",
                "default": "None",
                "optional": true,
                "description": "Use these dimensions in `use_rep`.",
                "optional_value": false
            },
            "groupby": {
                "type": "Optional[Union[str, list[str]]]",
                "default": "None",
                "optional": true,
                "description": "If specified, split the data into groups and perform batch correction\non each group separately.",
                "optional_value": false
            },
            "key_added": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "If specified, add the result to ``adata.obsm`` with this key. Otherwise,\nit will be stored in ``adata.obsm[use_rep + \"_mnn\"]``.",
                "optional_value": false
            },
            "inplace": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to store the result in the anndata object.",
                "optional_value": false
            },
            "n_jobs": {
                "type": "int",
                "default": "8",
                "optional": true,
                "description": "Number of jobs to use for parallelization.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[np.ndarray]",
            "description": "np.ndarray | None\nif `inplace=True` it updates adata with the field\n``adata.obsm[`use_rep`_mnn]``, containing adjusted principal components.\nOtherwise, it returns the result as a numpy array."
        },
        "Docstring": "A modified MNN-Correct algorithm based on cluster centroid.\n\nParameters\n----------\ndata\n    Matrice or AnnData object. Matrices should be shaped like n_obs x n_vars.\nbatch\n    Batch labels for cells. If a string, labels will be obtained from `obs`.\nn_neighbors\n    Number of mutual nearest neighbors.\nn_clusters\n    Number of clusters\nn_iter\n    Number of iterations.\nuse_rep\n    Use the indicated representation in `.obsm`.\nuse_dims\n    Use these dimensions in `use_rep`.\ngroupby\n    If specified, split the data into groups and perform batch correction\n    on each group separately.\nkey_added\n    If specified, add the result to ``adata.obsm`` with this key. Otherwise,\n    it will be stored in ``adata.obsm[use_rep + \"_mnn\"]``.\ninplace\n    Whether to store the result in the anndata object.\nn_jobs\n    Number of jobs to use for parallelization.\n\nReturns\n-------\nnp.ndarray | None\n    if `inplace=True` it updates adata with the field\n    ``adata.obsm[`use_rep`_mnn]``, containing adjusted principal components.\n    Otherwise, it returns the result as a numpy array.",
        "description": "A modified MNN-Correct algorithm based on cluster centroid.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "snapatac2.pp.mnc_correct(adata=@, batch=@, n_neighbors=@, n_clusters=@, n_iter=@, use_rep=@, use_dims=@, groupby=@, key_added=@, inplace=@, n_jobs=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.AnnData.close": {
        "Parameters": {},
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Close the AnnData object.",
        "description": "Close the AnnData object.",
        "example": "",
        "api_type": "method",
        "api_calling": [
            "snapatac2.AnnData.close()"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.pp.add_tile_matrix": {
        "Parameters": {
            "adata": {
                "type": "Union[internal.AnnData, list[internal.AnnData]]",
                "default": null,
                "optional": false,
                "description": "The (annotated) data matrix of shape `n_obs` x `n_vars`.\nRows correspond to cells and columns to regions.\n`adata` could also be a list of AnnData objects when `inplace=True`.\nIn this case, the function will be applied to each AnnData object in parallel.",
                "optional_value": false
            },
            "bin_size": {
                "type": "int",
                "default": "500",
                "optional": true,
                "description": "The size of consecutive genomic regions used to record the counts.",
                "optional_value": false
            },
            "inplace": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to add the tile matrix to the AnnData object or return a new AnnData object.",
                "optional_value": false
            },
            "chunk_size": {
                "type": "int",
                "default": "500",
                "optional": true,
                "description": "Increasing the chunk_size speeds up I/O but uses more memory.",
                "optional_value": false
            },
            "exclude_chroms": {
                "type": "Optional[Union[list[str], str]]",
                "default": "['chrM', 'chrY', 'M', 'Y']",
                "optional": true,
                "description": "A list of chromosomes to exclude.",
                "optional_value": false
            },
            "min_frag_size": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Minimum fragment size to include.",
                "optional_value": false
            },
            "max_frag_size": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Maximum fragment size to include.",
                "optional_value": false
            },
            "file": {
                "type": "Optional[Path]",
                "default": "None",
                "optional": true,
                "description": "File name of the output file used to store the result. If provided, result will\nbe saved to a backed AnnData, otherwise an in-memory AnnData is used.\nThis has no effect when `inplace=True`.",
                "optional_value": true
            },
            "backend": {
                "type": "Literal['hdf5']",
                "default": "hdf5",
                "optional": true,
                "description": "The backend to use for storing the result. If `None`, the default backend will be used.",
                "optional_value": true
            },
            "n_jobs": {
                "type": "int",
                "default": "8",
                "optional": true,
                "description": "Number of jobs to run in parallel when `adata` is a list.\nIf `n_jobs=-1`, all CPUs will be used.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[internal.AnnData]",
            "description": "AnnData | ad.AnnData | None\nAn annotated data matrix of shape `n_obs` x `n_vars`. Rows correspond to\ncells and columns to bins. If `file=None`, an in-memory AnnData will be\nreturned, otherwise a backed AnnData is returned.\nSee Also\nmake_peak_matrix\nmake_gene_matrix"
        },
        "Docstring": "Generate cell by bin count matrix.\n\nThis function is used to generate and add a cell by bin count matrix to the AnnData\nobject.\n\n:func:`~snapatac2.pp.import_data` must be ran first in order to use this function.\n\nParameters\n----------\nadata\n    The (annotated) data matrix of shape `n_obs` x `n_vars`.\n    Rows correspond to cells and columns to regions.\n    `adata` could also be a list of AnnData objects when `inplace=True`.\n    In this case, the function will be applied to each AnnData object in parallel.\nbin_size\n    The size of consecutive genomic regions used to record the counts.\ninplace\n    Whether to add the tile matrix to the AnnData object or return a new AnnData object.\nchunk_size\n    Increasing the chunk_size speeds up I/O but uses more memory.\nexclude_chroms\n    A list of chromosomes to exclude.\nmin_frag_size\n    Minimum fragment size to include.\nmax_frag_size\n    Maximum fragment size to include.\nfile\n    File name of the output file used to store the result. If provided, result will\n    be saved to a backed AnnData, otherwise an in-memory AnnData is used.\n    This has no effect when `inplace=True`.\nbackend\n    The backend to use for storing the result. If `None`, the default backend will be used.\nn_jobs\n    Number of jobs to run in parallel when `adata` is a list.\n    If `n_jobs=-1`, all CPUs will be used.\n\nReturns\n-------\nAnnData | ad.AnnData | None\n    An annotated data matrix of shape `n_obs` x `n_vars`. Rows correspond to\n    cells and columns to bins. If `file=None`, an in-memory AnnData will be\n    returned, otherwise a backed AnnData is returned.\n\nSee Also\n--------\nmake_peak_matrix\nmake_gene_matrix\n\nExamples\n--------\n>>> import snapatac2 as snap\n>>> data = snap.pp.import_data(snap.datasets.pbmc500(downsample=True), chrom_sizes=snap.genome.hg38, sorted_by_barcode=False)\n>>> snap.pp.add_tile_matrix(data, bin_size=500)\n>>> print(data)\nAnnData object with n_obs \u00d7 n_vars = 585 \u00d7 6062095\n    obs: 'n_fragment', 'frac_dup', 'frac_mito'\n    uns: 'reference_sequences'\n    obsm: 'fragment_paired'",
        "description": "Generate cell by bin count matrix.This function is used to generate and add a cell by bin count matrix to the AnnData\nobject.\n\n:func:`~snapatac2.pp.import_data` must be ran first in order to use this function.",
        "example": "Examples\n--------\n>>> import snapatac2 as snap\n>>> data = snap.pp.import_data(snap.datasets.pbmc500(downsample=True), chrom_sizes=snap.genome.hg38, sorted_by_barcode=False)\n>>> snap.pp.add_tile_matrix(data, bin_size=500)\n>>> print(data)\nAnnData object with n_obs \u00d7 n_vars = 585 \u00d7 6062095\n    obs: 'n_fragment', 'frac_dup', 'frac_mito'\n    uns: 'reference_sequences'\n    obsm: 'fragment_paired'",
        "api_type": "function",
        "api_calling": [
            "snapatac2.pp.add_tile_matrix(adata=@, bin_size=@, inplace=@, chunk_size=@, exclude_chroms=@, min_frag_size=@, max_frag_size=@, file=$, backend=$, n_jobs=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.pp.select_features": {
        "Parameters": {
            "adata": {
                "type": "Union[internal.AnnData, internal.AnnDataSet, list[internal.AnnData]]",
                "default": null,
                "optional": false,
                "description": "The (annotated) data matrix of shape `n_obs` x `n_vars`.\nRows correspond to cells and columns to regions.\n`adata` can also be a list of AnnData objects.\nIn this case, the function will be applied to each AnnData object in parallel.",
                "optional_value": false
            },
            "n_features": {
                "type": "int",
                "default": "500000",
                "optional": true,
                "description": "Number of features to keep. Note that the final number of features\nmay be smaller than this number if there is not enough features that pass\nthe filtering criteria.",
                "optional_value": false
            },
            "filter_lower_quantile": {
                "type": "float",
                "default": "0.005",
                "optional": true,
                "description": "Lower quantile of the feature count distribution to filter out.\nFor example, 0.005 means the bottom 0.5% features with the lowest counts will be removed.",
                "optional_value": false
            },
            "filter_upper_quantile": {
                "type": "float",
                "default": "0.005",
                "optional": true,
                "description": "Upper quantile of the feature count distribution to filter out.\nFor example, 0.005 means the top 0.5% features with the highest counts will be removed.\nBe aware that when the number of feature is very large, the default value of 0.005 may\nrisk removing too many features.",
                "optional_value": false
            },
            "whitelist": {
                "type": "Optional[Path]",
                "default": "None",
                "optional": true,
                "description": "A user provided bed file containing genome-wide whitelist regions.\nNone-zero features listed here will be kept regardless of the other\nfiltering criteria.\nIf a feature is present in both whitelist and blacklist, it will be kept.",
                "optional_value": true
            },
            "blacklist": {
                "type": "Optional[Path]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "max_iter": {
                "type": "int",
                "default": "1",
                "optional": true,
                "description": "If greater than 1, this function will perform iterative clustering and feature selection\nbased on variable features found using previous clustering results.\nThis is similar to the procedure implemented in ArchR, but we do not recommend it,\nsee https://github.com/kaizhang/SnapATAC2/issues/111.\nDefault value is 1, which means no iterative clustering is performed.",
                "optional_value": false
            },
            "inplace": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Perform computation inplace or return result.",
                "optional_value": false
            },
            "n_jobs": {
                "type": "int",
                "default": "8",
                "optional": true,
                "description": "Number of parallel jobs to use when `adata` is a list.",
                "optional_value": false
            },
            "verbose": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to print progress messages.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[Union[np.ndarray, list[np.ndarray]]]",
            "description": "np.ndarray | None:\nIf `inplace = False`, return a boolean index mask that does filtering,\nwhere `True` means that the feature is kept, `False` means the feature is removed.\nOtherwise, store this index mask directly to `.var['selected']`."
        },
        "Docstring": "Perform feature selection.\n\nNote\n----\nThis function does not perform the actual subsetting. The feature mask is used by\nvarious functions to generate submatrices on the fly.\nFor more discussion about feature selection, see: https://github.com/kaizhang/SnapATAC2/discussions/116.\n\nParameters\n----------\nadata\n    The (annotated) data matrix of shape `n_obs` x `n_vars`.\n    Rows correspond to cells and columns to regions.\n    `adata` can also be a list of AnnData objects.\n    In this case, the function will be applied to each AnnData object in parallel.\nn_features\n    Number of features to keep. Note that the final number of features\n    may be smaller than this number if there is not enough features that pass\n    the filtering criteria.\nfilter_lower_quantile\n    Lower quantile of the feature count distribution to filter out.\n    For example, 0.005 means the bottom 0.5% features with the lowest counts will be removed.\nfilter_upper_quantile\n    Upper quantile of the feature count distribution to filter out.\n    For example, 0.005 means the top 0.5% features with the highest counts will be removed.\n    Be aware that when the number of feature is very large, the default value of 0.005 may\n    risk removing too many features.\nwhitelist\n    A user provided bed file containing genome-wide whitelist regions.\n    None-zero features listed here will be kept regardless of the other\n    filtering criteria.\n    If a feature is present in both whitelist and blacklist, it will be kept.\nblacklist \n    A user provided bed file containing genome-wide blacklist regions.\n    Features that are overlapped with these regions will be removed.\nmax_iter\n    If greater than 1, this function will perform iterative clustering and feature selection\n    based on variable features found using previous clustering results.\n    This is similar to the procedure implemented in ArchR, but we do not recommend it,\n    see https://github.com/kaizhang/SnapATAC2/issues/111.\n    Default value is 1, which means no iterative clustering is performed.\ninplace\n    Perform computation inplace or return result.\nn_jobs\n    Number of parallel jobs to use when `adata` is a list.\nverbose\n    Whether to print progress messages.\n\nReturns\n-------\nnp.ndarray | None:\n    If `inplace = False`, return a boolean index mask that does filtering,\n    where `True` means that the feature is kept, `False` means the feature is removed.\n    Otherwise, store this index mask directly to `.var['selected']`.",
        "description": "Perform feature selection.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "snapatac2.pp.select_features(adata=@, n_features=@, filter_lower_quantile=@, filter_upper_quantile=@, whitelist=$, blacklist=$, max_iter=@, inplace=@, n_jobs=@, verbose=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.tl.macs3": {
        "Parameters": {
            "adata": {
                "type": "Union[AnnData, AnnDataSet]",
                "default": null,
                "optional": false,
                "description": "The (annotated) data matrix of shape `n_obs` x `n_vars`.\nRows correspond to cells and columns to regions.",
                "optional_value": true
            },
            "groupby": {
                "type": "Union[str, list[str]]",
                "default": null,
                "optional": false,
                "description": "Group the cells before peak calling. If a `str`, groups are obtained from\n`.obs[groupby]`.",
                "optional_value": false
            },
            "qvalue": {
                "type": "float",
                "default": "0.05",
                "optional": true,
                "description": "qvalue cutoff used in MACS3.",
                "optional_value": false
            },
            "replicate": {
                "type": "Optional[Union[str, list[str]]]",
                "default": "None",
                "optional": true,
                "description": "Replicate information. If provided, reproducible peaks will be called\nfor each group.",
                "optional_value": false
            },
            "replicate_qvalue": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "qvalue cutoff used in MACS3 for calling peaks in replicates.\nThis parameter is only used when `replicate` is provided.\nTypically this parameter is used to call peaks in replicates with a more lenient cutoff.\nIf not provided, `qvalue` will be used.",
                "optional_value": false
            },
            "max_frag_size": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Maximum fragment size. If provided, fragments with sizes larger than\n`max_frag_size` will be not be used in peak calling.\nThis is used in ATAC-seq data to remove fragments that are not \nfrom nucleosome-free regions.\nYou can use :func:`~snapatac2.pl.frag_size_distr` to choose a proper value for\nthis parameter.",
                "optional_value": false
            },
            "selections": {
                "type": "Optional[set[str]]",
                "default": "None",
                "optional": true,
                "description": "Call peaks for the selected groups only.",
                "optional_value": false
            },
            "nolambda": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to use the `--nolambda` option in MACS.",
                "optional_value": false
            },
            "shift": {
                "type": "int",
                "default": "-100",
                "optional": true,
                "description": "The shift size in MACS.",
                "optional_value": false
            },
            "extsize": {
                "type": "int",
                "default": "200",
                "optional": true,
                "description": "The extension size in MACS.",
                "optional_value": false
            },
            "blacklist": {
                "type": "Optional[Path]",
                "default": "None",
                "optional": true,
                "description": "Path to the blacklist file in BED format. If provided, regions in the blacklist will be\nremoved.",
                "optional_value": true
            },
            "key_added": {
                "type": "str",
                "default": "macs3",
                "optional": true,
                "description": "`.uns` key under which to add the peak information.",
                "optional_value": false
            },
            "tempdir": {
                "type": "Optional[Path]",
                "default": "None",
                "optional": true,
                "description": "If provided, a temporary directory will be created in the directory.\nOtherwise, a temporary directory will be created in the system default temporary directory.",
                "optional_value": true
            },
            "inplace": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to store the result inplace.",
                "optional_value": false
            },
            "n_jobs": {
                "type": "int",
                "default": "8",
                "optional": true,
                "description": "Number of processes to use for peak calling.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[dict[str, 'polars.DataFrame']]",
            "description": "dict[str, 'polars.DataFrame'] | None\nIf `inplace=True` it stores the result in `adata.uns[`key_added`]`.\nOtherwise, it returns the result as dataframes.\nSee Also\nmerge_peaks"
        },
        "Docstring": "Call peaks using MACS3.\n\nParameters\n----------\nadata\n    The (annotated) data matrix of shape `n_obs` x `n_vars`.\n    Rows correspond to cells and columns to regions.\ngroupby\n    Group the cells before peak calling. If a `str`, groups are obtained from\n    `.obs[groupby]`.\nqvalue\n    qvalue cutoff used in MACS3.\nreplicate\n    Replicate information. If provided, reproducible peaks will be called\n    for each group.\nreplicate_qvalue\n    qvalue cutoff used in MACS3 for calling peaks in replicates.\n    This parameter is only used when `replicate` is provided.\n    Typically this parameter is used to call peaks in replicates with a more lenient cutoff.\n    If not provided, `qvalue` will be used.\nmax_frag_size\n    Maximum fragment size. If provided, fragments with sizes larger than\n    `max_frag_size` will be not be used in peak calling.\n    This is used in ATAC-seq data to remove fragments that are not \n    from nucleosome-free regions.\n    You can use :func:`~snapatac2.pl.frag_size_distr` to choose a proper value for\n    this parameter.\nselections\n    Call peaks for the selected groups only.\nnolambda\n    Whether to use the `--nolambda` option in MACS.\nshift\n    The shift size in MACS.\nextsize\n    The extension size in MACS.\nblacklist\n    Path to the blacklist file in BED format. If provided, regions in the blacklist will be\n    removed.\nkey_added\n    `.uns` key under which to add the peak information.\ntempdir\n    If provided, a temporary directory will be created in the directory.\n    Otherwise, a temporary directory will be created in the system default temporary directory.\ninplace\n    Whether to store the result inplace.\nn_jobs\n    Number of processes to use for peak calling.\n\nReturns\n-------\ndict[str, 'polars.DataFrame'] | None\n    If `inplace=True` it stores the result in `adata.uns[`key_added`]`.\n    Otherwise, it returns the result as dataframes.\n\nSee Also\n--------\nmerge_peaks",
        "description": "Call peaks using MACS3.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "snapatac2.tl.macs3(adata=$, groupby=@, qvalue=@, replicate=@, replicate_qvalue=@, max_frag_size=@, selections=@, nolambda=@, shift=@, extsize=@, blacklist=$, key_added=@, tempdir=$, inplace=@, n_jobs=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.datasets.pbmc500": {
        "Parameters": {
            "type": {
                "type": "Literal['fragment, bam']",
                "default": "fragment",
                "optional": true,
                "description": "One of the following:\n    - \"fragment\": the fragment file.\n    - \"bam\": bam file.",
                "optional_value": true
            },
            "downsample": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Path",
            "description": "Path\nPath to the fragment file."
        },
        "Docstring": "scATAC-seq dataset of 500 PBMCs from 10x Genomics.\n\nThis function returns the path to the fragment file of the 10X scATAC-seq dataset\ncontaining ~500 PBMCs.\n\nParameters\n----------\ntype\n    One of the following:\n        - \"fragment\": the fragment file.\n        - \"bam\": bam file.\n\ndownsampled\n    Whether to return downsampled dataset.\n\nReturns\n-------\nPath\n    Path to the fragment file.",
        "description": "scATAC-seq dataset of 500 PBMCs from 10x Genomics.This function returns the path to the fragment file of the 10X scATAC-seq dataset\ncontaining ~500 PBMCs.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "snapatac2.datasets.pbmc500(type=$, downsample=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.datasets.pbmc5k": {
        "Parameters": {
            "type": {
                "type": "Literal['fragment, h5ad, annotated_h5ad']",
                "default": "fragment",
                "optional": true,
                "description": "One of the following:\n    - \"fragment\": the fragment file.\n    - \"h5ad\": preprocessed h5ad file.\n    - \"annotated_h5ad\": annotated h5ad file.",
                "optional_value": true
            }
        },
        "Returns": {
            "type": "Path",
            "description": "Path\npath to the file."
        },
        "Docstring": "scATAC-seq dataset of 5k PBMCs from 10x Genomics.\n\nParameters\n----------\ntype\n    One of the following:\n        - \"fragment\": the fragment file.\n        - \"h5ad\": preprocessed h5ad file.\n        - \"annotated_h5ad\": annotated h5ad file.\n\nReturns\n-------\nPath\n    path to the file.",
        "description": "scATAC-seq dataset of 5k PBMCs from 10x Genomics.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "snapatac2.datasets.pbmc5k(type=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.genome.GRCh37": {
        "Parameters": {},
        "Returns": {
            "type": "snapatac2.genome.Genome",
            "description": null
        },
        "Value": "<snapatac2.genome.Genome object at 0x7f4f676a2d10>",
        "Docstring": "\n    A class that encapsulates information about a genome, including its FASTA sequence,\n    its annotation, and chromosome sizes.\n\n    Attributes\n    ----------\n    fasta\n        The path to the FASTA file.\n    annotation\n        The path to the annotation file.\n    chrom_sizes\n        A dictionary containing chromosome names and sizes.\n\n    Raises\n    ------\n    ValueError\n        If `fasta` or `annotation` are not a Path, a string, or a callable.\n    ",
        "description": "A class that encapsulates information about a genome, including its FASTA sequence,its annotation, and chromosome sizes.",
        "example": "",
        "api_type": "unknown",
        "api_calling": [
            "snapatac2.genome.GRCh37()"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.AnnDataSet.close": {
        "Parameters": {},
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Close the AnnDataSet object.",
        "description": "Close the AnnDataSet object.",
        "example": "",
        "api_type": "method",
        "api_calling": [
            "snapatac2.AnnDataSet.close()"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.AnnDataSet": {
        "Parameters": {
            "adatas": {
                "type": "list[(str, Path)] | list[(str, AnnData)]",
                "default": null,
                "optional": false,
                "description": "List of key and file name (or backed AnnData object) pairs.",
                "optional_value": false
            },
            "filename": {
                "type": "Path",
                "default": null,
                "optional": false,
                "description": "File name of the output file containing the AnnDataSet object.",
                "optional_value": true
            },
            "add_key": {
                "type": "str",
                "default": "sample",
                "optional": true,
                "description": "The column name in obs to store the keys",
                "optional_value": false
            },
            "backend": {
                "type": "str",
                "default": "None",
                "optional": true,
                "description": "The backend to use for the AnnDataSet object.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Similar to `AnnData`, `AnnDataSet` contains annotations of\nobservations `obs` (`obsm`, `obsp`), variables `var` (`varm`, `varp`),\nand unstructured annotations `uns`. Additionally it provides lazy access to\nconcatenated component AnnData objects, including `X`, `obs`, `obsm`, `obsp`.\n\nParameters\n----------\nadatas: list[(str, Path)] | list[(str, AnnData)]\n    List of key and file name (or backed AnnData object) pairs.\nfilename: Path\n    File name of the output file containing the AnnDataSet object.\nadd_key: str\n    The column name in obs to store the keys\nbackend: str\n    The backend to use for the AnnDataSet object.\n\nNote\n----\nAnnDataSet does not copy underlying AnnData objects. It stores the references\nto individual anndata files. If you move the anndata files to a new location,\nremember to update the anndata file locations when opening an AnnDataSet object.\n\nSee Also\n--------\nread_dataset",
        "description": "Similar to `AnnData`, `AnnDataSet` contains annotations ofobservations `obs` (`obsm`, `obsp`), variables `var` (`varm`, `varp`),\nand unstructured annotations `uns`. Additionally it provides lazy access to\nconcatenated component AnnData objects, including `X`, `obs`, `obsm`, `obsp`.",
        "example": "",
        "api_type": "class",
        "api_calling": [
            "snapatac2.AnnDataSet(adatas=@, filename=$, add_key=@, backend=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.AnnDataSet.chunked_X": {
        "Parameters": {
            "chunk_size": {
                "type": "int",
                "default": "500",
                "optional": true,
                "description": "Row size of a single chunk. Default: 500.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Parameters\n----------\nchunk_size : int\n    Row size of a single chunk. Default: 500.",
        "description": "",
        "example": "",
        "api_type": "method",
        "api_calling": [
            "snapatac2.AnnDataSet.chunked_X(chunk_size=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.AnnDataSet.to_adata": {
        "Parameters": {
            "obs_indices": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "var_indices": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "copy_x": {
                "type": null,
                "default": "True",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "file": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "backed": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Convert AnnDataSet to AnnData object.",
        "description": "Convert AnnDataSet to AnnData object.",
        "example": "",
        "api_type": "method",
        "api_calling": [
            "snapatac2.AnnDataSet.to_adata(obs_indices=$, var_indices=$, copy_x=$, file=$, backed=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.pp.filter_cells": {
        "Parameters": {
            "data": {
                "type": "Union[internal.AnnData, list[internal.AnnData]]",
                "default": null,
                "optional": false,
                "description": "The (annotated) data matrix of shape `n_obs` x `n_vars`.\nRows correspond to cells and columns to regions.\n`data` can also be a list of AnnData objects.\nIn this case, the function will be applied to each AnnData object in parallel.",
                "optional_value": false
            },
            "min_counts": {
                "type": "Optional[int]",
                "default": "1000",
                "optional": true,
                "description": "Minimum number of counts required for a cell to pass filtering.",
                "optional_value": false
            },
            "min_tsse": {
                "type": "Optional[float]",
                "default": "5.0",
                "optional": true,
                "description": "Minimum TSS enrichemnt score required for a cell to pass filtering.",
                "optional_value": false
            },
            "max_counts": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Maximum number of counts required for a cell to pass filtering.",
                "optional_value": false
            },
            "max_tsse": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Maximum TSS enrichment score expressed required for a cell to pass filtering.",
                "optional_value": false
            },
            "inplace": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Perform computation inplace or return result.",
                "optional_value": false
            },
            "n_jobs": {
                "type": "int",
                "default": "8",
                "optional": true,
                "description": "Number of parallel jobs to use when `data` is a list.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[np.ndarray]",
            "description": "np.ndarray | None:\nIf `inplace = True`, directly subsets the data matrix. Otherwise return\na boolean index mask that does filtering, where `True` means that the\ncell is kept, `False` means the cell is removed."
        },
        "Docstring": "Filter cell outliers based on counts and numbers of genes expressed.\nFor instance, only keep cells with at least `min_counts` counts or\n`min_tsse` TSS enrichment scores. This is to filter measurement outliers,\ni.e. \"unreliable\" observations.\n\nParameters\n----------\ndata\n    The (annotated) data matrix of shape `n_obs` x `n_vars`.\n    Rows correspond to cells and columns to regions.\n    `data` can also be a list of AnnData objects.\n    In this case, the function will be applied to each AnnData object in parallel.\nmin_counts\n    Minimum number of counts required for a cell to pass filtering.\nmin_tsse\n    Minimum TSS enrichemnt score required for a cell to pass filtering.\nmax_counts\n    Maximum number of counts required for a cell to pass filtering.\nmax_tsse\n    Maximum TSS enrichment score expressed required for a cell to pass filtering.\ninplace\n    Perform computation inplace or return result.\nn_jobs\n    Number of parallel jobs to use when `data` is a list.\n\nReturns\n-------\nnp.ndarray | None:\n    If `inplace = True`, directly subsets the data matrix. Otherwise return \n    a boolean index mask that does filtering, where `True` means that the\n    cell is kept, `False` means the cell is removed.",
        "description": "Filter cell outliers based on counts and numbers of genes expressed.For instance, only keep cells with at least `min_counts` counts or\n`min_tsse` TSS enrichment scores. This is to filter measurement outliers,\ni.e. \"unreliable\" observations.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "snapatac2.pp.filter_cells(data=@, min_counts=@, min_tsse=@, max_counts=@, max_tsse=@, inplace=@, n_jobs=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.genome.mm10": {
        "Parameters": {},
        "Returns": {
            "type": "snapatac2.genome.Genome",
            "description": null
        },
        "Value": "<snapatac2.genome.Genome object at 0x7f4f676a3190>",
        "Docstring": "\n    A class that encapsulates information about a genome, including its FASTA sequence,\n    its annotation, and chromosome sizes.\n\n    Attributes\n    ----------\n    fasta\n        The path to the FASTA file.\n    annotation\n        The path to the annotation file.\n    chrom_sizes\n        A dictionary containing chromosome names and sizes.\n\n    Raises\n    ------\n    ValueError\n        If `fasta` or `annotation` are not a Path, a string, or a callable.\n    ",
        "description": "A class that encapsulates information about a genome, including its FASTA sequence,its annotation, and chromosome sizes.",
        "example": "",
        "api_type": "unknown",
        "api_calling": [
            "snapatac2.genome.mm10()"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.genome.GRCh38": {
        "Parameters": {},
        "Returns": {
            "type": "snapatac2.genome.Genome",
            "description": null
        },
        "Value": "<snapatac2.genome.Genome object at 0x7f4f676a2d70>",
        "Docstring": "\n    A class that encapsulates information about a genome, including its FASTA sequence,\n    its annotation, and chromosome sizes.\n\n    Attributes\n    ----------\n    fasta\n        The path to the FASTA file.\n    annotation\n        The path to the annotation file.\n    chrom_sizes\n        A dictionary containing chromosome names and sizes.\n\n    Raises\n    ------\n    ValueError\n        If `fasta` or `annotation` are not a Path, a string, or a callable.\n    ",
        "description": "A class that encapsulates information about a genome, including its FASTA sequence,its annotation, and chromosome sizes.",
        "example": "",
        "api_type": "unknown",
        "api_calling": [
            "snapatac2.genome.GRCh38()"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.tl.kmeans": {
        "Parameters": {
            "adata": {
                "type": "Union[internal.AnnData, internal.AnnDataSet, np.ndarray]",
                "default": null,
                "optional": false,
                "description": "The annotated data matrix.",
                "optional_value": false
            },
            "n_clusters": {
                "type": "int",
                "default": null,
                "optional": false,
                "description": "Number of clusters to return.",
                "optional_value": false
            },
            "n_iterations": {
                "type": "int",
                "default": "-1",
                "optional": true,
                "description": "How many iterations of the kmeans clustering algorithm to perform.\nPositive values above 2 define the total number of iterations to perform,\n-1 has the algorithm run until it reaches its optimal clustering.",
                "optional_value": false
            },
            "random_state": {
                "type": "int",
                "default": "0",
                "optional": true,
                "description": "Change the initialization of the optimization.",
                "optional_value": false
            },
            "use_rep": {
                "type": "str",
                "default": "X_spectral",
                "optional": true,
                "description": "Which data in `adata.obsm` to use for clustering. Default is \"X_spectral\".",
                "optional_value": false
            },
            "key_added": {
                "type": "str",
                "default": "kmeans",
                "optional": true,
                "description": "`adata.obs` key under which to add the cluster labels.",
                "optional_value": false
            },
            "inplace": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[np.ndarray]",
            "description": "adds fields to `adata`:\n`adata.obs[key_added]`\nArray of dim (number of samples) that stores the subgroup id\n(`'0'`, `'1'`, ...) for each cell.\n`adata.uns['kmeans']['params']`\nA dict with the values for the parameters `n_clusters`, `random_state`,\nand `n_iterations`."
        },
        "Docstring": "Cluster cells into subgroups using the K-means algorithm, a classical algorithm in data mining.\n\n\nParameters\n----------\nadata\n    The annotated data matrix.\nn_clusters\n    Number of clusters to return.\nn_iterations\n    How many iterations of the kmeans clustering algorithm to perform.\n    Positive values above 2 define the total number of iterations to perform,\n    -1 has the algorithm run until it reaches its optimal clustering.\nrandom_state\n    Change the initialization of the optimization.\nuse_rep\n    Which data in `adata.obsm` to use for clustering. Default is \"X_spectral\".\nkey_added\n    `adata.obs` key under which to add the cluster labels.\n\nReturns\n-------\nadds fields to `adata`:\n`adata.obs[key_added]`\n    Array of dim (number of samples) that stores the subgroup id\n    (`'0'`, `'1'`, ...) for each cell.\n`adata.uns['kmeans']['params']`\n    A dict with the values for the parameters `n_clusters`, `random_state`,\n    and `n_iterations`.",
        "description": "Cluster cells into subgroups using the K-means algorithm, a classical algorithm in data mining.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "snapatac2.tl.kmeans(adata=@, n_clusters=@, n_iterations=@, random_state=@, use_rep=@, key_added=@, inplace=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.read": {
        "Parameters": {
            "filename": {
                "type": "Path",
                "default": null,
                "optional": false,
                "description": "File name of data file.",
                "optional_value": true
            },
            "backed": {
                "type": "Literal['r', 'r+'] | None",
                "default": "r+",
                "optional": true,
                "description": "Default is `r+`.\nIf `'r'`, the file is opened in read-only mode.\nIf `'r+'`, the file is opened in read/write mode.\nIf `None`, the AnnData object is read into memory.",
                "optional_value": true
            },
            "backend": {
                "type": "Literal['hdf5'] | None",
                "default": "None",
                "optional": true,
                "description": null,
                "optional_value": true
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Read `.h5ad`-formatted hdf5 file.\n\nParameters\n----------\n\nfilename: Path\n    File name of data file.\nbacked: Literal['r', 'r+'] | None\n    Default is `r+`.\n    If `'r'`, the file is opened in read-only mode.\n    If `'r+'`, the file is opened in read/write mode.\n    If `None`, the AnnData object is read into memory.\nbackend: Literal['hdf5'] | None",
        "description": "Read `.h5ad`-formatted hdf5 file.",
        "example": "",
        "api_type": "builtin",
        "api_calling": [
            "snapatac2.read(filename=$, backed=$, backend=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.genome.GRCm39": {
        "Parameters": {},
        "Returns": {
            "type": "snapatac2.genome.Genome",
            "description": null
        },
        "Value": "<snapatac2.genome.Genome object at 0x7f4f676a3130>",
        "Docstring": "\n    A class that encapsulates information about a genome, including its FASTA sequence,\n    its annotation, and chromosome sizes.\n\n    Attributes\n    ----------\n    fasta\n        The path to the FASTA file.\n    annotation\n        The path to the annotation file.\n    chrom_sizes\n        A dictionary containing chromosome names and sizes.\n\n    Raises\n    ------\n    ValueError\n        If `fasta` or `annotation` are not a Path, a string, or a callable.\n    ",
        "description": "A class that encapsulates information about a genome, including its FASTA sequence,its annotation, and chromosome sizes.",
        "example": "",
        "api_type": "unknown",
        "api_calling": [
            "snapatac2.genome.GRCm39()"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.genome.hg38": {
        "Parameters": {},
        "Returns": {
            "type": "snapatac2.genome.Genome",
            "description": null
        },
        "Value": "<snapatac2.genome.Genome object at 0x7f4f676a2d70>",
        "Docstring": "\n    A class that encapsulates information about a genome, including its FASTA sequence,\n    its annotation, and chromosome sizes.\n\n    Attributes\n    ----------\n    fasta\n        The path to the FASTA file.\n    annotation\n        The path to the annotation file.\n    chrom_sizes\n        A dictionary containing chromosome names and sizes.\n\n    Raises\n    ------\n    ValueError\n        If `fasta` or `annotation` are not a Path, a string, or a callable.\n    ",
        "description": "A class that encapsulates information about a genome, including its FASTA sequence,its annotation, and chromosome sizes.",
        "example": "",
        "api_type": "unknown",
        "api_calling": [
            "snapatac2.genome.hg38()"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.pp.make_fragment_file": {
        "Parameters": {
            "bam_file": {
                "type": "Path",
                "default": null,
                "optional": false,
                "description": "File name of the BAM file.",
                "optional_value": true
            },
            "output_file": {
                "type": "Path",
                "default": null,
                "optional": false,
                "description": "File name of the output fragment file.",
                "optional_value": true
            },
            "is_paired": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Indicate whether the BAM file contain paired-end reads",
                "optional_value": false
            },
            "barcode_tag": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Extract barcodes from TAG fields of BAM records, e.g., `barcode_tag=\"CB\"`.",
                "optional_value": false
            },
            "barcode_regex": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Extract barcodes from read names of BAM records using regular expressions.\nReguler expressions should contain exactly one capturing group \n(Parentheses group the regex between them) that matches\nthe barcodes. For example, `barcode_regex=\"(..:..:..:..):\\w+$\"`\nextracts `bd:69:Y6:10` from\n`A01535:24:HW2MMDSX2:2:1359:8513:3458:bd:69:Y6:10:TGATAGGTTG`.",
                "optional_value": false
            },
            "umi_tag": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Extract UMI from TAG fields of BAM records.",
                "optional_value": false
            },
            "umi_regex": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Extract UMI from read names of BAM records using regular expressions.\nSee `barcode_regex` for more details.",
                "optional_value": false
            },
            "shift_left": {
                "type": "int",
                "default": "4",
                "optional": true,
                "description": "Insertion site correction for the left end. Note this has no effect on single-end reads.",
                "optional_value": false
            },
            "shift_right": {
                "type": "int",
                "default": "-5",
                "optional": true,
                "description": "Insertion site correction for the right end. Note this has no effect on single-end reads.",
                "optional_value": false
            },
            "min_mapq": {
                "type": "Optional[int]",
                "default": "30",
                "optional": true,
                "description": "Filter the reads based on MAPQ.",
                "optional_value": false
            },
            "chunk_size": {
                "type": "int",
                "default": "50000000",
                "optional": true,
                "description": "The size of data retained in memory when performing sorting. Larger chunk sizes\nresult in faster sorting and greater memory usage.",
                "optional_value": false
            },
            "compression": {
                "type": "Optional[Literal['gzip', 'zstandard']]",
                "default": "None",
                "optional": true,
                "description": "Compression type. If `None`, it is inferred from the suffix.",
                "optional_value": true
            },
            "compression_level": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Compression level. 1-9 for gzip, 1-22 for zstandard.\nIf `None`, it is set to 6 for gzip and 3 for zstandard.",
                "optional_value": false
            },
            "tempdir": {
                "type": "Optional[Path]",
                "default": "None",
                "optional": true,
                "description": "Location to store temporary files. If `None`, system temporary directory\nwill be used.",
                "optional_value": true
            }
        },
        "Returns": {
            "type": "internal.PyFlagStat",
            "description": "PyFlagStat\nVarious statistics.\nSee Also\nimport_data"
        },
        "Docstring": "Convert a BAM file to a fragment file.\n\nConvert a BAM file to a fragment file by performing the following steps:\n\n    1. Filtering: remove reads that are unmapped, not primary alignment, mapq < 30,\n       fails platform/vendor quality checks, or optical duplicate.\n       For paired-end sequencing, it also removes reads that are not properly aligned.\n    2. Deduplicate: Sort the reads by cell barcodes and remove duplicated reads\n       for each unique cell barcode.\n    3. Output: Convert BAM records to fragments (if paired-end) or single-end reads.\n\nThe bam file needn't be sorted or filtered.\n\nNote\n----\nBAM files produced by the 10X Genomics Cell Ranger pipeline are not supported,\nas they contain invalid BAM headers. Specifically, Cell Ranger ATAC <= 2.0 produces BAM\nfiles with no @VN tag in the header, and Cell Ranger ATAC >= 2.1 produces BAM files\nwith invalid @VN tag in the header.\nIt is recommended to use the fragment files produced by Cell Ranger ATAC instead.\n\nParameters\n----------\nbam_file\n    File name of the BAM file.\noutput_file\n    File name of the output fragment file.\nis_paired\n    Indicate whether the BAM file contain paired-end reads\nbarcode_tag\n    Extract barcodes from TAG fields of BAM records, e.g., `barcode_tag=\"CB\"`.\nbarcode_regex\n    Extract barcodes from read names of BAM records using regular expressions.\n    Reguler expressions should contain exactly one capturing group \n    (Parentheses group the regex between them) that matches\n    the barcodes. For example, `barcode_regex=\"(..:..:..:..):\\w+$\"`\n    extracts `bd:69:Y6:10` from\n    `A01535:24:HW2MMDSX2:2:1359:8513:3458:bd:69:Y6:10:TGATAGGTTG`.\numi_tag\n    Extract UMI from TAG fields of BAM records.\numi_regex\n    Extract UMI from read names of BAM records using regular expressions.\n    See `barcode_regex` for more details.\nshift_left\n    Insertion site correction for the left end. Note this has no effect on single-end reads.\nshift_right\n    Insertion site correction for the right end. Note this has no effect on single-end reads.\nmin_mapq\n    Filter the reads based on MAPQ.\nchunk_size\n    The size of data retained in memory when performing sorting. Larger chunk sizes\n    result in faster sorting and greater memory usage.\ncompression\n    Compression type. If `None`, it is inferred from the suffix.\ncompression_level\n    Compression level. 1-9 for gzip, 1-22 for zstandard.\n    If `None`, it is set to 6 for gzip and 3 for zstandard.\ntempdir\n    Location to store temporary files. If `None`, system temporary directory\n    will be used.\n\nReturns\n-------\nPyFlagStat\n    Various statistics.\n\nSee Also\n--------\nimport_data",
        "description": "Convert a BAM file to a fragment file.Convert a BAM file to a fragment file by performing the following steps:\n\n    1. Filtering: remove reads that are unmapped, not primary alignment, mapq < 30,\n       fails platform/vendor quality checks, or optical duplicate.\n       For paired-end sequencing, it also removes reads that are not properly aligned.\n    2. Deduplicate: Sort the reads by cell barcodes and remove duplicated reads\n       for each unique cell barcode.\n    3. Output: Convert BAM records to fragments (if paired-end) or single-end reads.\n\nThe bam file needn't be sorted or filtered.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "snapatac2.pp.make_fragment_file(bam_file=$, output_file=$, is_paired=@, barcode_tag=@, barcode_regex=@, umi_tag=@, umi_regex=@, shift_left=@, shift_right=@, min_mapq=@, chunk_size=@, compression=$, compression_level=@, tempdir=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.AnnData.write": {
        "Parameters": {
            "filename": {
                "type": "Path",
                "default": null,
                "optional": false,
                "description": "File name of the output `.h5ad` file.",
                "optional_value": true
            },
            "backend": {
                "type": "str | None",
                "default": null,
                "optional": false,
                "description": null,
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Write .h5ad-formatted hdf5 file.\n\nParameters\n----------\nfilename: Path\n    File name of the output `.h5ad` file.\nbackend: str | None",
        "description": "Write .h5ad-formatted hdf5 file.",
        "example": "",
        "api_type": "method",
        "api_calling": [
            "snapatac2.AnnData.write(filename=$, backend=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.tl.umap": {
        "Parameters": {
            "adata": {
                "type": "Union[internal.AnnData, internal.AnnDataSet, np.ndarray]",
                "default": null,
                "optional": false,
                "description": "The annotated data matrix.",
                "optional_value": false
            },
            "n_comps": {
                "type": "int",
                "default": "2",
                "optional": true,
                "description": "The number of dimensions of the embedding.",
                "optional_value": false
            },
            "use_dims": {
                "type": "Optional[Union[int, list[int]]]",
                "default": "None",
                "optional": true,
                "description": "Use these dimensions in `use_rep`.",
                "optional_value": false
            },
            "use_rep": {
                "type": "str",
                "default": "X_spectral",
                "optional": true,
                "description": "Use the indicated representation in `.obsm`.",
                "optional_value": false
            },
            "key_added": {
                "type": "str",
                "default": "umap",
                "optional": true,
                "description": "`adata.obs` key under which to add the cluster labels.",
                "optional_value": false
            },
            "random_state": {
                "type": "int",
                "default": "0",
                "optional": true,
                "description": "Random seed.",
                "optional_value": false
            },
            "inplace": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to store the result in the anndata object.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[np.ndarray]",
            "description": "np.ndarray | None\nif `inplace=True` it stores UMAP embedding in\n`adata.obsm[\"X_`key_added`\"]`.\nOtherwise, it returns the result as a numpy array."
        },
        "Docstring": "Parameters\n----------\nadata\n    The annotated data matrix.\nn_comps\n    The number of dimensions of the embedding.\nuse_dims\n    Use these dimensions in `use_rep`.\nuse_rep\n    Use the indicated representation in `.obsm`.\nkey_added\n    `adata.obs` key under which to add the cluster labels.\nrandom_state\n    Random seed.\ninplace\n    Whether to store the result in the anndata object.\n\nReturns\n-------\nnp.ndarray | None\n    if `inplace=True` it stores UMAP embedding in\n    `adata.obsm[\"X_`key_added`\"]`.\n    Otherwise, it returns the result as a numpy array.",
        "description": "",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "snapatac2.tl.umap(adata=@, n_comps=@, use_dims=@, use_rep=@, key_added=@, random_state=@, inplace=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.pp.make_peak_matrix": {
        "Parameters": {
            "adata": {
                "type": "Union[internal.AnnData, internal.AnnDataSet]",
                "default": null,
                "optional": false,
                "description": "The (annotated) data matrix of shape `n_obs` x `n_vars`.\nRows correspond to cells and columns to regions.",
                "optional_value": false
            },
            "use_rep": {
                "type": "Optional[Union[str, list[str]]]",
                "default": "None",
                "optional": true,
                "description": "This is used to read peak information from `.uns[use_rep]`.\nThe peaks can also be provided by a list of strings:\n[\"chr1:1-100\", \"chr2:2-200\"].",
                "optional_value": false
            },
            "inplace": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to add the tile matrix to the AnnData object or return a new AnnData object.",
                "optional_value": false
            },
            "file": {
                "type": "Optional[Path]",
                "default": "None",
                "optional": true,
                "description": "File name of the output h5ad file used to store the result. If provided,\nresult will be saved to a backed AnnData, otherwise an in-memory AnnData\nis used. This has no effect when `inplace=True`.",
                "optional_value": true
            },
            "backend": {
                "type": "Literal['hdf5']",
                "default": "hdf5",
                "optional": true,
                "description": "The backend to use for storing the result. If `None`, the default backend will be used.",
                "optional_value": true
            },
            "peak_file": {
                "type": "Optional[Path]",
                "default": "None",
                "optional": true,
                "description": "Bed file containing the peaks. If provided, peak information will be read\nfrom this file.",
                "optional_value": true
            },
            "chunk_size": {
                "type": "int",
                "default": "500",
                "optional": true,
                "description": "Chunk size",
                "optional_value": false
            },
            "use_x": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If True, use the matrix stored in `.X` as raw counts.\nOtherwise the `.obsm['insertion']` is used.",
                "optional_value": false
            },
            "min_frag_size": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Minimum fragment size to include.",
                "optional_value": false
            },
            "max_frag_size": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Maximum fragment size to include.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "internal.AnnData",
            "description": "AnnData | ad.AnnData | None\nAn annotated data matrix of shape `n_obs` x `n_vars`. Rows correspond to\ncells and columns to peaks. If `file=None`, an in-memory AnnData will be\nreturned, otherwise a backed AnnData is returned.\nSee Also\nadd_tile_matrix\nmake_gene_matrix"
        },
        "Docstring": "Generate cell by peak count matrix.\n\nThis function will generate a cell by peak count matrix and store it in a \nnew .h5ad file.\n\n:func:`~snapatac2.pp.import_data` must be ran first in order to use this function.\n\nParameters\n----------\nadata\n    The (annotated) data matrix of shape `n_obs` x `n_vars`.\n    Rows correspond to cells and columns to regions.\nuse_rep\n    This is used to read peak information from `.uns[use_rep]`.\n    The peaks can also be provided by a list of strings:\n    [\"chr1:1-100\", \"chr2:2-200\"].\ninplace\n    Whether to add the tile matrix to the AnnData object or return a new AnnData object.\nfile\n    File name of the output h5ad file used to store the result. If provided,\n    result will be saved to a backed AnnData, otherwise an in-memory AnnData\n    is used. This has no effect when `inplace=True`.\nbackend\n    The backend to use for storing the result. If `None`, the default backend will be used.\npeak_file\n    Bed file containing the peaks. If provided, peak information will be read\n    from this file.\nchunk_size\n    Chunk size\nuse_x\n    If True, use the matrix stored in `.X` as raw counts.\n    Otherwise the `.obsm['insertion']` is used.\nmin_frag_size\n    Minimum fragment size to include.\nmax_frag_size\n    Maximum fragment size to include.\n\nReturns\n-------\nAnnData | ad.AnnData | None\n    An annotated data matrix of shape `n_obs` x `n_vars`. Rows correspond to\n    cells and columns to peaks. If `file=None`, an in-memory AnnData will be\n    returned, otherwise a backed AnnData is returned.\n\nSee Also\n--------\nadd_tile_matrix\nmake_gene_matrix\n\nExamples\n--------\n>>> import snapatac2 as snap\n>>> data = snap.pp.import_data(snap.datasets.pbmc500(downsample=True), chrom_sizes=snap.genome.hg38, sorted_by_barcode=False)\n>>> peak_mat = snap.pp.make_peak_matrix(data, peak_file=snap.datasets.cre_HEA())\n>>> print(peak_mat)\nAnnData object with n_obs \u00d7 n_vars = 585 \u00d7 1154611\n    obs: 'n_fragment', 'frac_dup', 'frac_mito'",
        "description": "Generate cell by peak count matrix.This function will generate a cell by peak count matrix and store it in a \nnew .h5ad file.\n\n:func:`~snapatac2.pp.import_data` must be ran first in order to use this function.",
        "example": "Examples\n--------\n>>> import snapatac2 as snap\n>>> data = snap.pp.import_data(snap.datasets.pbmc500(downsample=True), chrom_sizes=snap.genome.hg38, sorted_by_barcode=False)\n>>> peak_mat = snap.pp.make_peak_matrix(data, peak_file=snap.datasets.cre_HEA())\n>>> print(peak_mat)\nAnnData object with n_obs \u00d7 n_vars = 585 \u00d7 1154611\n    obs: 'n_fragment', 'frac_dup', 'frac_mito'",
        "api_type": "function",
        "api_calling": [
            "snapatac2.pp.make_peak_matrix(adata=@, use_rep=@, inplace=@, file=$, backend=$, peak_file=$, chunk_size=@, use_x=@, min_frag_size=@, max_frag_size=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.pp.harmony": {
        "Parameters": {
            "adata": {
                "type": "Union[internal.AnnData, internal.AnnDataSet, np.ndarray]",
                "default": null,
                "optional": false,
                "description": "The (annotated) data matrix of shape `n_obs` x `n_vars`.\nRows correspond to cells and columns to regions.",
                "optional_value": false
            },
            "batch": {
                "type": "Union[str, list[str]]",
                "default": null,
                "optional": false,
                "description": "The name of the column in ``adata.obs`` that differentiates\namong experiments/batches.",
                "optional_value": false
            },
            "use_rep": {
                "type": "str",
                "default": "X_spectral",
                "optional": true,
                "description": "The name of the field in ``adata.obsm`` where the lower dimensional\nrepresentation is stored.",
                "optional_value": false
            },
            "use_dims": {
                "type": "Optional[Union[int, list[int]]]",
                "default": "None",
                "optional": true,
                "description": "Use these dimensions in `use_rep`.",
                "optional_value": false
            },
            "groupby": {
                "type": "Optional[Union[str, list[str]]]",
                "default": "None",
                "optional": true,
                "description": "If specified, split the data into groups and perform batch correction\non each group separately.",
                "optional_value": false
            },
            "key_added": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "If specified, add the result to ``adata.obsm`` with this key. Otherwise,\nit will be stored in ``adata.obsm[use_rep + \"_harmony\"]``.",
                "optional_value": false
            },
            "inplace": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to store the result in the anndata object.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[np.ndarray]",
            "description": "np.ndarray | None\nif `inplace=True` it updates adata with the field\n``adata.obsm[`use_rep`_harmony]``, containing principal components\nadjusted by Harmony such that different experiments are integrated.\nOtherwise, it returns the result as a numpy array."
        },
        "Docstring": "Use harmonypy to integrate different experiments.\n\nHarmony is an algorithm for integrating single-cell\ndata from multiple experiments. This function uses the python\nport of Harmony, ``harmonypy``, to integrate single-cell data\nstored in an AnnData object. This function should be run after performing\ndimension reduction.\n\nParameters\n----------\nadata\n    The (annotated) data matrix of shape `n_obs` x `n_vars`.\n    Rows correspond to cells and columns to regions.\nbatch\n    The name of the column in ``adata.obs`` that differentiates\n    among experiments/batches.\nuse_rep\n    The name of the field in ``adata.obsm`` where the lower dimensional\n    representation is stored.\nuse_dims\n    Use these dimensions in `use_rep`.\ngroupby\n    If specified, split the data into groups and perform batch correction\n    on each group separately.\nkey_added\n    If specified, add the result to ``adata.obsm`` with this key. Otherwise,\n    it will be stored in ``adata.obsm[use_rep + \"_harmony\"]``.\ninplace\n    Whether to store the result in the anndata object.\nkwargs\n    Any additional arguments will be passed to\n    ``harmonypy.run_harmony()``.\n\nReturns\n-------\nnp.ndarray | None\n    if `inplace=True` it updates adata with the field\n    ``adata.obsm[`use_rep`_harmony]``, containing principal components\n    adjusted by Harmony such that different experiments are integrated.\n    Otherwise, it returns the result as a numpy array.",
        "description": "Use harmonypy to integrate different experiments.Harmony is an algorithm for integrating single-cell\ndata from multiple experiments. This function uses the python\nport of Harmony, ``harmonypy``, to integrate single-cell data\nstored in an AnnData object. This function should be run after performing\ndimension reduction.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "snapatac2.pp.harmony(adata=@, batch=@, use_rep=@, use_dims=@, groupby=@, key_added=@, inplace=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.tl.marker_regions": {
        "Parameters": {
            "data": {
                "type": "Union[AnnData, AnnDataSet]",
                "default": null,
                "optional": false,
                "description": "AnnData or AnnDataSet object.",
                "optional_value": true
            },
            "groupby": {
                "type": "Union[str, list[str]]",
                "default": null,
                "optional": false,
                "description": "Grouping variable.",
                "optional_value": false
            },
            "pvalue": {
                "type": "float",
                "default": "0.01",
                "optional": true,
                "description": "P-value threshold.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "dict[str, list[str]]",
            "description": ""
        },
        "Docstring": "A quick-and-dirty way to get marker regions.\n\nParameters\n----------\ndata\n    AnnData or AnnDataSet object.\ngroupby\n    Grouping variable.\npvalue\n    P-value threshold.",
        "description": "A quick-and-dirty way to get marker regions.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "snapatac2.tl.marker_regions(data=$, groupby=@, pvalue=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.ex.export_fragments": {
        "Parameters": {
            "adata": {
                "type": "Union[internal.AnnData, internal.AnnDataSet]",
                "default": null,
                "optional": false,
                "description": "The (annotated) data matrix of shape `n_obs` x `n_vars`.\nRows correspond to cells and columns to regions.",
                "optional_value": false
            },
            "groupby": {
                "type": "Union[str, list[str]]",
                "default": null,
                "optional": false,
                "description": "Group the cells. If a `str`, groups are obtained from\n`.obs[groupby]`.",
                "optional_value": false
            },
            "selections": {
                "type": "Optional[list[str]]",
                "default": "None",
                "optional": true,
                "description": "Export only the selected groups.",
                "optional_value": false
            },
            "ids": {
                "type": "Optional[Union[str, list[str]]]",
                "default": "None",
                "optional": true,
                "description": "Cell ids add to the bed records. If `None`, `.obs_names` is used.",
                "optional_value": false
            },
            "min_frag_length": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Minimum fragment length to be included in the computation.",
                "optional_value": false
            },
            "max_frag_length": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Maximum fragment length to be included in the computation.",
                "optional_value": false
            },
            "out_dir": {
                "type": "Path",
                "default": "./",
                "optional": true,
                "description": "Directory for saving the outputs.",
                "optional_value": true
            },
            "prefix": {
                "type": "str",
                "default": "",
                "optional": true,
                "description": "Text added to the output file name.",
                "optional_value": false
            },
            "suffix": {
                "type": "str",
                "default": ".bed.zst",
                "optional": true,
                "description": "Text added to the output file name.",
                "optional_value": false
            },
            "compression": {
                "type": "Optional[Literal['gzip', 'zstandard']]",
                "default": "None",
                "optional": true,
                "description": "Compression type. If `None`, it is inferred from the suffix.",
                "optional_value": true
            },
            "compression_level": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Compression level. 1-9 for gzip, 1-22 for zstandard.\nIf `None`, it is set to 6 for gzip and 3 for zstandard.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "dict[str, str]",
            "description": "dict[str, str]\nA dictionary contains `(groupname, filename)` pairs. The file names are\nformatted as `{prefix}{groupname}{suffix}`.\nSee Also\nexport_coverage"
        },
        "Docstring": "Export and save fragments in a BED format file.\n\nParameters\n----------\nadata\n    The (annotated) data matrix of shape `n_obs` x `n_vars`.\n    Rows correspond to cells and columns to regions.\ngroupby\n    Group the cells. If a `str`, groups are obtained from\n    `.obs[groupby]`.\nselections\n    Export only the selected groups.\nids\n    Cell ids add to the bed records. If `None`, `.obs_names` is used.\nmin_frag_length\n    Minimum fragment length to be included in the computation.\nmax_frag_length\n    Maximum fragment length to be included in the computation.\nout_dir\n    Directory for saving the outputs.\nprefix\n    Text added to the output file name.\nsuffix\n    Text added to the output file name.\ncompression\n    Compression type. If `None`, it is inferred from the suffix.\ncompression_level\n    Compression level. 1-9 for gzip, 1-22 for zstandard.\n    If `None`, it is set to 6 for gzip and 3 for zstandard.\n\nReturns\n-------\ndict[str, str]\n    A dictionary contains `(groupname, filename)` pairs. The file names are\n    formatted as `{prefix}{groupname}{suffix}`.\n\nSee Also\n--------\nexport_coverage",
        "description": "Export and save fragments in a BED format file.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "snapatac2.ex.export_fragments(adata=@, groupby=@, selections=@, ids=@, min_frag_length=@, max_frag_length=@, out_dir=$, prefix=@, suffix=@, compression=$, compression_level=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.pl.spectral_eigenvalues": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix.",
                "optional_value": true
            },
            "width": {
                "type": "int",
                "default": "600",
                "optional": true,
                "description": "The width of the plot",
                "optional_value": false
            },
            "height": {
                "type": "int",
                "default": "400",
                "optional": true,
                "description": "The height of the plot",
                "optional_value": false
            },
            "show": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Show the figure.",
                "optional_value": false
            },
            "interactive": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to make interactive plot",
                "optional_value": false
            },
            "out_file": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Path of the output file for saving the output image, end with\n'.svg' or '.pdf' or '.png' or '.html'.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional['plotly.graph_objects.Figure']",
            "description": "'plotly.graph_objects.Figure' | None\nIf `show=False` and `out_file=None`, an `plotly.graph_objects.Figure` will be\nreturned, which can then be further customized using the plotly API."
        },
        "Docstring": "Plot the eigenvalues of spectral embedding.\n\nParameters\n----------\nadata\n    Annotated data matrix.\nwidth\n    The width of the plot\nheight\n    The height of the plot\nshow\n    Show the figure.\ninteractive\n    Whether to make interactive plot\nout_file\n    Path of the output file for saving the output image, end with\n    '.svg' or '.pdf' or '.png' or '.html'.\n\nReturns\n-------\n'plotly.graph_objects.Figure' | None\n    If `show=False` and `out_file=None`, an `plotly.graph_objects.Figure` will be \n    returned, which can then be further customized using the plotly API.",
        "description": "Plot the eigenvalues of spectral embedding.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "snapatac2.pl.spectral_eigenvalues(adata=$, width=@, height=@, show=@, interactive=@, out_file=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.pp.filter_doublets": {
        "Parameters": {
            "adata": {
                "type": "Union[internal.AnnData, list[internal.AnnData]]",
                "default": null,
                "optional": false,
                "description": "The (annotated) data matrix of shape `n_obs` x `n_vars`.\nRows correspond to cells and columns to regions.",
                "optional_value": false
            },
            "probability_threshold": {
                "type": "Optional[float]",
                "default": "0.5",
                "optional": true,
                "description": "Threshold for doublet probability. Doublet probability greater than\nthis threshold will be removed. The default value is 0.5. Using a lower\nthreshold will remove more cells.",
                "optional_value": false
            },
            "score_threshold": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Threshold for doublet score. Doublet score greater than this threshold\nwill be removed. Only one of `probability_threshold` and `score_threshold`\ncan be set. Using `score_threshold` is not recommended for most cases.",
                "optional_value": false
            },
            "inplace": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Perform computation inplace or return result.",
                "optional_value": false
            },
            "n_jobs": {
                "type": "int",
                "default": "8",
                "optional": true,
                "description": "Number of jobs to run in parallel.",
                "optional_value": false
            },
            "verbose": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to print progress messages.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[np.ndarray]",
            "description": "np.ndarray | None:\nIf `inplace = True`, directly subsets the data matrix. Otherwise return\na boolean index mask that does filtering, where `True` means that the\ncell is kept, `False` means the cell is removed.\nSee Also\nscrublet"
        },
        "Docstring": "Remove doublets according to the doublet probability or doublet score.\n\nThe user can choose to remove doublets by either the doublet probability or the doublet score.\n:func:`~snapatac2.pp.scrublet` must be ran first in order to use this function.\n\nParameters\n----------\nadata\n    The (annotated) data matrix of shape `n_obs` x `n_vars`.\n    Rows correspond to cells and columns to regions.\nprobability_threshold\n    Threshold for doublet probability. Doublet probability greater than\n    this threshold will be removed. The default value is 0.5. Using a lower\n    threshold will remove more cells.\nscore_threshold\n    Threshold for doublet score. Doublet score greater than this threshold\n    will be removed. Only one of `probability_threshold` and `score_threshold`\n    can be set. Using `score_threshold` is not recommended for most cases.\ninplace\n    Perform computation inplace or return result.\nn_jobs\n    Number of jobs to run in parallel.\nverbose\n    Whether to print progress messages.\n\nReturns\n-------\nnp.ndarray | None:\n    If `inplace = True`, directly subsets the data matrix. Otherwise return \n    a boolean index mask that does filtering, where `True` means that the\n    cell is kept, `False` means the cell is removed.\n\nSee Also\n--------\nscrublet",
        "description": "Remove doublets according to the doublet probability or doublet score.The user can choose to remove doublets by either the doublet probability or the doublet score.\n:func:`~snapatac2.pp.scrublet` must be ran first in order to use this function.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "snapatac2.pp.filter_doublets(adata=@, probability_threshold=@, score_threshold=@, inplace=@, n_jobs=@, verbose=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.genome.Genome": {
        "Parameters": {
            "fasta": {
                "type": "Union[Path, Callable[[], Path]]",
                "default": null,
                "optional": false,
                "description": "The path to the FASTA file.",
                "optional_value": true
            },
            "annotation": {
                "type": "Union[Path, Callable[[], Path]]",
                "default": null,
                "optional": false,
                "description": "The path to the annotation file.",
                "optional_value": true
            },
            "chrom_sizes": {
                "type": "Optional[dict[str, int]]",
                "default": "None",
                "optional": true,
                "description": "A dictionary containing chromosome names and sizes.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "A class that encapsulates information about a genome, including its FASTA sequence,\nits annotation, and chromosome sizes.\n\nAttributes\n----------\nfasta\n    The path to the FASTA file.\nannotation\n    The path to the annotation file.\nchrom_sizes\n    A dictionary containing chromosome names and sizes.\n\nRaises\n------\nValueError\n    If `fasta` or `annotation` are not a Path, a string, or a callable.",
        "description": "A class that encapsulates information about a genome, including its FASTA sequence,its annotation, and chromosome sizes.",
        "example": "",
        "api_type": "class",
        "api_calling": [
            "snapatac2.genome.Genome(fasta=$, annotation=$, chrom_sizes=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.AnnData": {
        "Parameters": {
            "filename": {
                "type": null,
                "default": null,
                "optional": false,
                "description": "Name of backing file.",
                "optional_value": true
            },
            "X": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "A #observations \u00d7 #variables data matrix. A view of the data is used if the\ndata type matches, otherwise, a copy is made.",
                "optional_value": true
            },
            "obs": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "Key-indexed one-dimensional observations annotation of length #observations.",
                "optional_value": true
            },
            "var": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "Key-indexed one-dimensional variables annotation of length #variables.",
                "optional_value": true
            },
            "obsm": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "Key-indexed multi-dimensional observations annotation of length #observations.\nIf passing a :class:`~numpy.ndarray`, it needs to have a structured datatype.",
                "optional_value": true
            },
            "varm": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "Key-indexed multi-dimensional variables annotation of length #variables.\nIf passing a :class:`~numpy.ndarray`, it needs to have a structured datatype.",
                "optional_value": true
            },
            "uns": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "Key-indexed unstructured annotation.",
                "optional_value": true
            },
            "backend": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "An annotated data matrix.\n\n`AnnData` stores a data matrix `X` together with annotations of\nobservations `obs` (`obsm`, `obsp`), variables `var` (`varm`, `varp`),\nand unstructured annotations `uns`.\n`AnnData` is stored as a HDF5 file. Opening/creating an AnnData object\ndoes not read data from the HDF5 file. Data is copied to memory only when\nindividual element is requested (or when cache is turned on).\n\nParameters\n----------\nX\n    A #observations \u00d7 #variables data matrix. A view of the data is used if the\n    data type matches, otherwise, a copy is made.\nobs\n    Key-indexed one-dimensional observations annotation of length #observations.\nvar\n    Key-indexed one-dimensional variables annotation of length #variables.\nuns\n    Key-indexed unstructured annotation.\nobsm\n    Key-indexed multi-dimensional observations annotation of length #observations.\n    If passing a :class:`~numpy.ndarray`, it needs to have a structured datatype.\nvarm\n    Key-indexed multi-dimensional variables annotation of length #variables.\n    If passing a :class:`~numpy.ndarray`, it needs to have a structured datatype.\nfilename\n    Name of backing file.\n\nNote\n----\nThis is a backed AnnData. You can use :func:`~AnnData.to_memory` to convert\nit to an in-memory AnnData object. See\n`here <https://anndata.readthedocs.io/en/latest/index.html>`_\nfor the documentation of in-memory AnnData objects.\n\nSee Also\n--------\nread\nread_mtx\nread_csv",
        "description": "An annotated data matrix.`AnnData` stores a data matrix `X` together with annotations of\nobservations `obs` (`obsm`, `obsp`), variables `var` (`varm`, `varp`),\nand unstructured annotations `uns`.\n`AnnData` is stored as a HDF5 file. Opening/creating an AnnData object\ndoes not read data from the HDF5 file. Data is copied to memory only when\nindividual element is requested (or when cache is turned on).",
        "example": "",
        "api_type": "class",
        "api_calling": [
            "snapatac2.AnnData(filename=$, X=$, obs=$, var=$, obsm=$, varm=$, uns=$, backend=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.AnnData.copy": {
        "Parameters": {
            "filename": {
                "type": null,
                "default": null,
                "optional": false,
                "description": "File name of the output `.h5ad` file.",
                "optional_value": true
            },
            "backend": {
                "type": "str | None",
                "default": null,
                "optional": false,
                "description": null,
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": "AnnData"
        },
        "Docstring": "Copy the AnnData object.\n\nParameters\n----------\nfilename\n    File name of the output `.h5ad` file.\nbackend: str | None\n\nReturns\n-------\nAnnData",
        "description": "Copy the AnnData object.",
        "example": "",
        "api_type": "method",
        "api_calling": [
            "snapatac2.AnnData.copy(filename=$, backend=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.AnnData.is_closed": {
        "Parameters": {},
        "Returns": {
            "type": null,
            "description": "bool"
        },
        "Docstring": "If the AnnData object has been closed.\n\nReturns\n-------\nbool",
        "description": "If the AnnData object has been closed.",
        "example": "",
        "api_type": "method",
        "api_calling": [
            "snapatac2.AnnData.is_closed()"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.AnnData.open": {
        "Parameters": {
            "mode": {
                "type": null,
                "default": "r",
                "optional": true,
                "description": "",
                "optional_value": true
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Reopen a closed AnnData object.",
        "description": "Reopen a closed AnnData object.",
        "example": "",
        "api_type": "method",
        "api_calling": [
            "snapatac2.AnnData.open(mode=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.metrics.frag_size_distr": {
        "Parameters": {
            "adata": {
                "type": "Union[internal.AnnData, list[internal.AnnData]]",
                "default": null,
                "optional": false,
                "description": "The (annotated) data matrix of shape `n_obs` x `n_vars`.\nRows correspond to cells and columns to regions.\n`adata` could also be a list of AnnData objects.\nIn this case, the function will be applied to each AnnData object in parallel.",
                "optional_value": false
            },
            "max_recorded_size": {
                "type": "int",
                "default": "1000",
                "optional": true,
                "description": "The maximum fragment size to record in the result.\nFragments with length larger than `max_recorded_size` will be recorded in the first\nposition of the result vector.",
                "optional_value": false
            },
            "add_key": {
                "type": "str",
                "default": "frag_size_distr",
                "optional": true,
                "description": "Key used to store the result in `adata.uns`.",
                "optional_value": false
            },
            "inplace": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to add the results to `adata.uns` or return it.",
                "optional_value": false
            },
            "n_jobs": {
                "type": "int",
                "default": "8",
                "optional": true,
                "description": "Number of jobs to run in parallel when `adata` is a list.\nIf `n_jobs=-1`, all CPUs will be used.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[Union[np.ndarray, list[np.ndarray]]]",
            "description": "np.ndarray | list[np.ndarray] | None\nIf `inplace = True`, directly adds the results to `adata.uns['`add_key`']`.\nOtherwise return the results."
        },
        "Docstring": "Compute the fragment size distribution of the dataset. \n\nThis function computes the fragment size distribution of the dataset.\nNote that it does not operate at the single-cell level.\nThe result is stored in a vector where each element represents the number of fragments\nand the index represents the fragment length. The first posision of the vector is\nreserved for fragments with size larger than the `max_recorded_size` parameter.\n:func:`~snapatac2.pp.import_data` must be ran first in order to use this function.\n\nParameters\n----------\nadata\n    The (annotated) data matrix of shape `n_obs` x `n_vars`.\n    Rows correspond to cells and columns to regions.\n    `adata` could also be a list of AnnData objects.\n    In this case, the function will be applied to each AnnData object in parallel.\nmax_recorded_size\n    The maximum fragment size to record in the result.\n    Fragments with length larger than `max_recorded_size` will be recorded in the first\n    position of the result vector.\nadd_key\n    Key used to store the result in `adata.uns`.\ninplace\n    Whether to add the results to `adata.uns` or return it.\nn_jobs\n    Number of jobs to run in parallel when `adata` is a list.\n    If `n_jobs=-1`, all CPUs will be used.\n\nReturns\n-------\nnp.ndarray | list[np.ndarray] | None\n    If `inplace = True`, directly adds the results to `adata.uns['`add_key`']`.\n    Otherwise return the results.",
        "description": "Compute the fragment size distribution of the dataset. This function computes the fragment size distribution of the dataset.\nNote that it does not operate at the single-cell level.\nThe result is stored in a vector where each element represents the number of fragments\nand the index represents the fragment length. The first posision of the vector is\nreserved for fragments with size larger than the `max_recorded_size` parameter.\n:func:`~snapatac2.pp.import_data` must be ran first in order to use this function.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "snapatac2.metrics.frag_size_distr(adata=@, max_recorded_size=@, add_key=@, inplace=@, n_jobs=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.metrics.tsse": {
        "Parameters": {
            "adata": {
                "type": "Union[internal.AnnData, list[internal.AnnData]]",
                "default": null,
                "optional": false,
                "description": "The (annotated) data matrix of shape `n_obs` x `n_vars`.\nRows correspond to cells and columns to regions.\n`adata` could also be a list of AnnData objects.\nIn this case, the function will be applied to each AnnData object in parallel.",
                "optional_value": false
            },
            "gene_anno": {
                "type": "Union[Genome, Path]",
                "default": null,
                "optional": false,
                "description": "A :class:`~snapatac2.Genome` object or a GTF/GFF file containing the gene annotation.",
                "optional_value": true
            },
            "inplace": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to add the results to `adata.obs` or return it as a dictionary.",
                "optional_value": false
            },
            "n_jobs": {
                "type": "int",
                "default": "8",
                "optional": true,
                "description": "Number of jobs to run in parallel when `adata` is a list.\nIf `n_jobs=-1`, all CPUs will be used.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[Union[np.ndarray, list[np.ndarray]]]",
            "description": "np.ndarray | list[np.ndarray] | None\nIf `inplace = True`, directly adds the results to `adata.obs['tsse']`.\nOtherwise return the results."
        },
        "Docstring": "Compute the TSS enrichment score (TSSe) for each cell.\n\n:func:`~snapatac2.pp.import_data` must be ran first in order to use this function.\n\nParameters\n----------\nadata\n    The (annotated) data matrix of shape `n_obs` x `n_vars`.\n    Rows correspond to cells and columns to regions.\n    `adata` could also be a list of AnnData objects.\n    In this case, the function will be applied to each AnnData object in parallel.\ngene_anno\n    A :class:`~snapatac2.Genome` object or a GTF/GFF file containing the gene annotation.\ninplace\n    Whether to add the results to `adata.obs` or return it as a dictionary.\nn_jobs\n    Number of jobs to run in parallel when `adata` is a list.\n    If `n_jobs=-1`, all CPUs will be used.\n\nReturns\n-------\nnp.ndarray | list[np.ndarray] | None\n    If `inplace = True`, directly adds the results to `adata.obs['tsse']`.\n    Otherwise return the results.\n\nExamples\n--------\n>>> import snapatac2 as snap\n>>> data = snap.pp.import_data(snap.datasets.pbmc500(downsample=True), chrom_sizes=snap.genome.hg38, sorted_by_barcode=False)\n>>> snap.metrics.tsse(data, snap.genome.hg38)\n>>> print(data.obs['tsse'].head())\nAAACTGCAGACTCGGA-1    32.129514\nAAAGATGCACCTATTT-1    22.052786\nAAAGATGCAGATACAA-1    27.109808\nAAAGGGCTCGCTCTAC-1    24.990329\nAAATGAGAGTCCCGCA-1    33.264463\nName: tsse, dtype: float64",
        "description": "Compute the TSS enrichment score (TSSe) for each cell.:func:`~snapatac2.pp.import_data` must be ran first in order to use this function.",
        "example": "Examples\n--------\n>>> import snapatac2 as snap\n>>> data = snap.pp.import_data(snap.datasets.pbmc500(downsample=True), chrom_sizes=snap.genome.hg38, sorted_by_barcode=False)\n>>> snap.metrics.tsse(data, snap.genome.hg38)\n>>> print(data.obs['tsse'].head())\nAAACTGCAGACTCGGA-1    32.129514\nAAAGATGCACCTATTT-1    22.052786\nAAAGATGCAGATACAA-1    27.109808\nAAAGGGCTCGCTCTAC-1    24.990329\nAAATGAGAGTCCCGCA-1    33.264463\nName: tsse, dtype: float64",
        "api_type": "function",
        "api_calling": [
            "snapatac2.metrics.tsse(adata=@, gene_anno=$, inplace=@, n_jobs=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.pp.knn": {
        "Parameters": {
            "adata": {
                "type": "Union[internal.AnnData, internal.AnnDataSet, np.ndarray]",
                "default": null,
                "optional": false,
                "description": "Annotated data matrix or numpy array.",
                "optional_value": false
            },
            "n_neighbors": {
                "type": "int",
                "default": "50",
                "optional": true,
                "description": "The number of nearest neighbors to be searched.",
                "optional_value": false
            },
            "use_dims": {
                "type": "Optional[Union[int, list[int]]]",
                "default": "None",
                "optional": true,
                "description": "The dimensions used for computation.",
                "optional_value": false
            },
            "use_rep": {
                "type": "str",
                "default": "X_spectral",
                "optional": true,
                "description": "The key for the matrix",
                "optional_value": false
            },
            "method": {
                "type": "Literal['kdtree', 'hora', 'pynndescent']",
                "default": "kdtree",
                "optional": true,
                "description": "Can be one of the following:\n- 'kdtree': use the kdtree algorithm to find the nearest neighbors.\n- 'hora': use the HNSW algorithm to find the approximate nearest neighbors.\n- 'pynndescent': use the pynndescent algorithm to find the approximate nearest neighbors.",
                "optional_value": true
            },
            "inplace": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to store the result in the anndata object.",
                "optional_value": false
            },
            "random_state": {
                "type": "int",
                "default": "0",
                "optional": true,
                "description": "Random seed for approximate nearest neighbor search.\nNote that this is only used when `method='pynndescent'`.\nCurrently 'hora' does not support random seed, so the result of 'hora' is not reproducible.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[csr_matrix]",
            "description": "csr_matrix | None\nif `inplace=True`, store KNN in `.obsp['distances']`.\nOtherwise, return a sparse matrix."
        },
        "Docstring": "Compute a neighborhood graph of observations.\n\nComputes a neighborhood graph of observations stored in `adata` using\nthe method specified by `method`. The distance metric used is Euclidean.\n\nParameters\n----------\nadata\n    Annotated data matrix or numpy array.\nn_neighbors\n    The number of nearest neighbors to be searched.\nuse_dims\n    The dimensions used for computation.\nuse_rep\n    The key for the matrix\nmethod\n    Can be one of the following:\n    - 'kdtree': use the kdtree algorithm to find the nearest neighbors.\n    - 'hora': use the HNSW algorithm to find the approximate nearest neighbors.\n    - 'pynndescent': use the pynndescent algorithm to find the approximate nearest neighbors.\ninplace\n    Whether to store the result in the anndata object.\nrandom_state\n    Random seed for approximate nearest neighbor search.\n    Note that this is only used when `method='pynndescent'`.\n    Currently 'hora' does not support random seed, so the result of 'hora' is not reproducible.\n\nReturns\n-------\ncsr_matrix | None\n    if `inplace=True`, store KNN in `.obsp['distances']`.\n    Otherwise, return a sparse matrix.",
        "description": "Compute a neighborhood graph of observations.Computes a neighborhood graph of observations stored in `adata` using\nthe method specified by `method`. The distance metric used is Euclidean.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "snapatac2.pp.knn(adata=@, n_neighbors=@, use_dims=@, use_rep=@, method=$, inplace=@, random_state=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.datasets.cis_bp": {
        "Parameters": {
            "unique": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "A transcription factor may have multiple motifs. If `unique=True`, \nonly the motifs with the highest information content will be selected.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "list[PyDNAMotif]",
            "description": "list[PyDNAMotif]\nA list of motifs.\nSee Also\n:func:`~snapatac2.tl.motif_enrichment`: compute motif enrichment."
        },
        "Docstring": "A list of transcription factor motifs curated by the CIS-BP database.\n\nThis function returns motifs curated from the CIS-BP database [Weirauch14]_.\nThe motifs can be used to scan the genome for potential binding sites and\nto perform motif enrichment analysis.\n\nParameters\n----------\nunique\n    A transcription factor may have multiple motifs. If `unique=True`, \n    only the motifs with the highest information content will be selected.\n\nReturns\n-------\nlist[PyDNAMotif]\n    A list of motifs.\n\nSee Also\n--------\n:func:`~snapatac2.tl.motif_enrichment`: compute motif enrichment.",
        "description": "A list of transcription factor motifs curated by the CIS-BP database.This function returns motifs curated from the CIS-BP database [Weirauch14]_.\nThe motifs can be used to scan the genome for potential binding sites and\nto perform motif enrichment analysis.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "snapatac2.datasets.cis_bp(unique=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.tl.link_tf_to_gene": {
        "Parameters": {
            "network": {
                "type": "rx.PyDiGraph",
                "default": null,
                "optional": false,
                "description": "",
                "optional_value": true
            }
        },
        "Returns": {
            "type": "rx.PyDiGraph",
            "description": ""
        },
        "Docstring": "Contruct a genetic network by linking TFs to target genes.\n\nConvert the network to a genetic network.\n:func:`~snapatac2.tl.add_tf_binding` must be ran first in order to use this function.\n\nParameters\n----------\n\nReturns \n-------\nrx.PyDiGraph",
        "description": "Contruct a genetic network by linking TFs to target genes.Convert the network to a genetic network.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "snapatac2.tl.link_tf_to_gene(network=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.datasets.Meuleman_2020": {
        "Parameters": {},
        "Returns": {
            "type": "list[PyDNAMotif]",
            "description": "list[PyDNAMotif]\nA list of motifs.\nSee Also\n:func:`~snapatac2.tl.motif_enrichment`: compute motif enrichment."
        },
        "Docstring": "A list of transcription factor motifs curated from [Meuleman20]_.\n\nThis function returns motifs curated from [Meuleman20]_.\nThe motifs in this list have been grouped into families.\nThe motifs can be used to scan the genome for potential binding sites and\nto perform motif enrichment analysis.\n\nReturns\n-------\nlist[PyDNAMotif]\n    A list of motifs.\n\nSee Also\n--------\n:func:`~snapatac2.tl.motif_enrichment`: compute motif enrichment.",
        "description": "A list of transcription factor motifs curated from [Meuleman20]_.This function returns motifs curated from [Meuleman20]_.\nThe motifs in this list have been grouped into families.\nThe motifs can be used to scan the genome for potential binding sites and\nto perform motif enrichment analysis.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "snapatac2.datasets.Meuleman_2020()"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.tl.diff_test": {
        "Parameters": {
            "data": {
                "type": "Union[AnnData, AnnDataSet]",
                "default": null,
                "optional": false,
                "description": "AnnData or AnnDataSet object.",
                "optional_value": true
            },
            "cell_group1": {
                "type": "Union[list[int], list[str]]",
                "default": null,
                "optional": false,
                "description": "cells belonging to group 1. This can be a list of cell barcodes, indices or \nboolean mask vector.",
                "optional_value": false
            },
            "cell_group2": {
                "type": "Union[list[int], list[str]]",
                "default": null,
                "optional": false,
                "description": "cells belonging to group 2. This can be a list of cell barcodes, indices or \nboolean mask vector.",
                "optional_value": false
            },
            "features": {
                "type": "Optional[Union[list[str], list[int]]]",
                "default": "None",
                "optional": true,
                "description": "Features/peaks to test. If None, all features are tested.",
                "optional_value": false
            },
            "covariates": {
                "type": "Optional[list[str]]",
                "default": "None",
                "optional": true,
                "description": null,
                "optional_value": false
            },
            "direction": {
                "type": "Literal['positive', 'negative', 'both']",
                "default": "both",
                "optional": true,
                "description": "\"positive\", \"negative\", or \"both\".\n\"positive\": return features that are enriched in group 1.\n\"negative\": return features that are enriched in group 2.\n\"both\": return features that are enriched in group 1 or group 2.",
                "optional_value": true
            },
            "min_log_fc": {
                "type": "float",
                "default": "0.25",
                "optional": true,
                "description": "Limit testing to features which show, on average, at least\nX-fold difference (log2-scale) between the two groups of cells.",
                "optional_value": false
            },
            "min_pct": {
                "type": "float",
                "default": "0.05",
                "optional": true,
                "description": "Only test features that are detected in a minimum fraction of min_pct\ncells in either of the two populations.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "'polars.DataFrame'",
            "description": "pl.DataFrame\nA DataFrame with 4 columns: \"feature name\", \"log2(fold_change)\",\n\"p-value\", and \"adjusted p-value\"."
        },
        "Docstring": "Identify differentially accessible regions.\n\nParameters\n----------\ndata\n    AnnData or AnnDataSet object.\ncell_group1\n    cells belonging to group 1. This can be a list of cell barcodes, indices or \n    boolean mask vector.\ncell_group2\n    cells belonging to group 2. This can be a list of cell barcodes, indices or \n    boolean mask vector.\nfeatures\n    Features/peaks to test. If None, all features are tested.\ncovariates\ndirection\n    \"positive\", \"negative\", or \"both\".\n    \"positive\": return features that are enriched in group 1.\n    \"negative\": return features that are enriched in group 2.\n    \"both\": return features that are enriched in group 1 or group 2.\nmin_log_fc\n    Limit testing to features which show, on average, at least\n    X-fold difference (log2-scale) between the two groups of cells.\nmin_pct\n    Only test features that are detected in a minimum fraction of min_pct\n    cells in either of the two populations. \n\nReturns\n-------\npl.DataFrame\n    A DataFrame with 4 columns: \"feature name\", \"log2(fold_change)\",\n    \"p-value\", and \"adjusted p-value\".",
        "description": "Identify differentially accessible regions.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "snapatac2.tl.diff_test(data=$, cell_group1=@, cell_group2=@, features=@, covariates=@, direction=$, min_log_fc=@, min_pct=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.pl.motif_enrichment": {
        "Parameters": {
            "enrichment": {
                "type": "list(str, 'pl.DataFrame')",
                "default": null,
                "optional": false,
                "description": "Motif enrichment result.",
                "optional_value": false
            },
            "min_log_fc": {
                "type": "float",
                "default": "1",
                "optional": true,
                "description": "Retain motifs that satisfy: log2-fold-change >= `min_log_fc`.",
                "optional_value": false
            },
            "max_fdr": {
                "type": "float",
                "default": "0.01",
                "optional": true,
                "description": "Retain motifs that satisfy: FDR <= `max_fdr`.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional['plotly.graph_objects.Figure']",
            "description": "'plotly.graph_objects.Figure' | None\nIf `show=False` and `out_file=None`, an `plotly.graph_objects.Figure` will be\nreturned, which can then be further customized using the plotly API."
        },
        "Docstring": "Plot the motif enrichment result.\n\nParameters\n----------\nenrichment\n    Motif enrichment result.\nmin_log_fc\n    Retain motifs that satisfy: log2-fold-change >= `min_log_fc`.\nmax_fdr\n    Retain motifs that satisfy: FDR <= `max_fdr`.\nkwargs        \n    Additional arguments passed to :func:`~snapatac2.pl.render_plot` to\n    control the final plot output. Please see :func:`~snapatac2.pl.render_plot`\n    for details.\n\nReturns\n-------\n'plotly.graph_objects.Figure' | None\n    If `show=False` and `out_file=None`, an `plotly.graph_objects.Figure` will be \n    returned, which can then be further customized using the plotly API.",
        "description": "Plot the motif enrichment result.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "snapatac2.pl.motif_enrichment(enrichment=@, min_log_fc=@, max_fdr=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.pl.network_edge_stat": {
        "Parameters": {
            "network": {
                "type": "rx.PyDiGraph",
                "default": null,
                "optional": false,
                "description": "Network.",
                "optional_value": true
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Parameters\n----------\nnetwork\n    Network.\nkwargs        \n    Additional arguments passed to :func:`~snapatac2.pl.render_plot` to\n    control the final plot output. Please see :func:`~snapatac2.pl.render_plot`\n    for details.",
        "description": "",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "snapatac2.pl.network_edge_stat(network=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.tl.add_cor_scores": {
        "Parameters": {
            "network": {
                "type": "rx.PyDiGraph",
                "default": null,
                "optional": false,
                "description": "network",
                "optional_value": true
            },
            "gene_mat": {
                "type": "Optional[Union[AnnData, AnnDataSet]]",
                "default": "None",
                "optional": true,
                "description": "AnnData or AnnDataSet object storing the cell by gene count matrix,\nwhere the `.var_names` contains genes.",
                "optional_value": true
            },
            "peak_mat": {
                "type": "Optional[Union[AnnData, AnnDataSet]]",
                "default": "None",
                "optional": true,
                "description": "AnnData or AnnDataSet object storing the cell by peak count matrix,\nwhere the `.var_names` contains peaks.",
                "optional_value": true
            },
            "select": {
                "type": "Optional[list[str]]",
                "default": "None",
                "optional": true,
                "description": "Run this for selected genes only.",
                "optional_value": false
            },
            "overwrite": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to overwrite existing records.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Compute correlation scores for any two connected nodes in the network.\n\nThis function can be used to compute correlation scores for any type of\nassociations. There are typically three types of edges in the network:\n\n1. Region -> gene: CREs regulate target genes.\n2. Gene -> gene: genes regulate other genes.\n3. Gene -> region: TFs bind to CREs.\n\nParameters\n----------\nnetwork\n    network\ngene_mat\n    AnnData or AnnDataSet object storing the cell by gene count matrix,\n    where the `.var_names` contains genes.\npeak_mat\n    AnnData or AnnDataSet object storing the cell by peak count matrix,\n    where the `.var_names` contains peaks.\nselect\n    Run this for selected genes only.\noverwrite\n    Whether to overwrite existing records.",
        "description": "Compute correlation scores for any two connected nodes in the network.This function can be used to compute correlation scores for any type of\nassociations. There are typically three types of edges in the network:\n\n1. Region -> gene: CREs regulate target genes.\n2. Gene -> gene: genes regulate other genes.\n3. Gene -> region: TFs bind to CREs.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "snapatac2.tl.add_cor_scores(network=$, gene_mat=$, peak_mat=$, select=@, overwrite=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.tl.aggregate_X": {
        "Parameters": {
            "adata": {
                "type": "Union[internal.AnnData, internal.AnnDataSet]",
                "default": null,
                "optional": false,
                "description": "The AnnData or AnnDataSet object.",
                "optional_value": false
            },
            "groupby": {
                "type": "Optional[Union[str, list[str]]]",
                "default": "None",
                "optional": true,
                "description": "Group the cells into different groups. If a `str`, groups are obtained\nfrom `.obs[groupby]`.",
                "optional_value": false
            },
            "normalize": {
                "type": "Optional[Literal['RPM', 'RPKM']]",
                "default": "None",
                "optional": true,
                "description": "normalization method: \"RPM\" or \"RPKM\".",
                "optional_value": true
            },
            "file": {
                "type": "Optional[Path]",
                "default": "None",
                "optional": true,
                "description": "if provided, the results will be saved to a new h5ad file.",
                "optional_value": true
            }
        },
        "Returns": {
            "type": "Union[np.ndarray, internal.AnnData]",
            "description": "np.ndarray | AnnData\nIf `grouby` is `None`, return a 1d array. Otherwise, return an AnnData\nobject."
        },
        "Docstring": "Aggregate values in adata.X in a row-wise fashion.\n\nAggregate values in adata.X in a row-wise fashion. This is used to compute\nRPKM or RPM values stratified by user-provided groupings.\n\nParameters\n----------\nadata\n    The AnnData or AnnDataSet object.\ngroupby\n    Group the cells into different groups. If a `str`, groups are obtained\n    from `.obs[groupby]`.\nnormalize\n    normalization method: \"RPM\" or \"RPKM\".\nfile\n    if provided, the results will be saved to a new h5ad file.\n\nReturns\n-------\nnp.ndarray | AnnData\n    If `grouby` is `None`, return a 1d array. Otherwise, return an AnnData\n    object.",
        "description": "Aggregate values in adata.X in a row-wise fashion.Aggregate values in adata.X in a row-wise fashion. This is used to compute\nRPKM or RPM values stratified by user-provided groupings.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "snapatac2.tl.aggregate_X(adata=@, groupby=@, normalize=$, file=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.tl.leiden": {
        "Parameters": {
            "adata": {
                "type": "Union[internal.AnnData, internal.AnnDataSet, ss.spmatrix]",
                "default": null,
                "optional": false,
                "description": "The annotated data matrix or sparse adjacency matrix of the graph,\ndefaults to neighbors connectivities.",
                "optional_value": false
            },
            "resolution": {
                "type": "float",
                "default": "1",
                "optional": true,
                "description": "A parameter value controlling the coarseness of the clustering.\nHigher values lead to more clusters.\nSet to `None` if overriding `partition_type`\nto one that doesn't accept a `resolution_parameter`.",
                "optional_value": false
            },
            "objective_function": {
                "type": "Literal['CPM', 'modularity', 'RBConfiguration']",
                "default": "modularity",
                "optional": true,
                "description": "whether to use the Constant Potts Model (CPM) or modularity.\nMust be either \"CPM\", \"modularity\" or \"RBConfiguration\".",
                "optional_value": true
            },
            "min_cluster_size": {
                "type": "int",
                "default": "5",
                "optional": true,
                "description": "The minimum size of clusters.",
                "optional_value": false
            },
            "n_iterations": {
                "type": "int",
                "default": "-1",
                "optional": true,
                "description": "How many iterations of the Leiden clustering algorithm to perform.\nPositive values above 2 define the total number of iterations to perform,\n-1 has the algorithm run until it reaches its optimal clustering.",
                "optional_value": false
            },
            "random_state": {
                "type": "int",
                "default": "0",
                "optional": true,
                "description": "Change the initialization of the optimization.",
                "optional_value": false
            },
            "key_added": {
                "type": "str",
                "default": "leiden",
                "optional": true,
                "description": "`adata.obs` key under which to add the cluster labels.",
                "optional_value": false
            },
            "use_leidenalg": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If `True`, `leidenalg` package is used. Otherwise, `python-igraph` is used.",
                "optional_value": false
            },
            "weighted": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to use the edge weights in the graph",
                "optional_value": false
            },
            "inplace": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to store the result in the anndata object.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[np.ndarray]",
            "description": "np.ndarray | None\nIf `inplace=True`, update `adata.obs[key_added]` to store an array of\ndim (number of samples) that stores the subgroup id\n(`'0'`, `'1'`, ...) for each cell. Otherwise, returns the array directly."
        },
        "Docstring": "Cluster cells into subgroups [Traag18]_.\n\nCluster cells using the Leiden algorithm [Traag18]_,\nan improved version of the Louvain algorithm [Blondel08]_.\nIt has been proposed for single-cell analysis by [Levine15]_.\nThis requires having ran :func:`~snapatac2.pp.knn`.\n\nParameters\n----------\nadata\n    The annotated data matrix or sparse adjacency matrix of the graph,\n    defaults to neighbors connectivities.\nresolution\n    A parameter value controlling the coarseness of the clustering.\n    Higher values lead to more clusters.\n    Set to `None` if overriding `partition_type`\n    to one that doesn't accept a `resolution_parameter`.\nobjective_function\n    whether to use the Constant Potts Model (CPM) or modularity.\n    Must be either \"CPM\", \"modularity\" or \"RBConfiguration\".\nmin_cluster_size\n    The minimum size of clusters.\nn_iterations\n    How many iterations of the Leiden clustering algorithm to perform.\n    Positive values above 2 define the total number of iterations to perform,\n    -1 has the algorithm run until it reaches its optimal clustering.\nrandom_state\n    Change the initialization of the optimization.\nkey_added\n    `adata.obs` key under which to add the cluster labels.\nuse_leidenalg\n    If `True`, `leidenalg` package is used. Otherwise, `python-igraph` is used.\nweighted\n    Whether to use the edge weights in the graph\ninplace\n    Whether to store the result in the anndata object.\n\nReturns\n-------\nnp.ndarray | None\n    If `inplace=True`, update `adata.obs[key_added]` to store an array of\n    dim (number of samples) that stores the subgroup id\n    (`'0'`, `'1'`, ...) for each cell. Otherwise, returns the array directly.",
        "description": "Cluster cells into subgroups [Traag18]_.Cluster cells using the Leiden algorithm [Traag18]_,\nan improved version of the Louvain algorithm [Blondel08]_.\nIt has been proposed for single-cell analysis by [Levine15]_.\nThis requires having ran :func:`~snapatac2.pp.knn`.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "snapatac2.tl.leiden(adata=@, resolution=@, objective_function=$, min_cluster_size=@, n_iterations=@, random_state=@, key_added=@, use_leidenalg=@, weighted=@, inplace=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.read_dataset": {
        "Parameters": {
            "filename": {
                "type": "Path",
                "default": null,
                "optional": false,
                "description": "File name.",
                "optional_value": true
            },
            "update_data_locations": {
                "type": "Mapping[str, str]",
                "default": "None",
                "optional": true,
                "description": "If provided, locations of component anndata files will be updated.",
                "optional_value": false
            },
            "mode": {
                "type": "str",
                "default": "r+",
                "optional": true,
                "description": "\"r\": Read-only mode; \"r+\": can modify annotation file but not component anndata files.",
                "optional_value": false
            },
            "backend": {
                "type": "Literal['hdf5'] | None",
                "default": "None",
                "optional": true,
                "description": null,
                "optional_value": true
            }
        },
        "Returns": {
            "type": null,
            "description": "AnnDataSet"
        },
        "Docstring": "Read AnnDataSet object.\n\nRead AnnDataSet from .h5ads file. If the file paths stored in AnnDataSet\nobject are relative paths, it will look for component .h5ad files in .h5ads file's parent directory.\n\nParameters\n----------\nfilename: Path\n    File name.\nupdate_data_locations: Mapping[str, str]\n    If provided, locations of component anndata files will be updated.\nmode: str\n    \"r\": Read-only mode; \"r+\": can modify annotation file but not component anndata files.\nbackend: Literal['hdf5'] | None\n\nReturns\n-------\nAnnDataSet",
        "description": "Read AnnDataSet object.Read AnnDataSet from .h5ads file. If the file paths stored in AnnDataSet\nobject are relative paths, it will look for component .h5ad files in .h5ads file's parent directory.",
        "example": "",
        "api_type": "builtin",
        "api_calling": [
            "snapatac2.read_dataset(filename=$, update_data_locations=@, mode=@, backend=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.read_mtx": {
        "Parameters": {
            "mtx_file": {
                "type": null,
                "default": null,
                "optional": false,
                "description": "File name of the input matrix market file.",
                "optional_value": true
            },
            "obs_names": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "File that stores the observation names.",
                "optional_value": true
            },
            "var_names": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "File that stores the variable names.",
                "optional_value": true
            },
            "file": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "File name of the output \".h5ad\" file.",
                "optional_value": true
            },
            "backend": {
                "type": null,
                "default": "None",
                "optional": true,
                "description": "Backend to use for writing the output file.",
                "optional_value": true
            },
            "sorted": {
                "type": null,
                "default": "False",
                "optional": true,
                "description": "If true, the input matrix is assumed to be sorted by rows.\nSorted input matrix can be read faster.",
                "optional_value": true
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Read Matrix Market file.\n\nParameters\n----------\n\nmtx_file\n    File name of the input matrix market file.\nobs_names\n    File that stores the observation names.\nvar_names\n    File that stores the variable names.\nfile\n    File name of the output \".h5ad\" file.\nbackend\n    Backend to use for writing the output file.\nsorted\n    If true, the input matrix is assumed to be sorted by rows.\n    Sorted input matrix can be read faster.",
        "description": "Read Matrix Market file.",
        "example": "",
        "api_type": "builtin",
        "api_calling": [
            "snapatac2.read_mtx(mtx_file=$, obs_names=$, var_names=$, file=$, backend=$, sorted=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.ex.export_coverage": {
        "Parameters": {
            "adata": {
                "type": "Union[internal.AnnData, internal.AnnDataSet]",
                "default": null,
                "optional": false,
                "description": "The (annotated) data matrix of shape `n_obs` x `n_vars`.\nRows correspond to cells and columns to regions.",
                "optional_value": false
            },
            "groupby": {
                "type": "Union[str, list[str]]",
                "default": null,
                "optional": false,
                "description": "Group the cells. If a `str`, groups are obtained from\n`.obs[groupby]`.",
                "optional_value": false
            },
            "selections": {
                "type": "Optional[list[str]]",
                "default": "None",
                "optional": true,
                "description": "Export only the selected groups.",
                "optional_value": false
            },
            "bin_size": {
                "type": "int",
                "default": "10",
                "optional": true,
                "description": "Size of the bins, in bases, for the output of the bigwig/bedgraph file.",
                "optional_value": false
            },
            "blacklist": {
                "type": "Optional[Path]",
                "default": "None",
                "optional": true,
                "description": "A BED file containing the blacklisted regions.",
                "optional_value": true
            },
            "normalization": {
                "type": "Optional[Literal['RPKM', 'CPM']]",
                "default": "RPKM",
                "optional": true,
                "description": "Normalization method. If `None`, no normalization is performed.",
                "optional_value": true
            },
            "ignore_for_norm": {
                "type": "Optional[list[str]]",
                "default": "None",
                "optional": true,
                "description": "A list of chromosomes to ignore for normalization.",
                "optional_value": false
            },
            "min_frag_length": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Minimum fragment length to be included in the computation.",
                "optional_value": false
            },
            "max_frag_length": {
                "type": "Optional[int]",
                "default": "2000",
                "optional": true,
                "description": "Maximum fragment length to be included in the computation.",
                "optional_value": false
            },
            "out_dir": {
                "type": "Path",
                "default": "./",
                "optional": true,
                "description": "Directory for saving the outputs.",
                "optional_value": true
            },
            "prefix": {
                "type": "str",
                "default": "",
                "optional": true,
                "description": "Text added to the output file name.",
                "optional_value": false
            },
            "suffix": {
                "type": "str",
                "default": ".bw",
                "optional": true,
                "description": "Text added to the output file name.",
                "optional_value": false
            },
            "output_format": {
                "type": "Optional[Literal['bedgraph', 'bigwig']]",
                "default": "None",
                "optional": true,
                "description": "Output format. If `None`, it is inferred from the suffix.",
                "optional_value": true
            },
            "compression": {
                "type": "Optional[Literal['gzip', 'zstandard']]",
                "default": "None",
                "optional": true,
                "description": "Compression type. If `None`, it is inferred from the suffix.",
                "optional_value": true
            },
            "compression_level": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Compression level. 1-9 for gzip, 1-22 for zstandard.\nIf `None`, it is set to 6 for gzip and 3 for zstandard.",
                "optional_value": false
            },
            "tempdir": {
                "type": "Optional[Path]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            },
            "n_jobs": {
                "type": "int",
                "default": "8",
                "optional": true,
                "description": "Number of threads to use. If `<= 0`, use all available threads.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "dict[str, str]",
            "description": "dict[str, str]\nA dictionary contains `(groupname, filename)` pairs. The file names are\nformatted as `{prefix}{groupname}{suffix}`.\nSee Also\nexport_fragments"
        },
        "Docstring": "Export and save coverage in a bedgraph or bigwig format file.\n\nThis function generates coverage tracks (bigWig or bedGraph) for each group\nof cells defined in `groupby`. The coverage is calculated as the number of reads\nper bin, where bins are short consecutive counting windows of a defined size.\nFor paired-end data, the reads are extended to the fragment length and the\ncoverage is calculated as the number of fragments per bin.\nThere are several options for normalization. The default is RPKM, which\nnormalizes by the total number of reads and the length of the region.\nThe normalization can be disabled by setting `normalization=None`.\n\nParameters\n----------\nadata\n    The (annotated) data matrix of shape `n_obs` x `n_vars`.\n    Rows correspond to cells and columns to regions.\ngroupby\n    Group the cells. If a `str`, groups are obtained from\n    `.obs[groupby]`.\nselections\n    Export only the selected groups.\nbin_size\n    Size of the bins, in bases, for the output of the bigwig/bedgraph file.\nblacklist\n    A BED file containing the blacklisted regions.\nnormalization\n    Normalization method. If `None`, no normalization is performed.\nignore_for_norm\n    A list of chromosomes to ignore for normalization.\nmin_frag_length\n    Minimum fragment length to be included in the computation.\nmax_frag_length\n    Maximum fragment length to be included in the computation.\nout_dir\n    Directory for saving the outputs.\nprefix\n    Text added to the output file name.\nsuffix\n    Text added to the output file name.\noutput_format\n    Output format. If `None`, it is inferred from the suffix.\ncompression\n    Compression type. If `None`, it is inferred from the suffix.\ncompression_level\n    Compression level. 1-9 for gzip, 1-22 for zstandard.\n    If `None`, it is set to 6 for gzip and 3 for zstandard.\nn_jobs\n    Number of threads to use. If `<= 0`, use all available threads.\n\nReturns\n-------\ndict[str, str]\n    A dictionary contains `(groupname, filename)` pairs. The file names are\n    formatted as `{prefix}{groupname}{suffix}`.\n\nSee Also\n--------\nexport_fragments\n\nExamples\n--------\n>>> import snapatac2 as snap\n>>> data = snap.read(snap.datasets.pbmc5k(type=\"annotated_h5ad\"), backed='r')\n>>> snap.ex.export_coverage(data, groupby='cell_type', suffix='.bedgraph.zst')\n{'cDC': './cDC.bedgraph.zst',\n 'Memory B': './Memory B.bedgraph.zst',\n 'CD4 Naive': './CD4 Naive.bedgraph.zst',\n 'pDC': './pDC.bedgraph.zst',\n 'CD8 Naive': './CD8 Naive.bedgraph.zst',\n 'CD8 Memory': './CD8 Memory.bedgraph.zst',\n 'CD14 Mono': './CD14 Mono.bedgraph.zst',\n 'Naive B': './Naive B.bedgraph.zst',\n 'NK': './NK.bedgraph.zst',\n 'CD4 Memory': './CD4 Memory.bedgraph.zst',\n 'CD16 Mono': './CD16 Mono.bedgraph.zst',\n 'MAIT': './MAIT.bedgraph.zst'}\n>>> snap.ex.export_coverage(data, groupby='cell_type', suffix='.bw')\n{'Naive B': './Naive B.bw',\n 'CD4 Memory': './CD4 Memory.bw',\n 'CD16 Mono': './CD16 Mono.bw',\n 'CD8 Naive': './CD8 Naive.bw',\n 'pDC': './pDC.bw',\n 'CD8 Memory': './CD8 Memory.bw',\n 'NK': './NK.bw',\n 'Memory B': './Memory B.bw',\n 'CD14 Mono': './CD14 Mono.bw',\n 'MAIT': './MAIT.bw',\n 'CD4 Naive': './CD4 Naive.bw',\n 'cDC': './cDC.bw'}",
        "description": "Export and save coverage in a bedgraph or bigwig format file.This function generates coverage tracks (bigWig or bedGraph) for each group\nof cells defined in `groupby`. The coverage is calculated as the number of reads\nper bin, where bins are short consecutive counting windows of a defined size.\nFor paired-end data, the reads are extended to the fragment length and the\ncoverage is calculated as the number of fragments per bin.\nThere are several options for normalization. The default is RPKM, which\nnormalizes by the total number of reads and the length of the region.\nThe normalization can be disabled by setting `normalization=None`.",
        "example": "Examples\n--------\n>>> import snapatac2 as snap\n>>> data = snap.read(snap.datasets.pbmc5k(type=\"annotated_h5ad\"), backed='r')\n>>> snap.ex.export_coverage(data, groupby='cell_type', suffix='.bedgraph.zst')\n{'cDC': './cDC.bedgraph.zst',\n 'Memory B': './Memory B.bedgraph.zst',\n 'CD4 Naive': './CD4 Naive.bedgraph.zst',\n 'pDC': './pDC.bedgraph.zst',\n 'CD8 Naive': './CD8 Naive.bedgraph.zst',\n 'CD8 Memory': './CD8 Memory.bedgraph.zst',\n 'CD14 Mono': './CD14 Mono.bedgraph.zst',\n 'Naive B': './Naive B.bedgraph.zst',\n 'NK': './NK.bedgraph.zst',\n 'CD4 Memory': './CD4 Memory.bedgraph.zst',\n 'CD16 Mono': './CD16 Mono.bedgraph.zst',\n 'MAIT': './MAIT.bedgraph.zst'}\n>>> snap.ex.export_coverage(data, groupby='cell_type', suffix='.bw')\n{'Naive B': './Naive B.bw',\n 'CD4 Memory': './CD4 Memory.bw',\n 'CD16 Mono': './CD16 Mono.bw',\n 'CD8 Naive': './CD8 Naive.bw',\n 'pDC': './pDC.bw',\n 'CD8 Memory': './CD8 Memory.bw',\n 'NK': './NK.bw',\n 'Memory B': './Memory B.bw',\n 'CD14 Mono': './CD14 Mono.bw',\n 'MAIT': './MAIT.bw',\n 'CD4 Naive': './CD4 Naive.bw',\n 'cDC': './cDC.bw'}",
        "api_type": "function",
        "api_calling": [
            "snapatac2.ex.export_coverage(adata=@, groupby=@, selections=@, bin_size=@, blacklist=$, normalization=$, ignore_for_norm=@, min_frag_length=@, max_frag_length=@, out_dir=$, prefix=@, suffix=@, output_format=$, compression=$, compression_level=@, tempdir=$, n_jobs=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.tl.add_regr_scores": {
        "Parameters": {
            "network": {
                "type": "rx.PyDiGraph",
                "default": null,
                "optional": false,
                "description": "network",
                "optional_value": true
            },
            "peak_mat": {
                "type": "Optional[Union[AnnData, AnnDataSet]]",
                "default": "None",
                "optional": true,
                "description": "AnnData or AnnDataSet object storing the cell by peak count matrix,\nwhere the `.var_names` contains peaks.",
                "optional_value": true
            },
            "gene_mat": {
                "type": "Optional[Union[AnnData, AnnDataSet]]",
                "default": "None",
                "optional": true,
                "description": "AnnData or AnnDataSet object storing the cell by gene count matrix,\nwhere the `.var_names` contains genes.",
                "optional_value": true
            },
            "select": {
                "type": "Optional[list[str]]",
                "default": "None",
                "optional": true,
                "description": "Run this for selected genes only.",
                "optional_value": false
            },
            "method": {
                "type": "Literal['gb_tree', 'elastic_net']",
                "default": "elastic_net",
                "optional": true,
                "description": "Regresson model.",
                "optional_value": true
            },
            "scale_X": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to scale the features.",
                "optional_value": false
            },
            "scale_Y": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to scale the response variable.",
                "optional_value": false
            },
            "alpha": {
                "type": "float",
                "default": "1.0",
                "optional": true,
                "description": "Constant that multiplies the penalty terms in 'elastic_net'.",
                "optional_value": false
            },
            "l1_ratio": {
                "type": "float",
                "default": "0.5",
                "optional": true,
                "description": "Used in 'elastic_net'. The ElasticNet mixing parameter,\nwith `0 <= l1_ratio <= 1`. For `l1_ratio = 0` the penalty is an L2 penalty.\nFor `l1_ratio = 1` it is an L1 penalty. For `0 < l1_ratio < 1`,\nthe penalty is a combination of L1 and L2.",
                "optional_value": false
            },
            "use_gpu": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to use gpu",
                "optional_value": false
            },
            "overwrite": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to overwrite existing records.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Perform regression analysis for nodes and their parents in the network.\n\nParameters\n----------\nnetwork\n    network\npeak_mat\n    AnnData or AnnDataSet object storing the cell by peak count matrix,\n    where the `.var_names` contains peaks.\ngene_mat\n    AnnData or AnnDataSet object storing the cell by gene count matrix,\n    where the `.var_names` contains genes.\nselect\n    Run this for selected genes only.\nmethod\n    Regresson model.\nscale_X\n    Whether to scale the features.\nscale_Y\n    Whether to scale the response variable.\nalpha\n    Constant that multiplies the penalty terms in 'elastic_net'.\nl1_ratio\n    Used in 'elastic_net'. The ElasticNet mixing parameter,\n    with `0 <= l1_ratio <= 1`. For `l1_ratio = 0` the penalty is an L2 penalty.\n    For `l1_ratio = 1` it is an L1 penalty. For `0 < l1_ratio < 1`,\n    the penalty is a combination of L1 and L2.\nuse_gpu\n    Whether to use gpu\noverwrite\n    Whether to overwrite existing records.",
        "description": "Perform regression analysis for nodes and their parents in the network.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "snapatac2.tl.add_regr_scores(network=$, peak_mat=$, gene_mat=$, select=@, method=$, scale_X=@, scale_Y=@, alpha=@, l1_ratio=@, use_gpu=@, overwrite=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.tl.merge_peaks": {
        "Parameters": {
            "peaks": {
                "type": "dict[str, 'polars.DataFrame']",
                "default": null,
                "optional": false,
                "description": "Peak information from different groups.",
                "optional_value": false
            },
            "chrom_sizes": {
                "type": "Union[dict[str, int], Genome]",
                "default": null,
                "optional": false,
                "description": "Chromosome sizes. If a :class:`~snapatac2.genome.Genome` is provided,\nchromosome sizes will be obtained from the genome.",
                "optional_value": false
            },
            "half_width": {
                "type": "int",
                "default": "250",
                "optional": true,
                "description": "Half width of the merged peaks.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "'polars.DataFrame'",
            "description": "'polars.DataFrame'\nA dataframe with merged peaks.\nSee Also\nmacs3"
        },
        "Docstring": "Merge peaks from different groups.\n\nMerge peaks from different groups. It is typically used to merge\nresults from :func:`~snapatac2.tools.macs3`.\n\nThis function initially expands the summits of identified peaks by `half_width`\non both sides. Following this expansion, it addresses the issue of overlapping\npeaks through an iterative process. The procedure begins by prioritizing the\nmost significant peak, determined by the smallest p-value. This peak is retained,\nand any peak that overlaps with it is excluded. Subsequently, the same method\nis applied to the next most significant peak. This iteration continues until\nall peaks have been evaluated, resulting in a final list of non-overlapping\npeaks, each with a fixed width determined by the initial extension.\n\nParameters\n----------\npeaks\n    Peak information from different groups.\nchrom_sizes\n    Chromosome sizes. If a :class:`~snapatac2.genome.Genome` is provided,\n    chromosome sizes will be obtained from the genome.\nhalf_width\n    Half width of the merged peaks.\n\nReturns\n-------\n'polars.DataFrame'\n    A dataframe with merged peaks.\n\nSee Also\n--------\nmacs3",
        "description": "Merge peaks from different groups.Merge peaks from different groups. It is typically used to merge\nresults from :func:`~snapatac2.tools.macs3`.\n\nThis function initially expands the summits of identified peaks by `half_width`\non both sides. Following this expansion, it addresses the issue of overlapping\npeaks through an iterative process. The procedure begins by prioritizing the\nmost significant peak, determined by the smallest p-value. This peak is retained,\nand any peak that overlaps with it is excluded. Subsequently, the same method\nis applied to the next most significant peak. This iteration continues until\nall peaks have been evaluated, resulting in a final list of non-overlapping\npeaks, each with a fixed width determined by the initial extension.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "snapatac2.tl.merge_peaks(peaks=@, chrom_sizes=@, half_width=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.tl.add_tf_binding": {
        "Parameters": {
            "network": {
                "type": "rx.PyDiGraph",
                "default": null,
                "optional": false,
                "description": "Network",
                "optional_value": true
            },
            "motifs": {
                "type": "list[PyDNAMotif]",
                "default": null,
                "optional": false,
                "description": "TF motifs",
                "optional_value": false
            },
            "genome_fasta": {
                "type": "Union[Path, Genome]",
                "default": null,
                "optional": false,
                "description": "A fasta file containing the genome sequences or a Genome object.",
                "optional_value": true
            },
            "pvalue": {
                "type": "float",
                "default": "1e-05",
                "optional": true,
                "description": "P-value threshold for motif binding.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ""
        },
        "Docstring": "Add TF motif binding information.\n\nParameters\n----------\nnetwork\n    Network\nmotifs\n    TF motifs\ngenome_fasta\n    A fasta file containing the genome sequences or a Genome object.\npvalue\n    P-value threshold for motif binding.",
        "description": "Add TF motif binding information.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "snapatac2.tl.add_tf_binding(network=$, motifs=@, genome_fasta=$, pvalue=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.genome.hg19": {
        "Parameters": {},
        "Returns": {
            "type": "snapatac2.genome.Genome",
            "description": null
        },
        "Value": "<snapatac2.genome.Genome object at 0x7f4f676a2d10>",
        "Docstring": "\n    A class that encapsulates information about a genome, including its FASTA sequence,\n    its annotation, and chromosome sizes.\n\n    Attributes\n    ----------\n    fasta\n        The path to the FASTA file.\n    annotation\n        The path to the annotation file.\n    chrom_sizes\n        A dictionary containing chromosome names and sizes.\n\n    Raises\n    ------\n    ValueError\n        If `fasta` or `annotation` are not a Path, a string, or a callable.\n    ",
        "description": "A class that encapsulates information about a genome, including its FASTA sequence,its annotation, and chromosome sizes.",
        "example": "",
        "api_type": "unknown",
        "api_calling": [
            "snapatac2.genome.hg19()"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.datasets.cre_HEA": {
        "Parameters": {},
        "Returns": {
            "type": "Path",
            "description": "Path\nPath to the gzipped BED file containing the cis-regulatory elements."
        },
        "Docstring": "Curated cis-regulatory elements from [Zhang21]_.\n\nReturns\n-------\nPath\n    Path to the gzipped BED file containing the cis-regulatory elements.",
        "description": "Curated cis-regulatory elements from [Zhang21]_.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "snapatac2.datasets.cre_HEA()"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "snapatac2.tl.multi_spectral": {
        "Parameters": {
            "adatas": {
                "type": "Union[list[internal.AnnData], list[internal.AnnDataSet]]",
                "default": null,
                "optional": false,
                "description": "A list of AnnData objects, representing single-cell data from different modalities.",
                "optional_value": false
            },
            "n_comps": {
                "type": "int",
                "default": "30",
                "optional": true,
                "description": "Number of dimensions to keep.\nSee :func:`~snapatac2.tl.spectral` for details.",
                "optional_value": false
            },
            "features": {
                "type": "Optional[Union[str, list[str], list[np.ndarray]]]",
                "default": "selected",
                "optional": true,
                "description": "Boolean index mask. True means that the feature is kept. False means the feature is removed.",
                "optional_value": false
            },
            "weights": {
                "type": "Optional[list[float]]",
                "default": "None",
                "optional": true,
                "description": "Weights for each modality. If None, all modalities are weighted equally.",
                "optional_value": false
            },
            "random_state": {
                "type": "int",
                "default": "0",
                "optional": true,
                "description": "Seed of the random state generator",
                "optional_value": false
            },
            "weighted_by_sd": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to weight the result eigenvectors by the square root of eigenvalues.\nSee :func:`~snapatac2.tl.spectral` for details.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "tuple[np.ndarray, np.ndarray]",
            "description": "tuple[np.ndarray, np.ndarray]\nReturn the eigenvalues and eigenvectors of the Laplacian matrix.\nSee Also\nspectral"
        },
        "Docstring": "Compute Laplacian Eigenmaps simultaneously on multiple modalities, with linear\nspace and time complexity.\n\nThis is similar to :func:`~snapatac2.tl.spectral`, but it can work on multiple modalities.\n\nParameters\n----------\nadatas\n    A list of AnnData objects, representing single-cell data from different modalities.\nn_comps\n    Number of dimensions to keep.\n    See :func:`~snapatac2.tl.spectral` for details.\nfeatures\n    Boolean index mask. True means that the feature is kept. False means the feature is removed.\nweights\n    Weights for each modality. If None, all modalities are weighted equally.\nrandom_state\n    Seed of the random state generator\nweighted_by_sd\n    Whether to weight the result eigenvectors by the square root of eigenvalues.\n    See :func:`~snapatac2.tl.spectral` for details.\n\nReturns\n-------\ntuple[np.ndarray, np.ndarray]\n    Return the eigenvalues and eigenvectors of the Laplacian matrix.\n\nSee Also\n--------\nspectral",
        "description": "Compute Laplacian Eigenmaps simultaneously on multiple modalities, with linearspace and time complexity.\n\nThis is similar to :func:`~snapatac2.tl.spectral`, but it can work on multiple modalities.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "snapatac2.tl.multi_spectral(adatas=@, n_comps=@, features=@, weights=@, random_state=@, weighted_by_sd=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    }
}
{
    "squidpy.pl.ligrec": {
        "Parameters": {
            "adata": {
                "type": "Union[AnnData, Mapping[str, pd.DataFrame]]",
                "default": null,
                "optional": false,
                "description": "Annotated data object.\nIt can also be a :class:`dict`, as returned by :func:`squidpy.gr.ligrec`.",
                "optional_value": false
            },
            "cluster_key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Key in :attr:`anndata.AnnData.obs` where clustering is stored.\nOnly used when ``adata`` is of type :class:`AnnData`.",
                "optional_value": false
            },
            "source_groups": {
                "type": "Optional[Union[str, Sequence[str]]]",
                "default": "None",
                "optional": true,
                "description": "Source interaction clusters. If `None`, select all clusters.",
                "optional_value": false
            },
            "target_groups": {
                "type": "Optional[Union[str, Sequence[str]]]",
                "default": "None",
                "optional": true,
                "description": "Target interaction clusters. If `None`, select all clusters.",
                "optional_value": false
            },
            "means_range": {
                "type": "tuple[float, float]",
                "default": "(-inf, inf)",
                "optional": true,
                "description": "Only show interactions whose means are within this **closed** interval.",
                "optional_value": false
            },
            "pvalue_threshold": {
                "type": "float",
                "default": "1.0",
                "optional": true,
                "description": "Only show interactions with p-value <= ``pvalue_threshold``.",
                "optional_value": false
            },
            "remove_empty_interactions": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Remove rows and columns that only contain interactions with `NaN` values.",
                "optional_value": false
            },
            "remove_nonsig_interactions": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Remove rows and columns that only contain interactions that are larger than ``alpha``.",
                "optional_value": false
            },
            "dendrogram": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "How to cluster based on the p-values. Valid options are:\n\n    -  `None` - do not perform clustering.\n    - `'interacting_molecules'` - cluster the interacting molecules.\n    - `'interacting_clusters'` - cluster the interacting clusters.\n    - `'both'` - cluster both rows and columns. Note that in this case, the dendrogram is not shown.",
                "optional_value": false
            },
            "alpha": {
                "type": "Optional[float]",
                "default": "0.001",
                "optional": true,
                "description": "Significance threshold. All elements with p-values <= ``alpha`` will be marked by tori instead of dots.",
                "optional_value": false
            },
            "swap_axes": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to show the cluster combinations as rows and the interacting pairs as columns.",
                "optional_value": false
            },
            "title": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Title of the plot.",
                "optional_value": false
            },
            "figsize": {
                "type": "Optional[tuple[float, float]]",
                "default": "None",
                "optional": true,
                "description": "Size of the figure in inches.",
                "optional_value": false
            },
            "dpi": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Dots per inch.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[str, Path]]",
                "default": "None",
                "optional": true,
                "description": "Whether to save the plot.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": "Nothing, just plots the figure and optionally saves the plot."
        },
        "Docstring": "Plot the result of a receptor-ligand permutation test.\n\nThe result was computed by :func:`squidpy.gr.ligrec`.\n\n:math:`molecule_1` belongs to the source clusters displayed on the top (or on the right, if ``swap_axes = True``,\nwhereas :math:`molecule_2` belongs to the target clusters.\n\nParameters\n----------\nadata\n    Annotated data object.\n    It can also be a :class:`dict`, as returned by :func:`squidpy.gr.ligrec`.\ncluster_key\n    Key in :attr:`anndata.AnnData.obs` where clustering is stored.\n    Only used when ``adata`` is of type :class:`AnnData`.\nsource_groups\n    Source interaction clusters. If `None`, select all clusters.\ntarget_groups\n    Target interaction clusters. If `None`, select all clusters.\nmeans_range\n    Only show interactions whose means are within this **closed** interval.\npvalue_threshold\n    Only show interactions with p-value <= ``pvalue_threshold``.\nremove_empty_interactions\n    Remove rows and columns that only contain interactions with `NaN` values.\nremove_nonsig_interactions\n    Remove rows and columns that only contain interactions that are larger than ``alpha``.\ndendrogram\n    How to cluster based on the p-values. Valid options are:\n\n        -  `None` - do not perform clustering.\n        - `'interacting_molecules'` - cluster the interacting molecules.\n        - `'interacting_clusters'` - cluster the interacting clusters.\n        - `'both'` - cluster both rows and columns. Note that in this case, the dendrogram is not shown.\n\nalpha\n    Significance threshold. All elements with p-values <= ``alpha`` will be marked by tori instead of dots.\nswap_axes\n    Whether to show the cluster combinations as rows and the interacting pairs as columns.\ntitle\n    Title of the plot.\nfigsize\n    Size of the figure in inches.\ndpi\n    Dots per inch.\nsave\n    Whether to save the plot.\nscalebar_kwargs\n    Keyword arguments for :meth:`matplotlib_scalebar.ScaleBar`.\nedges_kwargs\n    Keyword arguments for :func:`networkx.draw_networkx_edges`.\nkwargs\n    Keyword arguments for :func:`matplotlib.pyplot.scatter` or :func:`matplotlib.pyplot.imshow`.\n\nkwargs\n    Keyword arguments for :meth:`scanpy.pl.DotPlot.style` or :meth:`scanpy.pl.DotPlot.legend`.\n\nReturns\n-------\nNothing, just plots the figure and optionally saves the plot.",
        "description": "Plot the result of a receptor-ligand permutation test.The result was computed by :func:`squidpy.gr.ligrec`.\n\n:math:`molecule_1` belongs to the source clusters displayed on the top (or on the right, if ``swap_axes = True``,\nwhereas :math:`molecule_2` belongs to the target clusters.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "squidpy.pl.ligrec(adata=@, cluster_key=@, source_groups=@, target_groups=@, means_range=@, pvalue_threshold=@, remove_empty_interactions=@, remove_nonsig_interactions=@, dendrogram=@, alpha=@, swap_axes=@, title=@, figsize=@, dpi=@, save=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "squidpy.pl.co_occurrence": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data object.",
                "optional_value": true
            },
            "cluster_key": {
                "type": "str",
                "default": null,
                "optional": false,
                "description": "Key in :attr:`anndata.AnnData.obs` where clustering is stored.",
                "optional_value": false
            },
            "palette": {
                "type": "Palette_t",
                "default": "None",
                "optional": true,
                "description": "Categorical colormap for the clusters.\nIf ``None``, use :attr:`anndata.AnnData.uns` ``['{cluster_key}_colors']``, if available.",
                "optional_value": true
            },
            "clusters": {
                "type": "Optional[Union[str, Sequence[str]]]",
                "default": "None",
                "optional": true,
                "description": "Cluster instances for which to plot conditional probability.",
                "optional_value": false
            },
            "figsize": {
                "type": "Optional[tuple[float, float]]",
                "default": "None",
                "optional": true,
                "description": "Size of the figure in inches.",
                "optional_value": false
            },
            "dpi": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Dots per inch.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[str, Path]]",
                "default": "None",
                "optional": true,
                "description": "Whether to save the plot.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": "Nothing, just plots the figure and optionally saves the plot."
        },
        "Docstring": "Plot co-occurrence probability ratio for each cluster.\n\nThe co-occurrence is computed by :func:`squidpy.gr.co_occurrence`.\n\nParameters\n----------\nadata\n    Annotated data object.\ncluster_key\n    Key in :attr:`anndata.AnnData.obs` where clustering is stored.\nclusters\n    Cluster instances for which to plot conditional probability.\npalette\n    Categorical colormap for the clusters.\n    If ``None``, use :attr:`anndata.AnnData.uns` ``['{cluster_key}_colors']``, if available.\nfigsize\n    Size of the figure in inches.\ndpi\n    Dots per inch.\nsave\n    Whether to save the plot.\nscalebar_kwargs\n    Keyword arguments for :meth:`matplotlib_scalebar.ScaleBar`.\nedges_kwargs\n    Keyword arguments for :func:`networkx.draw_networkx_edges`.\nkwargs\n    Keyword arguments for :func:`matplotlib.pyplot.scatter` or :func:`matplotlib.pyplot.imshow`.\n\nlegend_kwargs\n    Keyword arguments for :func:`matplotlib.pyplot.legend`.\nkwargs\n    Keyword arguments for :func:`seaborn.lineplot`.\n\nReturns\n-------\nNothing, just plots the figure and optionally saves the plot.",
        "description": "Plot co-occurrence probability ratio for each cluster.The co-occurrence is computed by :func:`squidpy.gr.co_occurrence`.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "squidpy.pl.co_occurrence(adata=$, cluster_key=@, palette=$, clusters=@, figsize=@, dpi=@, save=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "squidpy.datasets.imc": {
        "Parameters": {
            "path": {
                "type": "Union[PathLike, str]",
                "default": "None",
                "optional": true,
                "description": "Path where to save the dataset.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": "The dataset."
        },
        "Docstring": "Pre-processed subset IMC dataset from `Jackson et al <https://www.nature.com/articles/s41586-019-1876-x>`__.\n\nThe shape of this :class:`anndata.AnnData` object ``(4668, 34)``.\n\nParameters\n----------\npath\n    Path where to save the dataset.\nkwargs\n    Keyword arguments for :func:`scanpy.read`.\n\nReturns\n-------\nThe dataset.",
        "description": "Pre-processed subset IMC dataset from `Jackson et al <https://www.nature.com/articles/s41586-019-1876-x>`__.The shape of this :class:`anndata.AnnData` object ``(4668, 34)``.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "squidpy.datasets.imc(path=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "squidpy.pl.interaction_matrix": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data object.",
                "optional_value": true
            },
            "cluster_key": {
                "type": "str",
                "default": null,
                "optional": false,
                "description": "Key in :attr:`anndata.AnnData.obs` where clustering is stored.",
                "optional_value": false
            },
            "annotate": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to annotate the cells of the heatmap.",
                "optional_value": false
            },
            "method": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "The linkage method to be used for dendrogram/clustering, see :func:`scipy.cluster.hierarchy.linkage`.",
                "optional_value": false
            },
            "title": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "The title of the plot.",
                "optional_value": false
            },
            "cmap": {
                "type": "str",
                "default": "viridis",
                "optional": true,
                "description": "Continuous colormap to use.",
                "optional_value": false
            },
            "palette": {
                "type": "Palette_t",
                "default": "None",
                "optional": true,
                "description": "Categorical colormap for the clusters.\nIf `None`, use :attr:`anndata.AnnData.uns` ``['{cluster_key}_colors']``, if available.",
                "optional_value": true
            },
            "figsize": {
                "type": "Optional[tuple[float, float]]",
                "default": "None",
                "optional": true,
                "description": "Size of the figure in inches.",
                "optional_value": false
            },
            "dpi": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Dots per inch.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[str, Path]]",
                "default": "None",
                "optional": true,
                "description": "Whether to save the plot.",
                "optional_value": false
            },
            "ax": {
                "type": "Optional[Axes]",
                "default": "None",
                "optional": true,
                "description": "Axes, :class:`matplotlib.axes.Axes`.",
                "optional_value": true
            }
        },
        "Returns": {
            "type": null,
            "description": "Nothing, just plots the figure and optionally saves the plot."
        },
        "Docstring": "Plot cluster interaction matrix.\n\nThe interaction matrix is computed by :func:`squidpy.gr.interaction_matrix`.\n\nParameters\n----------\nadata\n    Annotated data object.\ncluster_key\n    Key in :attr:`anndata.AnnData.obs` where clustering is stored.\nannotate\n    Whether to annotate the cells of the heatmap.\nmethod\n    The linkage method to be used for dendrogram/clustering, see :func:`scipy.cluster.hierarchy.linkage`.\ntitle\n    The title of the plot.\ncmap\n    Continuous colormap to use.\ncbar_kwargs\n    Keyword arguments for :meth:`matplotlib.figure.Figure.colorbar`.\npalette\n    Categorical colormap for the clusters.\n    If `None`, use :attr:`anndata.AnnData.uns` ``['{cluster_key}_colors']``, if available.\nfigsize\n    Size of the figure in inches.\ndpi\n    Dots per inch.\nsave\n    Whether to save the plot.\nax\n    Axes, :class:`matplotlib.axes.Axes`.\nkwargs\n    Keyword arguments for :func:`matplotlib.pyplot.text`.\n\nReturns\n-------\nNothing, just plots the figure and optionally saves the plot.",
        "description": "Plot cluster interaction matrix.The interaction matrix is computed by :func:`squidpy.gr.interaction_matrix`.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "squidpy.pl.interaction_matrix(adata=$, cluster_key=@, annotate=@, method=@, title=@, cmap=@, palette=$, figsize=@, dpi=@, save=@, ax=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "squidpy.datasets.seqfish": {
        "Parameters": {
            "path": {
                "type": "Union[PathLike, str]",
                "default": "None",
                "optional": true,
                "description": "Path where to save the dataset.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": "The dataset."
        },
        "Docstring": "Pre-processed subset seqFISH dataset from `Lohoff et al <https://www.biorxiv.org/content/10.1101/2020.11.20.391896v1>`__.\n\nThe shape of this :class:`anndata.AnnData` object ``(19416, 351)``.\n\nParameters\n----------\npath\n    Path where to save the dataset.\nkwargs\n    Keyword arguments for :func:`scanpy.read`.\n\nReturns\n-------\nThe dataset.",
        "description": "Pre-processed subset seqFISH dataset from `Lohoff et al <https://www.biorxiv.org/content/10.1101/2020.11.20.391896v1>`__.The shape of this :class:`anndata.AnnData` object ``(19416, 351)``.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "squidpy.datasets.seqfish(path=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "squidpy.datasets.visium_fluo_adata_crop": {
        "Parameters": {
            "path": {
                "type": "Union[PathLike, str]",
                "default": "None",
                "optional": true,
                "description": "Path where to save the dataset.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": "The dataset."
        },
        "Docstring": "Pre-processed subset `10x Genomics Visium Fluorescent dataset <https://support.10xgenomics.com/spatial-gene-expression/datasets/1.1.0/V1_Adult_Mouse_Brain_Coronal_Section_2>`__.\n\nThe shape of this :class:`anndata.AnnData` object ``(704, 16562)``.\n\nParameters\n----------\npath\n    Path where to save the dataset.\nkwargs\n    Keyword arguments for :func:`scanpy.read`.\n\nReturns\n-------\nThe dataset.",
        "description": "Pre-processed subset `10x Genomics Visium Fluorescent dataset <https://support.10xgenomics.com/spatial-gene-expression/datasets/1.1.0/V1_Adult_Mouse_Brain_Coronal_Section_2>`__.The shape of this :class:`anndata.AnnData` object ``(704, 16562)``.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "squidpy.datasets.visium_fluo_adata_crop(path=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "squidpy.datasets.visium_hne_adata_crop": {
        "Parameters": {
            "path": {
                "type": "Union[PathLike, str]",
                "default": "None",
                "optional": true,
                "description": "Path where to save the dataset.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": "The dataset."
        },
        "Docstring": "Pre-processed subset `10x Genomics Visium H&E dataset <https://support.10xgenomics.com/spatial-gene-expression/datasets/1.1.0/V1_Adult_Mouse_Brain>`__.\n\nThe shape of this :class:`anndata.AnnData` object ``(684, 18078)``.\n\nParameters\n----------\npath\n    Path where to save the dataset.\nkwargs\n    Keyword arguments for :func:`scanpy.read`.\n\nReturns\n-------\nThe dataset.",
        "description": "Pre-processed subset `10x Genomics Visium H&E dataset <https://support.10xgenomics.com/spatial-gene-expression/datasets/1.1.0/V1_Adult_Mouse_Brain>`__.The shape of this :class:`anndata.AnnData` object ``(684, 18078)``.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "squidpy.datasets.visium_hne_adata_crop(path=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "squidpy.datasets.visium_hne_image": {
        "Parameters": {
            "path": {
                "type": "Union[PathLike, str]",
                "default": "None",
                "optional": true,
                "description": "Path where to save the .tiff image.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ":class:`squidpy.im.ImageContainer` The image data."
        },
        "Docstring": "H&E image from `10x Genomics Visium dataset <https://support.10xgenomics.com/spatial-gene-expression/datasets/1.1.0/V1_Adult_Mouse_Brain>`__.\n\nThe shape of this image is ``(11757, 11291)``.\n\nParameters\n----------\npath\n    Path where to save the .tiff image.\nkwargs\n    Keyword arguments for :meth:`squidpy.im.ImageContainer.add_img`.\n\nReturns\n-------\n:class:`squidpy.im.ImageContainer` The image data.",
        "description": "H&E image from `10x Genomics Visium dataset <https://support.10xgenomics.com/spatial-gene-expression/datasets/1.1.0/V1_Adult_Mouse_Brain>`__.The shape of this image is ``(11757, 11291)``.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "squidpy.datasets.visium_hne_image(path=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "squidpy.gr.co_occurrence": {
        "Parameters": {
            "adata": {
                "type": "Union[AnnData, SpatialData]",
                "default": null,
                "optional": false,
                "description": "Annotated data object.",
                "optional_value": true
            },
            "cluster_key": {
                "type": "str",
                "default": null,
                "optional": false,
                "description": "Key in :attr:`anndata.AnnData.obs` where clustering is stored.",
                "optional_value": false
            },
            "spatial_key": {
                "type": "str",
                "default": "spatial",
                "optional": true,
                "description": "Key in :attr:`anndata.AnnData.obsm` where spatial coordinates are stored.",
                "optional_value": false
            },
            "interval": {
                "type": "Union[int, ndarray[Any, dtype[Any]]]",
                "default": "50",
                "optional": true,
                "description": "Distances interval at which co-occurrence is computed. If :class:`int`, uniformly spaced interval\nof the given size will be used.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If ``True``, return the result, otherwise save it to the ``adata`` object.",
                "optional_value": false
            },
            "n_splits": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Number of splits in which to divide the spatial coordinates in\n:attr:`anndata.AnnData.obsm` ``['{spatial_key}']``.",
                "optional_value": false
            },
            "n_jobs": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Number of parallel jobs.",
                "optional_value": false
            },
            "backend": {
                "type": "str",
                "default": "loky",
                "optional": true,
                "description": "Parallelization backend to use. See :class:`joblib.Parallel` for available options.",
                "optional_value": false
            },
            "show_progress_bar": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to show the progress bar or not.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[tuple[ndarray[Any, dtype[Any]], ndarray[Any, dtype[Any]]]]",
            "description": "If ``copy = True``, returns the co-occurrence probability and the distance thresholds intervals.\nOtherwise, modifies the ``adata`` with the following keys:\n- :attr:`anndata.AnnData.uns` ``['{cluster_key}_co_occurrence']['occ']`` - the co-occurrence probabilities\nacross interval thresholds.\n- :attr:`anndata.AnnData.uns` ``['{cluster_key}_co_occurrence']['interval']`` - the distance thresholds\ncomputed at ``interval``."
        },
        "Docstring": "Compute co-occurrence probability of clusters.\n\nParameters\n----------\nadata\n    Annotated data object.\ncluster_key\n    Key in :attr:`anndata.AnnData.obs` where clustering is stored.\nspatial_key\n    Key in :attr:`anndata.AnnData.obsm` where spatial coordinates are stored.\ninterval\n    Distances interval at which co-occurrence is computed. If :class:`int`, uniformly spaced interval\n    of the given size will be used.\ncopy\n    If ``True``, return the result, otherwise save it to the ``adata`` object.\nn_splits\n    Number of splits in which to divide the spatial coordinates in\n    :attr:`anndata.AnnData.obsm` ``['{spatial_key}']``.\nn_jobs\n    Number of parallel jobs.\nbackend\n    Parallelization backend to use. See :class:`joblib.Parallel` for available options.\nshow_progress_bar\n    Whether to show the progress bar or not.\n\nReturns\n-------\nIf ``copy = True``, returns the co-occurrence probability and the distance thresholds intervals.\n\nOtherwise, modifies the ``adata`` with the following keys:\n\n    - :attr:`anndata.AnnData.uns` ``['{cluster_key}_co_occurrence']['occ']`` - the co-occurrence probabilities\n      across interval thresholds.\n    - :attr:`anndata.AnnData.uns` ``['{cluster_key}_co_occurrence']['interval']`` - the distance thresholds\n      computed at ``interval``.",
        "description": "Compute co-occurrence probability of clusters.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "squidpy.gr.co_occurrence(adata=$, cluster_key=@, spatial_key=@, interval=@, copy=@, n_splits=@, n_jobs=@, backend=@, show_progress_bar=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "squidpy.datasets.four_i": {
        "Parameters": {
            "path": {
                "type": "Union[PathLike, str]",
                "default": "None",
                "optional": true,
                "description": "Path where to save the dataset.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": "The dataset."
        },
        "Docstring": "Pre-processed subset 4i dataset from `Gut et al <https://doi.org/10.1126/science.aar7042>`__.\n\nThe shape of this :class:`anndata.AnnData` object ``(270876, 43)``.\n\nParameters\n----------\npath\n    Path where to save the dataset.\nkwargs\n    Keyword arguments for :func:`scanpy.read`.\n\nReturns\n-------\nThe dataset.",
        "description": "Pre-processed subset 4i dataset from `Gut et al <https://doi.org/10.1126/science.aar7042>`__.The shape of this :class:`anndata.AnnData` object ``(270876, 43)``.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "squidpy.datasets.four_i(path=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "squidpy.pl.spatial_scatter": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data object.",
                "optional_value": true
            },
            "shape": {
                "type": "Optional[_AvailShapes]",
                "default": "None",
                "optional": true,
                "description": "Whether to plot scatter plot of points or regular polygons.",
                "optional_value": true
            },
            "color": {
                "type": "Optional[Union[str, Sequence[str, None]]]",
                "default": "None",
                "optional": true,
                "description": "Key for annotations in :attr:`anndata.AnnData.obs` or variables/genes.",
                "optional_value": false
            },
            "groups": {
                "type": "Optional[_SeqStr]",
                "default": "None",
                "optional": true,
                "description": "For discrete annotation in ``color``, select which values to plot (other values are set to NAs).",
                "optional_value": true
            },
            "library_id": {
                "type": "Optional[_SeqStr]",
                "default": "None",
                "optional": true,
                "description": "Name of the Z-dimension(s) that this function should be applied to.\nFor not specified Z-dimensions, the identity function is applied.",
                "optional_value": true
            },
            "library_key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "If multiple `library_id`, column in :attr:`anndata.AnnData.obs`\nwhich stores mapping between ``library_id`` and obs.",
                "optional_value": false
            },
            "spatial_key": {
                "type": "str",
                "default": "spatial",
                "optional": true,
                "description": "Key in :attr:`anndata.AnnData.obsm` where spatial coordinates are stored.",
                "optional_value": false
            },
            "img": {
                "type": "Optional[Union[bool, _SeqArray]]",
                "default": "True",
                "optional": true,
                "description": "Whether to plot the image. One (or more) :class:`numpy.ndarray` can also be\npassed for plotting.",
                "optional_value": false
            },
            "img_res_key": {
                "type": "Optional[str]",
                "default": "hires",
                "optional": true,
                "description": "Key for image resolution, used to get ``img`` and ``scale_factor`` from ``'images'``\nand ``'scalefactors'`` entries for this library.",
                "optional_value": false
            },
            "img_alpha": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Alpha value for the underlying image.",
                "optional_value": false
            },
            "img_cmap": {
                "type": "Optional[Union[Colormap, str]]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "img_channel": {
                "type": "Optional[Union[int, list[int]]]",
                "default": "None",
                "optional": true,
                "description": "To select which channel to plot (all by default).",
                "optional_value": false
            },
            "use_raw": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "If True, use :attr:`anndata.AnnData.raw`.",
                "optional_value": false
            },
            "layer": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Key in :attr:`anndata.AnnData.layers` or `None` for :attr:`anndata.AnnData.X`.",
                "optional_value": false
            },
            "alt_var": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Which column to use in :attr:`anndata.AnnData.var` to select alternative ``var_name``.",
                "optional_value": false
            },
            "size": {
                "type": "Optional[_SeqFloat]",
                "default": "None",
                "optional": true,
                "description": "Size of the scatter point/shape. In case of ``spatial_shape`` it represents to the\nscaling factor for shape (accessed via ``size_key``). In case of ``spatial_point``,\nit represents the ``size`` argument in :func:`matplotlib.pyplot.scatter`.",
                "optional_value": true
            },
            "size_key": {
                "type": "Optional[str]",
                "default": "spot_diameter_fullres",
                "optional": true,
                "description": "Key of of pixel size of shapes to be plotted, stored in :attr:`anndata.AnnData.uns`.\nOnly needed for ``spatial_shape``.",
                "optional_value": false
            },
            "scale_factor": {
                "type": "Optional[_SeqFloat]",
                "default": "None",
                "optional": true,
                "description": "Scaling factor used to map from coordinate space to pixel space.\nFound by default if ``library_id`` and ``img_key`` can be resolved.\nOtherwise, defaults to `1`.",
                "optional_value": true
            },
            "crop_coord": {
                "type": "Optional[Union[_CoordTuple, Sequence[_CoordTuple]]]",
                "default": "None",
                "optional": true,
                "description": "Coordinates to use for cropping the image (left, right, top, bottom).\nThese coordinates are expected to be in pixel space (same as ``spatial``)\nand will be transformed by ``scale_factor``.\nIf not provided, image is automatically cropped to bounds of ``spatial``,\nplus a border.",
                "optional_value": true
            },
            "cmap": {
                "type": "Optional[Union[str, Colormap]]",
                "default": "None",
                "optional": true,
                "description": "Colormap for continuous annotations, see :class:`matplotlib.colors.Colormap`.",
                "optional_value": false
            },
            "palette": {
                "type": "Palette_t",
                "default": "None",
                "optional": true,
                "description": "Palette for discrete annotations, see :class:`matplotlib.colors.Colormap`.",
                "optional_value": true
            },
            "alpha": {
                "type": "float",
                "default": "1.0",
                "optional": true,
                "description": "Alpha value for scatter point/shape.",
                "optional_value": false
            },
            "norm": {
                "type": "Optional[_Normalize]",
                "default": "None",
                "optional": true,
                "description": "Colormap normalization for continuous annotations, see :class:`matplotlib.colors.Normalize`.",
                "optional_value": true
            },
            "na_color": {
                "type": "Union[str, tuple[float, ...]]",
                "default": "(0, 0, 0, 0)",
                "optional": true,
                "description": "Color to be used for NAs values, if present.",
                "optional_value": false
            },
            "connectivity_key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Key for neighbors graph to plot. Default is: :attr:`anndata.AnnData.obsp` ``['spatial_connectivities']``.",
                "optional_value": false
            },
            "edges_width": {
                "type": "float",
                "default": "1.0",
                "optional": true,
                "description": "Width of the edges. Only used when ``connectivity_key != None`` .",
                "optional_value": false
            },
            "edges_color": {
                "type": "Union[str, Sequence[str], Sequence[float]]",
                "default": "grey",
                "optional": true,
                "description": "Color of the edges.",
                "optional_value": false
            },
            "library_first": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "If multiple libraries are plotted, set the plotting order with respect to ``color``.",
                "optional_value": false
            },
            "frameon": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "If `True`, draw a frame around the panels.",
                "optional_value": false
            },
            "wspace": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Width space between panels.",
                "optional_value": false
            },
            "hspace": {
                "type": "float",
                "default": "0.25",
                "optional": true,
                "description": "Height space between panels.",
                "optional_value": false
            },
            "ncols": {
                "type": "int",
                "default": "4",
                "optional": true,
                "description": "Number of panels per row.",
                "optional_value": false
            },
            "outline": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If `True`, a thin border around points/shapes is plotted.",
                "optional_value": false
            },
            "outline_color": {
                "type": "tuple[str, str]",
                "default": "('black', 'white')",
                "optional": true,
                "description": "Color of the border.",
                "optional_value": false
            },
            "outline_width": {
                "type": "tuple[float, float]",
                "default": "(0.3, 0.05)",
                "optional": true,
                "description": "Width of the border.",
                "optional_value": false
            },
            "legend_loc": {
                "type": "Optional[str]",
                "default": "right margin",
                "optional": true,
                "description": "Location of the legend, see :class:`matplotlib.legend.Legend`.",
                "optional_value": false
            },
            "legend_fontsize": {
                "type": "Optional[Union[int, float, _FontSize]]",
                "default": "None",
                "optional": true,
                "description": "Font size of the legend, see :meth:`matplotlib.text.Text.set_fontsize`.",
                "optional_value": false
            },
            "legend_fontweight": {
                "type": "Union[int, _FontWeight]",
                "default": "bold",
                "optional": true,
                "description": "Font weight of the legend, see :meth:`matplotlib.text.Text.set_fontweight`.",
                "optional_value": false
            },
            "legend_fontoutline": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Font outline of the legend, see :class:`matplotlib.patheffects.withStroke`.",
                "optional_value": false
            },
            "legend_na": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to show NA values in the legend.",
                "optional_value": false
            },
            "colorbar": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to show the colorbar, see :func:`matplotlib.pyplot.colorbar`.",
                "optional_value": false
            },
            "scalebar_dx": {
                "type": "Optional[_SeqFloat]",
                "default": "None",
                "optional": true,
                "description": "Size of one pixel in units specified by ``scalebar_units``.",
                "optional_value": true
            },
            "scalebar_units": {
                "type": "Optional[_SeqStr]",
                "default": "None",
                "optional": true,
                "description": "Units of ``scalebar_dx``.",
                "optional_value": true
            },
            "title": {
                "type": "Optional[_SeqStr]",
                "default": "None",
                "optional": true,
                "description": "Panel titles.",
                "optional_value": true
            },
            "axis_label": {
                "type": "Optional[_SeqStr]",
                "default": "None",
                "optional": true,
                "description": "Panel axis labels.",
                "optional_value": true
            },
            "fig": {
                "type": "Optional[Figure]",
                "default": "None",
                "optional": true,
                "description": "Optional :class:`matplotlib.figure.Figure` to use.",
                "optional_value": true
            },
            "ax": {
                "type": "Optional[Union[Axes, Sequence[Axes]]]",
                "default": "None",
                "optional": true,
                "description": "Optional :class:`matplotlib.axes.Axes` to use.",
                "optional_value": true
            },
            "return_ax": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to return :class:`matplotlib.axes.Axes` object(s).",
                "optional_value": false
            },
            "figsize": {
                "type": "Optional[tuple[float, float]]",
                "default": "None",
                "optional": true,
                "description": "Size of the figure in inches.",
                "optional_value": false
            },
            "dpi": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Dots per inch.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[str, Path]]",
                "default": "None",
                "optional": true,
                "description": "Whether to save the plot.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[Union[Axes, Sequence[Axes]]]",
            "description": "Nothing, just plots the figure and optionally saves the plot."
        },
        "Docstring": "Plot spatial omics data with data overlayed on top.\n\nThe plotted shapes (circles, squares or hexagons) have a real \"size\" with respect to their\ncoordinate space, which can be specified via the ``size`` or ``size_key`` argument.\n\n    - Use ``img_key`` to display the image in the background.\n    - Use ``library_id`` to select the image. By default, ``'hires'`` is attempted.\n    - Use ``img_alpha``, ``img_cmap`` and ``img_channel`` to control how it is displayed.\n    - Use ``size`` to scale the size of the shapes plotted on top.\n\nIf no image is plotted, it defaults to a scatter plot, see :meth:`matplotlib.axes.Axes.scatter`.\n\nUse ``library_id`` to select the image. If multiple ``library_id`` are available, use ``library_key`` in\n:attr:`anndata.AnnData.obs` to plot the subsets.\nUse ``crop_coord`` to crop the spatial plot based on coordinate boundaries.\n\nThis function has few key assumptions about how coordinates and libraries are handled:\n\n    - The arguments ``library_key`` and ``library_id`` control which dataset is plotted.\n      If multiple libraries are present, specifying solely ``library_key`` will suffice, and all unique libraries\n      will be plotted sequentially. To select specific libraries, use the ``library_id`` argument.\n    - The argument ``color`` controls which features in obs/var are plotted. They are plotted for all\n      available/specified libraries. The argument ``groups`` can be used to select categories to be plotted.\n      This is valid only for categorical features in :attr:`anndata.AnnData.obs`.\n    - If multiple ``library_id`` are available, arguments such as ``size`` and ``crop_coord`` accept lists to\n      selectively customize different ``library_id`` plots. This requires that the length of such lists matches\n      the number of unique libraries in the dataset.\n    - Coordinates are in the pixel space of the source image, so an equal aspect ratio is assumed.\n    - The origin *(0, 0)* is on the top left, as is common convention with image data.\n    - The plotted points (dots) do not have a real \"size\" but it is relative to their coordinate/pixel space.\n      This does not hold if no image is plotted, then the size corresponds to points size passed to\n      :meth:`matplotlib.axes.Axes.scatter`.\n\nIf :attr:`anndata.AnnData.uns` ``['spatial']`` is present, use ``img_key``, ``seg_key`` and\n``size_key`` arguments to find values for ``img``, ``seg`` and ``size``.\nAlternatively, these values can be passed directly via ``img``.\n\n.. seealso::\n    - :func:`squidpy.pl.spatial_segment` on how to plot spatial data with segmentation masks on top.\n\nParameters\n----------\nadata\n    Annotated data object.\nshape\n    Whether to plot scatter plot of points or regular polygons.\ncolor\n    Key for annotations in :attr:`anndata.AnnData.obs` or variables/genes.\ngroups\n    For discrete annotation in ``color``, select which values to plot (other values are set to NAs).\nlibrary_id\n    Name of the Z-dimension(s) that this function should be applied to.\n    For not specified Z-dimensions, the identity function is applied.\nlibrary_key\n    If multiple `library_id`, column in :attr:`anndata.AnnData.obs`\n    which stores mapping between ``library_id`` and obs.\nspatial_key\n    Key in :attr:`anndata.AnnData.obsm` where spatial coordinates are stored.\nimg\n    Whether to plot the image. One (or more) :class:`numpy.ndarray` can also be\n    passed for plotting.\nimg_res_key\n    Key for image resolution, used to get ``img`` and ``scale_factor`` from ``'images'``\n    and ``'scalefactors'`` entries for this library.\nimg_alpha\n    Alpha value for the underlying image.\nimage_cmap\n    Colormap for the image, see :class:`matplotlib.colors.Colormap`.\nimg_channel\n    To select which channel to plot (all by default).\nuse_raw\n    If True, use :attr:`anndata.AnnData.raw`.\nlayer\n    Key in :attr:`anndata.AnnData.layers` or `None` for :attr:`anndata.AnnData.X`.\nalt_var\n    Which column to use in :attr:`anndata.AnnData.var` to select alternative ``var_name``.\nsize\n    Size of the scatter point/shape. In case of ``spatial_shape`` it represents to the\n    scaling factor for shape (accessed via ``size_key``). In case of ``spatial_point``,\n    it represents the ``size`` argument in :func:`matplotlib.pyplot.scatter`.\nsize_key\n    Key of of pixel size of shapes to be plotted, stored in :attr:`anndata.AnnData.uns`.\n    Only needed for ``spatial_shape``.\nscale_factor\n    Scaling factor used to map from coordinate space to pixel space.\n    Found by default if ``library_id`` and ``img_key`` can be resolved.\n    Otherwise, defaults to `1`.\ncrop_coord\n    Coordinates to use for cropping the image (left, right, top, bottom).\n    These coordinates are expected to be in pixel space (same as ``spatial``)\n    and will be transformed by ``scale_factor``.\n    If not provided, image is automatically cropped to bounds of ``spatial``,\n    plus a border.\ncmap\n    Colormap for continuous annotations, see :class:`matplotlib.colors.Colormap`.\npalette\n    Palette for discrete annotations, see :class:`matplotlib.colors.Colormap`.\nalpha\n    Alpha value for scatter point/shape.\nnorm\n    Colormap normalization for continuous annotations, see :class:`matplotlib.colors.Normalize`.\nna_color\n    Color to be used for NAs values, if present.\nconnectivity_key\n    Key for neighbors graph to plot. Default is: :attr:`anndata.AnnData.obsp` ``['spatial_connectivities']``.\nedges_width\n    Width of the edges. Only used when ``connectivity_key != None`` .\nedges_color\n    Color of the edges.\nlibrary_first\n    If multiple libraries are plotted, set the plotting order with respect to ``color``.\nframeon\n    If `True`, draw a frame around the panels.\nwspace\n    Width space between panels.\nhspace\n    Height space between panels.\nncols\n    Number of panels per row.\noutline\n    If `True`, a thin border around points/shapes is plotted.\noutline_color\n    Color of the border.\noutline_width\n    Width of the border.\nlegend_loc\n    Location of the legend, see :class:`matplotlib.legend.Legend`.\nlegend_fontsize\n    Font size of the legend, see :meth:`matplotlib.text.Text.set_fontsize`.\nlegend_fontweight\n    Font weight of the legend, see :meth:`matplotlib.text.Text.set_fontweight`.\nlegend_fontoutline\n    Font outline of the legend, see :class:`matplotlib.patheffects.withStroke`.\nlegend_na\n    Whether to show NA values in the legend.\ncolorbar\n    Whether to show the colorbar, see :func:`matplotlib.pyplot.colorbar`.\nscalebar_dx\n    Size of one pixel in units specified by ``scalebar_units``.\nscalebar_units\n    Units of ``scalebar_dx``.\ntitle\n    Panel titles.\naxis_label\n    Panel axis labels.\nfig\n    Optional :class:`matplotlib.figure.Figure` to use.\nax\n    Optional :class:`matplotlib.axes.Axes` to use.\nreturn_ax\n    Whether to return :class:`matplotlib.axes.Axes` object(s).\nfigsize\n    Size of the figure in inches.\ndpi\n    Dots per inch.\nsave\n    Whether to save the plot.\nscalebar_kwargs\n    Keyword arguments for :meth:`matplotlib_scalebar.ScaleBar`.\nedges_kwargs\n    Keyword arguments for :func:`networkx.draw_networkx_edges`.\nkwargs\n    Keyword arguments for :func:`matplotlib.pyplot.scatter` or :func:`matplotlib.pyplot.imshow`.\n\n\nReturns\n-------\nNothing, just plots the figure and optionally saves the plot.",
        "description": "Plot spatial omics data with data overlayed on top.The plotted shapes (circles, squares or hexagons) have a real \"size\" with respect to their\ncoordinate space, which can be specified via the ``size`` or ``size_key`` argument.\n\n    - Use ``img_key`` to display the image in the background.\n    - Use ``library_id`` to select the image. By default, ``'hires'`` is attempted.\n    - Use ``img_alpha``, ``img_cmap`` and ``img_channel`` to control how it is displayed.\n    - Use ``size`` to scale the size of the shapes plotted on top.\n\nIf no image is plotted, it defaults to a scatter plot, see :meth:`matplotlib.axes.Axes.scatter`.\n\nUse ``library_id`` to select the image. If multiple ``library_id`` are available, use ``library_key`` in\n:attr:`anndata.AnnData.obs` to plot the subsets.\nUse ``crop_coord`` to crop the spatial plot based on coordinate boundaries.\n\nThis function has few key assumptions about how coordinates and libraries are handled:\n\n    - The arguments ``library_key`` and ``library_id`` control which dataset is plotted.\n      If multiple libraries are present, specifying solely ``library_key`` will suffice, and all unique libraries\n      will be plotted sequentially. To select specific libraries, use the ``library_id`` argument.\n    - The argument ``color`` controls which features in obs/var are plotted. They are plotted for all\n      available/specified libraries. The argument ``groups`` can be used to select categories to be plotted.\n      This is valid only for categorical features in :attr:`anndata.AnnData.obs`.\n    - If multiple ``library_id`` are available, arguments such as ``size`` and ``crop_coord`` accept lists to\n      selectively customize different ``library_id`` plots. This requires that the length of such lists matches\n      the number of unique libraries in the dataset.\n    - Coordinates are in the pixel space of the source image, so an equal aspect ratio is assumed.\n    - The origin *(0, 0)* is on the top left, as is common convention with image data.\n    - The plotted points (dots) do not have a real \"size\" but it is relative to their coordinate/pixel space.\n      This does not hold if no image is plotted, then the size corresponds to points size passed to\n      :meth:`matplotlib.axes.Axes.scatter`.\n\nIf :attr:`anndata.AnnData.uns` ``['spatial']`` is present, use ``img_key``, ``seg_key`` and\n``size_key`` arguments to find values for ``img``, ``seg`` and ``size``.\nAlternatively, these values can be passed directly via ``img``.\n\n.. seealso::\n    - :func:`squidpy.pl.spatial_segment` on how to plot spatial data with segmentation masks on top.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "squidpy.pl.spatial_scatter(adata=$, shape=$, color=@, groups=$, library_id=$, library_key=@, spatial_key=@, img=@, img_res_key=@, img_alpha=@, img_cmap=@, img_channel=@, use_raw=@, layer=@, alt_var=@, size=$, size_key=@, scale_factor=$, crop_coord=$, cmap=@, palette=$, alpha=@, norm=$, na_color=@, connectivity_key=@, edges_width=@, edges_color=@, library_first=@, frameon=@, wspace=@, hspace=@, ncols=@, outline=@, outline_color=@, outline_width=@, legend_loc=@, legend_fontsize=@, legend_fontweight=@, legend_fontoutline=@, legend_na=@, colorbar=@, scalebar_dx=$, scalebar_units=$, title=$, axis_label=$, fig=$, ax=$, return_ax=@, figsize=@, dpi=@, save=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "squidpy.gr.sepal": {
        "Parameters": {
            "adata": {
                "type": "Union[AnnData, SpatialData]",
                "default": null,
                "optional": false,
                "description": "Annotated data object.",
                "optional_value": true
            },
            "max_neighs": {
                "type": "Literal[4, 6]",
                "default": null,
                "optional": false,
                "description": "Maximum number of neighbors of a node in the graph. Valid options are:\n\n    - `4` - for a square-grid (ST, Dbit-seq).\n    - `6` - for a hexagonal-grid (Visium).",
                "optional_value": true
            },
            "genes": {
                "type": "Optional[Union[str, Sequence[str]]]",
                "default": "None",
                "optional": true,
                "description": "List of gene names, as stored in :attr:`anndata.AnnData.var_names`, used to compute sepal score.\n\nIf `None`, it's computed :attr:`anndata.AnnData.var` ``['highly_variable']``, if present.\nOtherwise, it's computed for all genes.",
                "optional_value": false
            },
            "n_iter": {
                "type": "Optional[int]",
                "default": "30000",
                "optional": true,
                "description": "Maximum number of iterations for the diffusion simulation.\nIf ``n_iter`` iterations are reached, the simulation will terminate\neven though convergence has not been achieved.",
                "optional_value": false
            },
            "dt": {
                "type": "float",
                "default": "0.001",
                "optional": true,
                "description": "Time step in diffusion simulation.",
                "optional_value": false
            },
            "thresh": {
                "type": "float",
                "default": "1e-08",
                "optional": true,
                "description": "Entropy threshold for convergence of diffusion simulation.",
                "optional_value": false
            },
            "connectivity_key": {
                "type": "str",
                "default": "spatial_connectivities",
                "optional": true,
                "description": "Key in :attr:`anndata.AnnData.obsp` where spatial connectivities are stored.\nDefault is: :attr:`anndata.AnnData.obsp` ``['spatial_connectivities']``.",
                "optional_value": false
            },
            "spatial_key": {
                "type": "str",
                "default": "spatial",
                "optional": true,
                "description": "Key in :attr:`anndata.AnnData.obsm` where spatial coordinates are stored.",
                "optional_value": false
            },
            "layer": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Layer in :attr:`anndata.AnnData.layers` to use. If `None`, use :attr:`anndata.AnnData.X`.",
                "optional_value": false
            },
            "use_raw": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to access :attr:`anndata.AnnData.raw`.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If ``True``, return the result, otherwise save it to the ``adata`` object.",
                "optional_value": false
            },
            "n_jobs": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Number of parallel jobs.",
                "optional_value": false
            },
            "backend": {
                "type": "str",
                "default": "loky",
                "optional": true,
                "description": "Parallelization backend to use. See :class:`joblib.Parallel` for available options.",
                "optional_value": false
            },
            "show_progress_bar": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to show the progress bar or not.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[pd.DataFrame]",
            "description": "If ``copy = True``, returns a :class:`pandas.DataFrame` with the sepal scores.\nOtherwise, modifies the ``adata`` with the following key:\n- :attr:`anndata.AnnData.uns` ``['sepal_score']`` - the sepal scores.\nNotes\nIf some genes in :attr:`anndata.AnnData.uns` ``['sepal_score']`` are `NaN`,\nconsider re-running the function with increased ``n_iter``."
        },
        "Docstring": "Identify spatially variable genes with *Sepal*.\n\n*Sepal* is a method that simulates a diffusion process to quantify spatial structure in tissue.\nSee :cite:`andersson2021` for reference.\n\nParameters\n----------\nadata\n    Annotated data object.\nmax_neighs\n    Maximum number of neighbors of a node in the graph. Valid options are:\n\n        - `4` - for a square-grid (ST, Dbit-seq).\n        - `6` - for a hexagonal-grid (Visium).\ngenes\n    List of gene names, as stored in :attr:`anndata.AnnData.var_names`, used to compute sepal score.\n\n    If `None`, it's computed :attr:`anndata.AnnData.var` ``['highly_variable']``, if present.\n    Otherwise, it's computed for all genes.\nn_iter\n    Maximum number of iterations for the diffusion simulation.\n    If ``n_iter`` iterations are reached, the simulation will terminate\n    even though convergence has not been achieved.\ndt\n    Time step in diffusion simulation.\nthresh\n    Entropy threshold for convergence of diffusion simulation.\nconnectivity_key\n    Key in :attr:`anndata.AnnData.obsp` where spatial connectivities are stored.\n    Default is: :attr:`anndata.AnnData.obsp` ``['spatial_connectivities']``.\nspatial_key\n    Key in :attr:`anndata.AnnData.obsm` where spatial coordinates are stored.\nlayer\n    Layer in :attr:`anndata.AnnData.layers` to use. If `None`, use :attr:`anndata.AnnData.X`.\nuse_raw\n    Whether to access :attr:`anndata.AnnData.raw`.\ncopy\n    If ``True``, return the result, otherwise save it to the ``adata`` object.\nn_jobs\n    Number of parallel jobs.\nbackend\n    Parallelization backend to use. See :class:`joblib.Parallel` for available options.\nshow_progress_bar\n    Whether to show the progress bar or not.\n\nReturns\n-------\nIf ``copy = True``, returns a :class:`pandas.DataFrame` with the sepal scores.\n\nOtherwise, modifies the ``adata`` with the following key:\n\n    - :attr:`anndata.AnnData.uns` ``['sepal_score']`` - the sepal scores.\n\nNotes\n-----\nIf some genes in :attr:`anndata.AnnData.uns` ``['sepal_score']`` are `NaN`,\nconsider re-running the function with increased ``n_iter``.",
        "description": "Identify spatially variable genes with *Sepal*.*Sepal* is a method that simulates a diffusion process to quantify spatial structure in tissue.\nSee :cite:`andersson2021` for reference.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "squidpy.gr.sepal(adata=$, max_neighs=$, genes=@, n_iter=@, dt=@, thresh=@, connectivity_key=@, spatial_key=@, layer=@, use_raw=@, copy=@, n_jobs=@, backend=@, show_progress_bar=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "squidpy.im.segment": {
        "Parameters": {
            "img": {
                "type": "ImageContainer",
                "default": null,
                "optional": false,
                "description": "High-resolution image.",
                "optional_value": true
            },
            "layer": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Image layer in ``img`` that should be processed. If `None` and only 1 layer is present, it will be selected.",
                "optional_value": false
            },
            "library_id": {
                "type": "Optional[Union[str, Sequence[str]]]",
                "default": "None",
                "optional": true,
                "description": "Name of the Z-dimension(s) that this function should be applied to.\nFor not specified Z-dimensions, the identity function is applied.\nIf `None`, all Z-dimensions are segmented separately.",
                "optional_value": false
            },
            "method": {
                "type": "Union[str, SegmentationModel, Callable[..., ndarray[Any, dtype[Any]]]]",
                "default": "watershed",
                "optional": true,
                "description": "Segmentation method to use. Valid options are:\n\n    - `'watershed'` - :func:`skimage.segmentation.watershed`.\n\nAlternatively, any :func:`callable` can be passed as long as it has the following signature:\n:class:`numpy.ndarray` ``(height, width, channels)`` **->** :class:`numpy.ndarray` ``(height, width[, channels])``.",
                "optional_value": false
            },
            "channel": {
                "type": "Optional[int]",
                "default": "0",
                "optional": true,
                "description": "Channel index to use for segmentation. If `None`, use all channels.",
                "optional_value": false
            },
            "chunks": {
                "type": "Optional[Union[str, int, tuple[int, int]]]",
                "default": "None",
                "optional": true,
                "description": "Number of chunks for :mod:`dask`. For automatic chunking, use ``chunks = 'auto'``.",
                "optional_value": false
            },
            "lazy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to lazily compute the result or not. Only used when ``chunks != None``.",
                "optional_value": false
            },
            "layer_added": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Layer of new image layer to add into ``img`` object. If `None`, use ``'segmented_{model}'``.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If ``True``, return the result, otherwise save it to the image container.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[ImageContainer]",
            "description": "If ``copy = True``, returns a new container with the segmented image in ``'{layer_added}'``.\nOtherwise, modifies the ``img`` with the following key:\n- :class:`squidpy.im.ImageContainer` ``['{layer_added}']`` - the segmented image."
        },
        "Docstring": "Segment an image.\n\nParameters\n----------\nimg\n    High-resolution image.\nlayer\n    Image layer in ``img`` that should be processed. If `None` and only 1 layer is present, it will be selected.\nlibrary_id\n    Name of the Z-dimension(s) that this function should be applied to.\n    For not specified Z-dimensions, the identity function is applied.\n    If `None`, all Z-dimensions are segmented separately.\nmethod\n    Segmentation method to use. Valid options are:\n\n        - `'watershed'` - :func:`skimage.segmentation.watershed`.\n\n    Alternatively, any :func:`callable` can be passed as long as it has the following signature:\n    :class:`numpy.ndarray` ``(height, width, channels)`` **->** :class:`numpy.ndarray` ``(height, width[, channels])``.\nchannel\n    Channel index to use for segmentation. If `None`, use all channels.\nchunks\n    Number of chunks for :mod:`dask`. For automatic chunking, use ``chunks = 'auto'``.\nlazy\n    Whether to lazily compute the result or not. Only used when ``chunks != None``.\nlayer_added\n    Layer of new image layer to add into ``img`` object. If `None`, use ``'segmented_{model}'``.\nthresh\n    Threshold for creation of masked image. The areas to segment should be contained in this mask.\n    If `None`, it is determined by `Otsu's method <https://en.wikipedia.org/wiki/Otsu%27s_method>`_.\n    Only used if ``method = 'watershed'``.\ngeq\n    Treat ``thresh`` as upper or lower bound for defining areas to segment. If ``geq = True``, mask is defined\n    as ``mask = arr >= thresh``, meaning high values in ``arr`` denote areas to segment.\n    Only used if ``method = 'watershed'``.\ncopy\n    If ``True``, return the result, otherwise save it to the image container.\nkwargs\n    Keyword arguments for the underlying model.\n\nReturns\n-------\nIf ``copy = True``, returns a new container with the segmented image in ``'{layer_added}'``.\n\nOtherwise, modifies the ``img`` with the following key:\n\n    - :class:`squidpy.im.ImageContainer` ``['{layer_added}']`` - the segmented image.",
        "description": "Segment an image.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "squidpy.im.segment(img=$, layer=@, library_id=@, method=@, channel=@, chunks=@, lazy=@, layer_added=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "squidpy.datasets.visium": {
        "Parameters": {
            "sample_id": {
                "type": "VisiumDatasets",
                "default": null,
                "optional": false,
                "description": "Name of the Visium dataset.",
                "optional_value": false
            },
            "include_hires_tiff": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to download the high-resolution tissue section into\n:attr:`anndata.AnnData.uns` ``['spatial']['{sample_id}']['metadata']['source_image_path']``.",
                "optional_value": false
            },
            "base_dir": {
                "type": "Optional[PathLike]",
                "default": "None",
                "optional": true,
                "description": "Directory where to download the data. If `None`, use :attr:`scanpy._settings.ScanpyConfig.datasetdir`.",
                "optional_value": true
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": "Spatial :class:`anndata.AnnData`."
        },
        "Docstring": "Download Visium `datasets <https://support.10xgenomics.com/spatial-gene-expression/datasets>`_ from *10x Genomics*.\n\nParameters\n----------\nsample_id\n    Name of the Visium dataset.\ninclude_hires_tiff\n    Whether to download the high-resolution tissue section into\n    :attr:`anndata.AnnData.uns` ``['spatial']['{sample_id}']['metadata']['source_image_path']``.\nbase_dir\n    Directory where to download the data. If `None`, use :attr:`scanpy._settings.ScanpyConfig.datasetdir`.\n\nReturns\n-------\nSpatial :class:`anndata.AnnData`.",
        "description": "Download Visium `datasets <https://support.10xgenomics.com/spatial-gene-expression/datasets>`_ from *10x Genomics*.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "squidpy.datasets.visium(sample_id=@, include_hires_tiff=@, base_dir=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "squidpy.read.vizgen": {
        "Parameters": {
            "path": {
                "type": "Union[str, Path]",
                "default": null,
                "optional": false,
                "description": "Path to the root directory containing *Vizgen* files.",
                "optional_value": false
            },
            "counts_file": {
                "type": "str",
                "default": null,
                "optional": false,
                "description": "File containing the counts. Typically ends with *_cell_by_gene.csv*.",
                "optional_value": false
            },
            "meta_file": {
                "type": "str",
                "default": null,
                "optional": false,
                "description": "File containing the spatial coordinates and additional cell-level metadata.",
                "optional_value": false
            },
            "transformation_file": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Transformation matrix file for converting micron coordinates into pixels in images.",
                "optional_value": false
            },
            "library_id": {
                "type": "str",
                "default": "library",
                "optional": true,
                "description": "Identifier for the *Vizgen* library. Useful when concatenating multiple :class:`anndata.AnnData` objects.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": "Annotated data object with the following keys:\n- :attr:`anndata.AnnData.obsm` ``['spatial']`` - spatial spot coordinates in microns.\n- :attr:`anndata.AnnData.obsm` ``['blank_genes']`` - blank genes from Vizgen platform.\n- :attr:`anndata.AnnData.uns` ``['spatial']['{library_id}']['scalefactors']['transformation_matrix']`` -\ntransformation matrix for converting micron coordinates to pixels.\nOnly present if ``transformation_file != None``."
        },
        "Docstring": "Read *Vizgen* formatted dataset.\n\nIn addition to reading the regular *Vizgen* output, it loads the metadata file and optionally loads\nthe transformation matrix.\n\n.. seealso::\n\n    - `Vizgen data release program <https://vizgen.com/data-release-program/>`_.\n    - :func:`squidpy.pl.spatial_scatter` on how to plot spatial data.\n\nParameters\n----------\npath\n    Path to the root directory containing *Vizgen* files.\ncounts_file\n    File containing the counts. Typically ends with *_cell_by_gene.csv*.\nmeta_file\n    File containing the spatial coordinates and additional cell-level metadata.\ntransformation_file\n    Transformation matrix file for converting micron coordinates into pixels in images.\nlibrary_id\n    Identifier for the *Vizgen* library. Useful when concatenating multiple :class:`anndata.AnnData` objects.\n\nReturns\n-------\nAnnotated data object with the following keys:\n\n    - :attr:`anndata.AnnData.obsm` ``['spatial']`` - spatial spot coordinates in microns.\n    - :attr:`anndata.AnnData.obsm` ``['blank_genes']`` - blank genes from Vizgen platform.\n    - :attr:`anndata.AnnData.uns` ``['spatial']['{library_id}']['scalefactors']['transformation_matrix']`` -\n      transformation matrix for converting micron coordinates to pixels.\n      Only present if ``transformation_file != None``.",
        "description": "Read *Vizgen* formatted dataset.In addition to reading the regular *Vizgen* output, it loads the metadata file and optionally loads\nthe transformation matrix.\n\n.. seealso::\n\n    - `Vizgen data release program <https://vizgen.com/data-release-program/>`_.\n    - :func:`squidpy.pl.spatial_scatter` on how to plot spatial data.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "squidpy.read.vizgen(path=@, counts_file=@, meta_file=@, transformation_file=@, library_id=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "squidpy.pl.extract": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data object.",
                "optional_value": true
            },
            "obsm_key": {
                "type": "Union[list[str], str]",
                "default": "img_features",
                "optional": true,
                "description": "Entries in :attr:`anndata.AnnData.obsm` that should be moved to :attr:`anndata.AnnData.obs`.",
                "optional_value": false
            },
            "prefix": {
                "type": "Optional[Union[list[str], str]]",
                "default": "None",
                "optional": true,
                "description": "Prefix to prepend to each column name. Should be a :class;`list` if ``obsm_key`` is a :class:`list`.\nIf `None`, use the original column names.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": "Temporary :class:`anndata.AnnData` object with desired entries in :attr:`anndata.AnnData.obs`.\nRaises\nValueError\nIf number of ``prefixes`` does not fit to number of ``obsm_keys``.\nNotes\nIf :attr:`anndata.AnnData.obs` ``['{column}']`` already exists, it will be overwritten and a warning will be issued."
        },
        "Docstring": "Create a temporary :class:`anndata.AnnData` object for plotting.\n\nMove columns from :attr:`anndata.AnnData.obsm` ``['{obsm_key}']`` to :attr:`anndata.AnnData.obs` to enable\nthe use of :mod:`scanpy.plotting` functions.\n\nParameters\n----------\nadata\n    Annotated data object.\nobsm_key\n    Entries in :attr:`anndata.AnnData.obsm` that should be moved to :attr:`anndata.AnnData.obs`.\nprefix\n    Prefix to prepend to each column name. Should be a :class;`list` if ``obsm_key`` is a :class:`list`.\n    If `None`, use the original column names.\n\nReturns\n-------\nTemporary :class:`anndata.AnnData` object with desired entries in :attr:`anndata.AnnData.obs`.\n\nRaises\n------\nValueError\n    If number of ``prefixes`` does not fit to number of ``obsm_keys``.\n\nNotes\n-----\nIf :attr:`anndata.AnnData.obs` ``['{column}']`` already exists, it will be overwritten and a warning will be issued.",
        "description": "Create a temporary :class:`anndata.AnnData` object for plotting.Move columns from :attr:`anndata.AnnData.obsm` ``['{obsm_key}']`` to :attr:`anndata.AnnData.obs` to enable\nthe use of :mod:`scanpy.plotting` functions.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "squidpy.pl.extract(adata=$, obsm_key=@, prefix=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "squidpy.datasets.mibitof": {
        "Parameters": {
            "path": {
                "type": "Union[PathLike, str]",
                "default": "None",
                "optional": true,
                "description": "Path where to save the dataset.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": "The dataset."
        },
        "Docstring": "Pre-processed MIBI-TOF dataset from `Hartmann et al <https://doi.org/10.1101/2020.01.17.909796>`__.\n\nThe shape of this :class:`anndata.AnnData` object ``(3309, 36)``.\n\nParameters\n----------\npath\n    Path where to save the dataset.\nkwargs\n    Keyword arguments for :func:`scanpy.read`.\n\nReturns\n-------\nThe dataset.",
        "description": "Pre-processed MIBI-TOF dataset from `Hartmann et al <https://doi.org/10.1101/2020.01.17.909796>`__.The shape of this :class:`anndata.AnnData` object ``(3309, 36)``.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "squidpy.datasets.mibitof(path=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "squidpy.pl.var_by_distance": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data object.",
                "optional_value": true
            },
            "var": {
                "type": "Union[str, list[str]]",
                "default": null,
                "optional": false,
                "description": "Variables to plot on y-axis.",
                "optional_value": false
            },
            "anchor_key": {
                "type": "Union[str, list[str]]",
                "default": null,
                "optional": false,
                "description": "Anchor point column from which distances are taken.",
                "optional_value": false
            },
            "design_matrix_key": {
                "type": "str",
                "default": "design_matrix",
                "optional": true,
                "description": "Name of the design matrix, previously computed with :func:`squidpy.tl.var_by_distance`, to use.",
                "optional_value": false
            },
            "color": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Variables to plot on color palette.",
                "optional_value": false
            },
            "covariate": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "A covariate for which separate regression lines are plotted for each category.",
                "optional_value": false
            },
            "order": {
                "type": "int",
                "default": "5",
                "optional": true,
                "description": "Order of the polynomial fit for :func:`seaborn.regplot`.",
                "optional_value": false
            },
            "show_scatter": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to show a scatter plot underlying the regression line.",
                "optional_value": false
            },
            "line_palette": {
                "type": "Optional[Union[str, Sequence[str], Cycler]]",
                "default": "None",
                "optional": true,
                "description": "Categorical color palette used in case a covariate is specified.",
                "optional_value": false
            },
            "scatter_palette": {
                "type": "Optional[Union[str, Sequence[str], Cycler]]",
                "default": "viridis",
                "optional": true,
                "description": "Color palette for the scatter plot underlying the `sns.regplot`",
                "optional_value": false
            },
            "dpi": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Dots per inch.",
                "optional_value": false
            },
            "figsize": {
                "type": "Optional[tuple[int, int]]",
                "default": "None",
                "optional": true,
                "description": "Size of the figure in inches.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[str, Path]]",
                "default": "None",
                "optional": true,
                "description": "Whether to save the plot.",
                "optional_value": false
            },
            "title": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Panel titles.",
                "optional_value": false
            },
            "axis_label": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Panel axis labels.",
                "optional_value": false
            },
            "return_ax": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[Axes]",
            "description": "Nothing, just plots the figure and optionally saves the plot."
        },
        "Docstring": "Plot a variable using a smooth regression line with increasing distance to an anchor point.\n\nParameters\n----------\nadata\n    Annotated data object.\ndesign_matrix_key\n    Name of the design matrix, previously computed with :func:`squidpy.tl.var_by_distance`, to use.\nvar\n    Variables to plot on y-axis.\nanchor_key\n    Anchor point column from which distances are taken.\ncolor\n    Variables to plot on color palette.\ncovariate\n    A covariate for which separate regression lines are plotted for each category.\norder\n    Order of the polynomial fit for :func:`seaborn.regplot`.\nshow_scatter\n    Whether to show a scatter plot underlying the regression line.\nline_palette\n    Categorical color palette used in case a covariate is specified.\nscatter_palette\n    Color palette for the scatter plot underlying the `sns.regplot`\nfigsize\n    Size of the figure in inches.\ndpi\n    Dots per inch.\nsave\n    Whether to save the plot.\nscalebar_kwargs\n    Keyword arguments for :meth:`matplotlib_scalebar.ScaleBar`.\nedges_kwargs\n    Keyword arguments for :func:`networkx.draw_networkx_edges`.\nkwargs\n    Keyword arguments for :func:`matplotlib.pyplot.scatter` or :func:`matplotlib.pyplot.imshow`.\n\ntitle\n    Panel titles.\naxis_label\n    Panel axis labels.\nregplot_kwargs\n    Kwargs for `sns.regplot`\nscatterplot_kwargs\n    Kwargs for `sns.scatter`\n\nReturns\n-------\nNothing, just plots the figure and optionally saves the plot.",
        "description": "Plot a variable using a smooth regression line with increasing distance to an anchor point.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "squidpy.pl.var_by_distance(adata=$, var=@, anchor_key=@, design_matrix_key=@, color=@, covariate=@, order=@, show_scatter=@, line_palette=@, scatter_palette=@, dpi=@, figsize=@, save=@, title=@, axis_label=@, return_ax=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "squidpy.pl.ripley": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data object.",
                "optional_value": true
            },
            "cluster_key": {
                "type": "str",
                "default": null,
                "optional": false,
                "description": "Key in :attr:`anndata.AnnData.obs` where clustering is stored.",
                "optional_value": false
            },
            "mode": {
                "type": "Literal['F', 'G', 'L']",
                "default": "F",
                "optional": true,
                "description": "Ripley's statistics to be plotted.",
                "optional_value": true
            },
            "plot_sims": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to overlay simulations in the plot.",
                "optional_value": false
            },
            "palette": {
                "type": "Palette_t",
                "default": "None",
                "optional": true,
                "description": "Categorical colormap for the clusters.\nIf ``None``, use :attr:`anndata.AnnData.uns` ``['{cluster_key}_colors']``, if available.",
                "optional_value": true
            },
            "figsize": {
                "type": "Optional[tuple[float, float]]",
                "default": "None",
                "optional": true,
                "description": "Size of the figure in inches.",
                "optional_value": false
            },
            "dpi": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Dots per inch.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[str, Path]]",
                "default": "None",
                "optional": true,
                "description": "Whether to save the plot.",
                "optional_value": false
            },
            "ax": {
                "type": "Optional[Axes]",
                "default": "None",
                "optional": true,
                "description": "Axes, :class:`matplotlib.axes.Axes`.",
                "optional_value": true
            }
        },
        "Returns": {
            "type": null,
            "description": "Nothing, just plots the figure and optionally saves the plot."
        },
        "Docstring": "Plot Ripley's statistics for each cluster.\n\nThe estimate is computed by :func:`squidpy.gr.ripley`.\n\nParameters\n----------\nadata\n    Annotated data object.\ncluster_key\n    Key in :attr:`anndata.AnnData.obs` where clustering is stored.\nmode\n    Ripley's statistics to be plotted.\nplot_sims\n    Whether to overlay simulations in the plot.\npalette\n    Categorical colormap for the clusters.\n    If ``None``, use :attr:`anndata.AnnData.uns` ``['{cluster_key}_colors']``, if available.\nfigsize\n    Size of the figure in inches.\ndpi\n    Dots per inch.\nsave\n    Whether to save the plot.\nscalebar_kwargs\n    Keyword arguments for :meth:`matplotlib_scalebar.ScaleBar`.\nedges_kwargs\n    Keyword arguments for :func:`networkx.draw_networkx_edges`.\nkwargs\n    Keyword arguments for :func:`matplotlib.pyplot.scatter` or :func:`matplotlib.pyplot.imshow`.\n\nax\n    Axes, :class:`matplotlib.axes.Axes`.\nlegend_kwargs\n    Keyword arguments for :func:`matplotlib.pyplot.legend`.\nkwargs\n    Keyword arguments for :func:`seaborn.lineplot`.\n\nReturns\n-------\nNothing, just plots the figure and optionally saves the plot.",
        "description": "Plot Ripley's statistics for each cluster.The estimate is computed by :func:`squidpy.gr.ripley`.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "squidpy.pl.ripley(adata=$, cluster_key=@, mode=$, plot_sims=@, palette=$, figsize=@, dpi=@, save=@, ax=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "squidpy.read.nanostring": {
        "Parameters": {
            "path": {
                "type": "Union[str, Path]",
                "default": null,
                "optional": false,
                "description": "Path to the root directory containing *Nanostring* files.",
                "optional_value": false
            },
            "counts_file": {
                "type": "str",
                "default": null,
                "optional": false,
                "description": "File containing the counts. Typically ends with *_exprMat_file.csv*.",
                "optional_value": false
            },
            "meta_file": {
                "type": "str",
                "default": null,
                "optional": false,
                "description": "File containing the spatial coordinates and additional cell-level metadata.\nTypically ends with *_metadata_file.csv*.",
                "optional_value": false
            },
            "fov_file": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "File containing the coordinates of all the fields of view.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": "Annotated data object with the following keys:\n- :attr:`anndata.AnnData.obsm` ``['spatial']`` -  local coordinates of the centers of cells.\n- :attr:`anndata.AnnData.obsm` ``['spatial_fov']`` - global coordinates of the centers of cells in the\nfield of view.\n- :attr:`anndata.AnnData.uns` ``['spatial']['{fov}']['images']`` - *hires* and *segmentation* images.\n- :attr:`anndata.AnnData.uns` ``['spatial']['{fov}']['metadata']]['{x,y}_global_px']`` - coordinates of the field of view.\nOnly present if ``fov_file != None``."
        },
        "Docstring": "Read *Nanostring* formatted dataset.\n\nIn addition to reading the regular *Nanostring* output, it loads the metadata file, *CellComposite* and *CellLabels*\ndirectories containing the images and optionally the field of view file.\n\n.. seealso::\n\n    - `Nanostring Spatial Molecular Imager <https://nanostring.com/products/cosmx-spatial-molecular-imager/>`_.\n    - :func:`squidpy.pl.spatial_scatter` on how to plot spatial data.\n\nParameters\n----------\npath\n    Path to the root directory containing *Nanostring* files.\ncounts_file\n    File containing the counts. Typically ends with *_exprMat_file.csv*.\nmeta_file\n    File containing the spatial coordinates and additional cell-level metadata.\n    Typically ends with *_metadata_file.csv*.\nfov_file\n    File containing the coordinates of all the fields of view.\n\nReturns\n-------\nAnnotated data object with the following keys:\n\n    - :attr:`anndata.AnnData.obsm` ``['spatial']`` -  local coordinates of the centers of cells.\n    - :attr:`anndata.AnnData.obsm` ``['spatial_fov']`` - global coordinates of the centers of cells in the\n      field of view.\n    - :attr:`anndata.AnnData.uns` ``['spatial']['{fov}']['images']`` - *hires* and *segmentation* images.\n    - :attr:`anndata.AnnData.uns` ``['spatial']['{fov}']['metadata']]['{x,y}_global_px']`` - coordinates of the field of view.\n      Only present if ``fov_file != None``.",
        "description": "Read *Nanostring* formatted dataset.In addition to reading the regular *Nanostring* output, it loads the metadata file, *CellComposite* and *CellLabels*\ndirectories containing the images and optionally the field of view file.\n\n.. seealso::\n\n    - `Nanostring Spatial Molecular Imager <https://nanostring.com/products/cosmx-spatial-molecular-imager/>`_.\n    - :func:`squidpy.pl.spatial_scatter` on how to plot spatial data.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "squidpy.read.nanostring(path=@, counts_file=@, meta_file=@, fov_file=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "squidpy.datasets.merfish": {
        "Parameters": {
            "path": {
                "type": "Union[PathLike, str]",
                "default": "None",
                "optional": true,
                "description": "Path where to save the dataset.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": "The dataset."
        },
        "Docstring": "Pre-processed MERFISH dataset from `Moffitt et al <https://doi.org/10.1126/science.aau5324>`__.\n\nThe shape of this :class:`anndata.AnnData` object ``(73655, 161)``.\n\nParameters\n----------\npath\n    Path where to save the dataset.\nkwargs\n    Keyword arguments for :func:`scanpy.read`.\n\nReturns\n-------\nThe dataset.",
        "description": "Pre-processed MERFISH dataset from `Moffitt et al <https://doi.org/10.1126/science.aau5324>`__.The shape of this :class:`anndata.AnnData` object ``(73655, 161)``.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "squidpy.datasets.merfish(path=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "squidpy.read.visium": {
        "Parameters": {
            "path": {
                "type": "PathLike",
                "default": null,
                "optional": false,
                "description": "Path to the root directory containing *Visium* files.",
                "optional_value": true
            },
            "counts_file": {
                "type": "str",
                "default": "filtered_feature_bc_matrix.h5",
                "optional": true,
                "description": "Which file in the passed directory to use as the count file. Typically either *filtered_feature_bc_matrix.h5* or\n*raw_feature_bc_matrix.h5*.",
                "optional_value": false
            },
            "library_id": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Identifier for the *Visium* library. Useful when concatenating multiple :class:`anndata.AnnData` objects.",
                "optional_value": false
            },
            "load_images": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "source_image_path": {
                "type": "Optional[PathLike]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": true
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": "Annotated data object with the following keys:\n- :attr:`anndata.AnnData.obsm` ``['spatial']`` - spatial spot coordinates.\n- :attr:`anndata.AnnData.uns` ``['spatial']['{library_id}']['images']`` - *hires* and *lowres* images.\n- :attr:`anndata.AnnData.uns` ``['spatial']['{library_id}']['scalefactors']`` - scale factors for the spots.\n- :attr:`anndata.AnnData.uns` ``['spatial']['{library_id}']['metadata']`` - various metadata."
        },
        "Docstring": "Read *10x Genomics* Visium formatted dataset.\n\nIn addition to reading the regular *Visium* output, it looks for the *spatial* directory and loads the images,\nspatial coordinates and scale factors.\n\n.. seealso::\n\n    - `Space Ranger output <https://support.10xgenomics.com/spatial-gene-expression/software/pipelines/latest/output/overview>`_.\n    - :func:`squidpy.pl.spatial_scatter` on how to plot spatial data.\n\nParameters\n----------\npath\n    Path to the root directory containing *Visium* files.\ncounts_file\n    Which file in the passed directory to use as the count file. Typically either *filtered_feature_bc_matrix.h5* or\n    *raw_feature_bc_matrix.h5*.\nlibrary_id\n    Identifier for the *Visium* library. Useful when concatenating multiple :class:`anndata.AnnData` objects.\nkwargs\n    Keyword arguments for :func:`scanpy.read_10x_h5`, :func:`anndata.read_mtx` or :func:`read_text`.\n\nReturns\n-------\nAnnotated data object with the following keys:\n\n    - :attr:`anndata.AnnData.obsm` ``['spatial']`` - spatial spot coordinates.\n    - :attr:`anndata.AnnData.uns` ``['spatial']['{library_id}']['images']`` - *hires* and *lowres* images.\n    - :attr:`anndata.AnnData.uns` ``['spatial']['{library_id}']['scalefactors']`` - scale factors for the spots.\n    - :attr:`anndata.AnnData.uns` ``['spatial']['{library_id}']['metadata']`` - various metadata.",
        "description": "Read *10x Genomics* Visium formatted dataset.In addition to reading the regular *Visium* output, it looks for the *spatial* directory and loads the images,\nspatial coordinates and scale factors.\n\n.. seealso::\n\n    - `Space Ranger output <https://support.10xgenomics.com/spatial-gene-expression/software/pipelines/latest/output/overview>`_.\n    - :func:`squidpy.pl.spatial_scatter` on how to plot spatial data.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "squidpy.read.visium(path=$, counts_file=@, library_id=@, load_images=@, source_image_path=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "squidpy.gr.ripley": {
        "Parameters": {
            "adata": {
                "type": "Union[AnnData, SpatialData]",
                "default": null,
                "optional": false,
                "description": "Annotated data object.",
                "optional_value": true
            },
            "cluster_key": {
                "type": "str",
                "default": null,
                "optional": false,
                "description": "Key in :attr:`anndata.AnnData.obs` where clustering is stored.",
                "optional_value": false
            },
            "mode": {
                "type": "Literal['F', 'G', 'L']",
                "default": "F",
                "optional": true,
                "description": "Which Ripley's statistic to compute.",
                "optional_value": true
            },
            "spatial_key": {
                "type": "str",
                "default": "spatial",
                "optional": true,
                "description": "Key in :attr:`anndata.AnnData.obsm` where spatial coordinates are stored.",
                "optional_value": false
            },
            "metric": {
                "type": "str",
                "default": "euclidean",
                "optional": true,
                "description": "Which metric to use for computing distances.\nFor available metrics, check out :class:`sklearn.neighbors.DistanceMetric`.",
                "optional_value": false
            },
            "n_neigh": {
                "type": "int",
                "default": "2",
                "optional": true,
                "description": "Number of neighbors to consider for the KNN graph.",
                "optional_value": false
            },
            "n_simulations": {
                "type": "int",
                "default": "100",
                "optional": true,
                "description": "How many simulations to run for computing p-values.",
                "optional_value": false
            },
            "n_observations": {
                "type": "int",
                "default": "1000",
                "optional": true,
                "description": "How many observations to generate for the Spatial Poisson Point Process.",
                "optional_value": false
            },
            "max_dist": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Maximum distances for the support. If `None`, `max_dist=`:math:`\\sqrt{area \\over 2}`.",
                "optional_value": false
            },
            "n_steps": {
                "type": "int",
                "default": "50",
                "optional": true,
                "description": "Number of steps for the support.",
                "optional_value": false
            },
            "seed": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Random seed for reproducibility.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If ``True``, return the result, otherwise save it to the ``adata`` object.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "dict[str, pd.DataFrame | ndarray[Any, dtype[Any]]]",
            "description": "If ``copy = True``, returns a :class:`dict` with following keys:\n- `'{mode}_stat'` - :class:`pandas.DataFrame` containing the statistics of choice for the real observations.\n- `'sims_stat'` - :class:`pandas.DataFrame` containing the statistics of choice for the simulations.\n- `'bins'` - :class:`numpy.ndarray` containing the support.\n- `'pvalues'` - :class:`numpy.ndarray` containing the p-values for the statistics of interest.\nOtherwise, modifies the ``adata`` object with the following key:\n- :attr:`anndata.AnnData.uns` ``['{key_added}']`` - the above mentioned :class:`dict`.\nStatistics and p-values are computed for each cluster :attr:`anndata.AnnData.obs` ``['{cluster_key}']`` separately.\nReferences\nFor reference, check out\n`Wikipedia <https://en.wikipedia.org/wiki/Spatial_descriptive_statistics#Ripley's_K_and_L_functions>`_\nor :cite:`Baddeley2015-lm`."
        },
        "Docstring": "Calculate various Ripley's statistics for point processes.\n\nAccording to the `'mode'` argument, it calculates one of the following Ripley's statistics:\n`'F'`, `'G'` or `'L'` statistics.\n\n`'F'`, `'G'` are defined as:\n\n.. math::\n\n    F(t),G(t)=P( d_{i,j} \\le t )\n\nWhere :math:`d_{i,j}` represents:\n\n    - distances to a random Spatial Poisson Point Process for `'F'`.\n    - distances to any other point of the dataset for `'G'`.\n\n`'L'` we first need to compute :math:`K(t)`, which is defined as:\n\n.. math::\n\n    K(t) = \\frac{1}{\\lambda} \\sum_{i \\ne j} \\frac{I(d_{i,j}<t)}{n}\n\n\nand then we apply a variance-stabilizing transformation:\n\n.. math::\n\n    L(t) = (\\frac{K(t)}{\\pi})^{1/2}\n\n\nParameters\n----------\nadata\n    Annotated data object.\ncluster_key\n    Key in :attr:`anndata.AnnData.obs` where clustering is stored.\nmode\n    Which Ripley's statistic to compute.\nspatial_key\n    Key in :attr:`anndata.AnnData.obsm` where spatial coordinates are stored.\nmetric\n    Which metric to use for computing distances.\n    For available metrics, check out :class:`sklearn.neighbors.DistanceMetric`.\nn_neigh\n    Number of neighbors to consider for the KNN graph.\nn_simulations\n    How many simulations to run for computing p-values.\nn_observations\n    How many observations to generate for the Spatial Poisson Point Process.\nmax_dist\n    Maximum distances for the support. If `None`, `max_dist=`:math:`\\sqrt{area \\over 2}`.\nn_steps\n    Number of steps for the support.\nseed\n    Random seed for reproducibility.\ncopy\n    If ``True``, return the result, otherwise save it to the ``adata`` object.\n\nReturns\n-------\nIf ``copy = True``, returns a :class:`dict` with following keys:\n\n    - `'{mode}_stat'` - :class:`pandas.DataFrame` containing the statistics of choice for the real observations.\n    - `'sims_stat'` - :class:`pandas.DataFrame` containing the statistics of choice for the simulations.\n    - `'bins'` - :class:`numpy.ndarray` containing the support.\n    - `'pvalues'` - :class:`numpy.ndarray` containing the p-values for the statistics of interest.\n\nOtherwise, modifies the ``adata`` object with the following key:\n\n    - :attr:`anndata.AnnData.uns` ``['{key_added}']`` - the above mentioned :class:`dict`.\n\nStatistics and p-values are computed for each cluster :attr:`anndata.AnnData.obs` ``['{cluster_key}']`` separately.\n\nReferences\n----------\nFor reference, check out\n`Wikipedia <https://en.wikipedia.org/wiki/Spatial_descriptive_statistics#Ripley's_K_and_L_functions>`_\nor :cite:`Baddeley2015-lm`.",
        "description": "Calculate various Ripley's statistics for point processes.According to the `'mode'` argument, it calculates one of the following Ripley's statistics:\n`'F'`, `'G'` or `'L'` statistics.\n\n`'F'`, `'G'` are defined as:\n\n.. math::\n\n    F(t),G(t)=P( d_{i,j} \\le t )\n\nWhere :math:`d_{i,j}` represents:\n\n    - distances to a random Spatial Poisson Point Process for `'F'`.\n    - distances to any other point of the dataset for `'G'`.\n\n`'L'` we first need to compute :math:`K(t)`, which is defined as:\n\n.. math::\n\n    K(t) = \\frac{1}{\\lambda} \\sum_{i \\ne j} \\frac{I(d_{i,j}<t)}{n}\n\n\nand then we apply a variance-stabilizing transformation:\n\n.. math::\n\n    L(t) = (\\frac{K(t)}{\\pi})^{1/2}",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "squidpy.gr.ripley(adata=$, cluster_key=@, mode=$, spatial_key=@, metric=@, n_neigh=@, n_simulations=@, n_observations=@, max_dist=@, n_steps=@, seed=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "squidpy.datasets.visium_fluo_adata": {
        "Parameters": {
            "path": {
                "type": "Union[PathLike, str]",
                "default": "None",
                "optional": true,
                "description": "Path where to save the dataset.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": "The dataset."
        },
        "Docstring": "Pre-processed `10x Genomics Visium Fluorecent dataset <https://support.10xgenomics.com/spatial-gene-expression/datasets/1.1.0/V1_Adult_Mouse_Brain_Coronal_Section_2>`__.\n\nThe shape of this :class:`anndata.AnnData` object ``(2800, 16562)``.\n\nParameters\n----------\npath\n    Path where to save the dataset.\nkwargs\n    Keyword arguments for :func:`scanpy.read`.\n\nReturns\n-------\nThe dataset.",
        "description": "Pre-processed `10x Genomics Visium Fluorecent dataset <https://support.10xgenomics.com/spatial-gene-expression/datasets/1.1.0/V1_Adult_Mouse_Brain_Coronal_Section_2>`__.The shape of this :class:`anndata.AnnData` object ``(2800, 16562)``.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "squidpy.datasets.visium_fluo_adata(path=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "squidpy.tl.var_by_distance": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data object.",
                "optional_value": true
            },
            "groups": {
                "type": "Union[str, list[str], ndarray[Any, dtype[Any]]]",
                "default": null,
                "optional": false,
                "description": "Anchor points to calculate distances from, can be a single gene,\na list of genes or a set of coordinates.",
                "optional_value": false
            },
            "cluster_key": {
                "type": "str",
                "default": null,
                "optional": false,
                "description": "Annotation column in `.obs` that is used as anchor.",
                "optional_value": false
            },
            "library_key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "If multiple `library_id`, column in :attr:`anndata.AnnData.obs`\nwhich stores mapping between ``library_id`` and obs.",
                "optional_value": false
            },
            "design_matrix_key": {
                "type": "str",
                "default": "design_matrix",
                "optional": true,
                "description": "Name of the design matrix saved to `.obsm`.",
                "optional_value": false
            },
            "covariates": {
                "type": "Optional[Union[str, list[str]]]",
                "default": "None",
                "optional": true,
                "description": "Additional covariates from `.obs` to include in the design matrix.",
                "optional_value": false
            },
            "metric": {
                "type": "str",
                "default": "euclidean",
                "optional": true,
                "description": "Distance metric, defaults to \"euclidean\".",
                "optional_value": false
            },
            "spatial_key": {
                "type": "str",
                "default": "spatial",
                "optional": true,
                "description": "Key in :attr:`anndata.AnnData.obsm` where spatial coordinates are stored.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If ``True``, return the result, otherwise save it to the ``adata`` object.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": "If ``copy = True``, returns the design_matrix with the distances to an anchor point\nOtherwise, stores design_matrix in .obsm"
        },
        "Docstring": "Build a design matrix consisting of distance measurements to selected anchor point(s) for each observation.\n\nParameters\n----------\nadata\n    Annotated data object.\ngroups\n    Anchor points to calculate distances from, can be a single gene,\n    a list of genes or a set of coordinates.\ncluster_key\n    Annotation column in `.obs` that is used as anchor.\nlibrary_key\n    If multiple `library_id`, column in :attr:`anndata.AnnData.obs`\n    which stores mapping between ``library_id`` and obs.\ndesign_matrix_key\n    Name of the design matrix saved to `.obsm`.\ncovariates\n    Additional covariates from `.obs` to include in the design matrix.\nmetric\n    Distance metric, defaults to \"euclidean\".\nspatial_key\n    Key in :attr:`anndata.AnnData.obsm` where spatial coordinates are stored.\ncopy\n    If ``True``, return the result, otherwise save it to the ``adata`` object.\n\nReturns\n-------\nIf ``copy = True``, returns the design_matrix with the distances to an anchor point\nOtherwise, stores design_matrix in .obsm",
        "description": "Build a design matrix consisting of distance measurements to selected anchor point(s) for each observation.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "squidpy.tl.var_by_distance(adata=$, groups=@, cluster_key=@, library_key=@, design_matrix_key=@, covariates=@, metric=@, spatial_key=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "squidpy.datasets.visium_hne_adata": {
        "Parameters": {
            "path": {
                "type": "Union[PathLike, str]",
                "default": "None",
                "optional": true,
                "description": "Path where to save the dataset.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": "The dataset."
        },
        "Docstring": "Pre-processed `10x Genomics Visium H&E dataset <https://support.10xgenomics.com/spatial-gene-expression/datasets/1.1.0/V1_Adult_Mouse_Brain>`__.\n\nThe shape of this :class:`anndata.AnnData` object ``(2688, 18078)``.\n\nParameters\n----------\npath\n    Path where to save the dataset.\nkwargs\n    Keyword arguments for :func:`scanpy.read`.\n\nReturns\n-------\nThe dataset.",
        "description": "Pre-processed `10x Genomics Visium H&E dataset <https://support.10xgenomics.com/spatial-gene-expression/datasets/1.1.0/V1_Adult_Mouse_Brain>`__.The shape of this :class:`anndata.AnnData` object ``(2688, 18078)``.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "squidpy.datasets.visium_hne_adata(path=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "squidpy.pl.spatial_segment": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data object.",
                "optional_value": true
            },
            "color": {
                "type": "Optional[Union[str, Sequence[str, None]]]",
                "default": "None",
                "optional": true,
                "description": "Key for annotations in :attr:`anndata.AnnData.obs` or variables/genes.",
                "optional_value": false
            },
            "groups": {
                "type": "Optional[_SeqStr]",
                "default": "None",
                "optional": true,
                "description": "For discrete annotation in ``color``, select which values to plot (other values are set to NAs).",
                "optional_value": true
            },
            "library_id": {
                "type": "Optional[_SeqStr]",
                "default": "None",
                "optional": true,
                "description": "Name of the Z-dimension(s) that this function should be applied to.\nFor not specified Z-dimensions, the identity function is applied.",
                "optional_value": true
            },
            "library_key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "If multiple `library_id`, column in :attr:`anndata.AnnData.obs`\nwhich stores mapping between ``library_id`` and obs.",
                "optional_value": false
            },
            "spatial_key": {
                "type": "str",
                "default": "spatial",
                "optional": true,
                "description": "Key in :attr:`anndata.AnnData.obsm` where spatial coordinates are stored.",
                "optional_value": false
            },
            "img": {
                "type": "Optional[Union[bool, _SeqArray]]",
                "default": "True",
                "optional": true,
                "description": "Whether to plot the image. One (or more) :class:`numpy.ndarray` can also be\npassed for plotting.",
                "optional_value": false
            },
            "img_res_key": {
                "type": "Optional[str]",
                "default": "hires",
                "optional": true,
                "description": "Key for image resolution, used to get ``img`` and ``scale_factor`` from ``'images'``\nand ``'scalefactors'`` entries for this library.",
                "optional_value": false
            },
            "img_alpha": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Alpha value for the underlying image.",
                "optional_value": false
            },
            "img_cmap": {
                "type": "Optional[Union[Colormap, str]]",
                "default": "None",
                "optional": true,
                "description": "",
                "optional_value": false
            },
            "img_channel": {
                "type": "Optional[Union[int, list[int]]]",
                "default": "None",
                "optional": true,
                "description": "To select which channel to plot (all by default).",
                "optional_value": false
            },
            "seg": {
                "type": "Optional[Union[bool, _SeqArray]]",
                "default": "None",
                "optional": true,
                "description": "Whether to plot the segmentation mask. One (or more) :class:`numpy.ndarray` can also be\npassed for plotting.",
                "optional_value": false
            },
            "seg_key": {
                "type": "Optional[str]",
                "default": "segmentation",
                "optional": true,
                "description": "Key of segmentation mask in :attr:`anndata.AnnData.uns`.",
                "optional_value": false
            },
            "seg_cell_id": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Column in :attr:`anndata.AnnData.obs` with unique segmentation mask ids. Required to filter\nvalid segmentation masks.",
                "optional_value": false
            },
            "seg_contourpx": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Draw contour of specified width for each segment. If `None`, fills\nentire segment, see :func:`skimage.morphology.erosion`.",
                "optional_value": false
            },
            "seg_outline": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to plot boundaries around segmentation masks.",
                "optional_value": false
            },
            "use_raw": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "If True, use :attr:`anndata.AnnData.raw`.",
                "optional_value": false
            },
            "layer": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Key in :attr:`anndata.AnnData.layers` or `None` for :attr:`anndata.AnnData.X`.",
                "optional_value": false
            },
            "alt_var": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Which column to use in :attr:`anndata.AnnData.var` to select alternative ``var_name``.",
                "optional_value": false
            },
            "crop_coord": {
                "type": "Optional[Union[_CoordTuple, Sequence[_CoordTuple]]]",
                "default": "None",
                "optional": true,
                "description": "Coordinates to use for cropping the image (left, right, top, bottom).\nThese coordinates are expected to be in pixel space (same as ``spatial``)\nand will be transformed by ``scale_factor``.\nIf not provided, image is automatically cropped to bounds of ``spatial``,\nplus a border.",
                "optional_value": true
            },
            "cmap": {
                "type": "Optional[Union[str, Colormap]]",
                "default": "None",
                "optional": true,
                "description": "Colormap for continuous annotations, see :class:`matplotlib.colors.Colormap`.",
                "optional_value": false
            },
            "palette": {
                "type": "Palette_t",
                "default": "None",
                "optional": true,
                "description": "Palette for discrete annotations, see :class:`matplotlib.colors.Colormap`.",
                "optional_value": true
            },
            "alpha": {
                "type": "float",
                "default": "1.0",
                "optional": true,
                "description": "Alpha value for scatter point/shape.",
                "optional_value": false
            },
            "norm": {
                "type": "Optional[_Normalize]",
                "default": "None",
                "optional": true,
                "description": "Colormap normalization for continuous annotations, see :class:`matplotlib.colors.Normalize`.",
                "optional_value": true
            },
            "na_color": {
                "type": "Union[str, tuple[float, ...]]",
                "default": "(0, 0, 0, 0)",
                "optional": true,
                "description": "Color to be used for NAs values, if present.",
                "optional_value": false
            },
            "connectivity_key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Key for neighbors graph to plot. Default is: :attr:`anndata.AnnData.obsp` ``['spatial_connectivities']``.",
                "optional_value": false
            },
            "edges_width": {
                "type": "float",
                "default": "1.0",
                "optional": true,
                "description": "Width of the edges. Only used when ``connectivity_key != None`` .",
                "optional_value": false
            },
            "edges_color": {
                "type": "Union[str, Sequence[str], Sequence[float]]",
                "default": "grey",
                "optional": true,
                "description": "Color of the edges.",
                "optional_value": false
            },
            "library_first": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "If multiple libraries are plotted, set the plotting order with respect to ``color``.",
                "optional_value": false
            },
            "frameon": {
                "type": "Optional[bool]",
                "default": "None",
                "optional": true,
                "description": "If `True`, draw a frame around the panels.",
                "optional_value": false
            },
            "wspace": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Width space between panels.",
                "optional_value": false
            },
            "hspace": {
                "type": "float",
                "default": "0.25",
                "optional": true,
                "description": "Height space between panels.",
                "optional_value": false
            },
            "ncols": {
                "type": "int",
                "default": "4",
                "optional": true,
                "description": "Number of panels per row.",
                "optional_value": false
            },
            "outline": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If `True`, a thin border around points/shapes is plotted.",
                "optional_value": false
            },
            "outline_color": {
                "type": "tuple[str, str]",
                "default": "('black', 'white')",
                "optional": true,
                "description": "Color of the border.",
                "optional_value": false
            },
            "outline_width": {
                "type": "tuple[float, float]",
                "default": "(0.3, 0.05)",
                "optional": true,
                "description": "Width of the border.",
                "optional_value": false
            },
            "legend_loc": {
                "type": "Optional[str]",
                "default": "right margin",
                "optional": true,
                "description": "Location of the legend, see :class:`matplotlib.legend.Legend`.",
                "optional_value": false
            },
            "legend_fontsize": {
                "type": "Optional[Union[int, float, _FontSize]]",
                "default": "None",
                "optional": true,
                "description": "Font size of the legend, see :meth:`matplotlib.text.Text.set_fontsize`.",
                "optional_value": false
            },
            "legend_fontweight": {
                "type": "Union[int, _FontWeight]",
                "default": "bold",
                "optional": true,
                "description": "Font weight of the legend, see :meth:`matplotlib.text.Text.set_fontweight`.",
                "optional_value": false
            },
            "legend_fontoutline": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Font outline of the legend, see :class:`matplotlib.patheffects.withStroke`.",
                "optional_value": false
            },
            "legend_na": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to show NA values in the legend.",
                "optional_value": false
            },
            "colorbar": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to show the colorbar, see :func:`matplotlib.pyplot.colorbar`.",
                "optional_value": false
            },
            "scalebar_dx": {
                "type": "Optional[_SeqFloat]",
                "default": "None",
                "optional": true,
                "description": "Size of one pixel in units specified by ``scalebar_units``.",
                "optional_value": true
            },
            "scalebar_units": {
                "type": "Optional[_SeqStr]",
                "default": "None",
                "optional": true,
                "description": "Units of ``scalebar_dx``.",
                "optional_value": true
            },
            "title": {
                "type": "Optional[_SeqStr]",
                "default": "None",
                "optional": true,
                "description": "Panel titles.",
                "optional_value": true
            },
            "axis_label": {
                "type": "Optional[_SeqStr]",
                "default": "None",
                "optional": true,
                "description": "Panel axis labels.",
                "optional_value": true
            },
            "fig": {
                "type": "Optional[Figure]",
                "default": "None",
                "optional": true,
                "description": "Optional :class:`matplotlib.figure.Figure` to use.",
                "optional_value": true
            },
            "ax": {
                "type": "Optional[Union[Axes, Sequence[Axes]]]",
                "default": "None",
                "optional": true,
                "description": "Optional :class:`matplotlib.axes.Axes` to use.",
                "optional_value": true
            },
            "return_ax": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to return :class:`matplotlib.axes.Axes` object(s).",
                "optional_value": false
            },
            "figsize": {
                "type": "Optional[tuple[float, float]]",
                "default": "None",
                "optional": true,
                "description": "Size of the figure in inches.",
                "optional_value": false
            },
            "dpi": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Dots per inch.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[str, Path]]",
                "default": "None",
                "optional": true,
                "description": "Whether to save the plot.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[Union[Axes, Sequence[Axes]]]",
            "description": "Nothing, just plots the figure and optionally saves the plot."
        },
        "Docstring": "Plot spatial omics data with segmentation masks on top.\n\nArgument ``seg_cell_id`` in :attr:`anndata.AnnData.obs` controls unique segmentation mask's ids to be plotted.\nBy default, ``'segmentation'``, ``seg_key`` for the segmentation and ``'hires'`` for the image is attempted.\n\n    - Use ``seg_key`` to display the image in the background.\n    - Use ``seg_contourpx`` or ``seg_outline`` to control how the segmentation mask is displayed.\n\nUse ``library_id`` to select the image. If multiple ``library_id`` are available, use ``library_key`` in\n:attr:`anndata.AnnData.obs` to plot the subsets.\nUse ``crop_coord`` to crop the spatial plot based on coordinate boundaries.\n\nThis function has few key assumptions about how coordinates and libraries are handled:\n\n    - The arguments ``library_key`` and ``library_id`` control which dataset is plotted.\n      If multiple libraries are present, specifying solely ``library_key`` will suffice, and all unique libraries\n      will be plotted sequentially. To select specific libraries, use the ``library_id`` argument.\n    - The argument ``color`` controls which features in obs/var are plotted. They are plotted for all\n      available/specified libraries. The argument ``groups`` can be used to select categories to be plotted.\n      This is valid only for categorical features in :attr:`anndata.AnnData.obs`.\n    - If multiple ``library_id`` are available, arguments such as ``size`` and ``crop_coord`` accept lists to\n      selectively customize different ``library_id`` plots. This requires that the length of such lists matches\n      the number of unique libraries in the dataset.\n    - Coordinates are in the pixel space of the source image, so an equal aspect ratio is assumed.\n    - The origin *(0, 0)* is on the top left, as is common convention with image data.\n    - The plotted points (dots) do not have a real \"size\" but it is relative to their coordinate/pixel space.\n      This does not hold if no image is plotted, then the size corresponds to points size passed to\n      :meth:`matplotlib.axes.Axes.scatter`.\n\nIf :attr:`anndata.AnnData.uns` ``['spatial']`` is present, use ``img_key``, ``seg_key`` and\n``size_key`` arguments to find values for ``img``, ``seg`` and ``size``.\nAlternatively, these values can be passed directly via ``img``.\n\n.. seealso::\n    - :func:`squidpy.pl.spatial_scatter` on how to plot spatial data with overlayed data on top.\n\nParameters\n----------\nadata\n    Annotated data object.\nseg_cell_id\n    Column in :attr:`anndata.AnnData.obs` with unique segmentation mask ids. Required to filter\n    valid segmentation masks.\nseg\n    Whether to plot the segmentation mask. One (or more) :class:`numpy.ndarray` can also be\n    passed for plotting.\nseg_key\n    Key of segmentation mask in :attr:`anndata.AnnData.uns`.\nseg_contourpx\n    Draw contour of specified width for each segment. If `None`, fills\n    entire segment, see :func:`skimage.morphology.erosion`.\nseg_outline\n    Whether to plot boundaries around segmentation masks.\ncolor\n    Key for annotations in :attr:`anndata.AnnData.obs` or variables/genes.\ngroups\n    For discrete annotation in ``color``, select which values to plot (other values are set to NAs).\nlibrary_id\n    Name of the Z-dimension(s) that this function should be applied to.\n    For not specified Z-dimensions, the identity function is applied.\nlibrary_key\n    If multiple `library_id`, column in :attr:`anndata.AnnData.obs`\n    which stores mapping between ``library_id`` and obs.\nspatial_key\n    Key in :attr:`anndata.AnnData.obsm` where spatial coordinates are stored.\nimg\n    Whether to plot the image. One (or more) :class:`numpy.ndarray` can also be\n    passed for plotting.\nimg_res_key\n    Key for image resolution, used to get ``img`` and ``scale_factor`` from ``'images'``\n    and ``'scalefactors'`` entries for this library.\nimg_alpha\n    Alpha value for the underlying image.\nimage_cmap\n    Colormap for the image, see :class:`matplotlib.colors.Colormap`.\nimg_channel\n    To select which channel to plot (all by default).\nuse_raw\n    If True, use :attr:`anndata.AnnData.raw`.\nlayer\n    Key in :attr:`anndata.AnnData.layers` or `None` for :attr:`anndata.AnnData.X`.\nalt_var\n    Which column to use in :attr:`anndata.AnnData.var` to select alternative ``var_name``.\nsize\n    Size of the scatter point/shape. In case of ``spatial_shape`` it represents to the\n    scaling factor for shape (accessed via ``size_key``). In case of ``spatial_point``,\n    it represents the ``size`` argument in :func:`matplotlib.pyplot.scatter`.\nsize_key\n    Key of of pixel size of shapes to be plotted, stored in :attr:`anndata.AnnData.uns`.\n    Only needed for ``spatial_shape``.\nscale_factor\n    Scaling factor used to map from coordinate space to pixel space.\n    Found by default if ``library_id`` and ``img_key`` can be resolved.\n    Otherwise, defaults to `1`.\ncrop_coord\n    Coordinates to use for cropping the image (left, right, top, bottom).\n    These coordinates are expected to be in pixel space (same as ``spatial``)\n    and will be transformed by ``scale_factor``.\n    If not provided, image is automatically cropped to bounds of ``spatial``,\n    plus a border.\ncmap\n    Colormap for continuous annotations, see :class:`matplotlib.colors.Colormap`.\npalette\n    Palette for discrete annotations, see :class:`matplotlib.colors.Colormap`.\nalpha\n    Alpha value for scatter point/shape.\nnorm\n    Colormap normalization for continuous annotations, see :class:`matplotlib.colors.Normalize`.\nna_color\n    Color to be used for NAs values, if present.\nconnectivity_key\n    Key for neighbors graph to plot. Default is: :attr:`anndata.AnnData.obsp` ``['spatial_connectivities']``.\nedges_width\n    Width of the edges. Only used when ``connectivity_key != None`` .\nedges_color\n    Color of the edges.\nlibrary_first\n    If multiple libraries are plotted, set the plotting order with respect to ``color``.\nframeon\n    If `True`, draw a frame around the panels.\nwspace\n    Width space between panels.\nhspace\n    Height space between panels.\nncols\n    Number of panels per row.\noutline\n    If `True`, a thin border around points/shapes is plotted.\noutline_color\n    Color of the border.\noutline_width\n    Width of the border.\nlegend_loc\n    Location of the legend, see :class:`matplotlib.legend.Legend`.\nlegend_fontsize\n    Font size of the legend, see :meth:`matplotlib.text.Text.set_fontsize`.\nlegend_fontweight\n    Font weight of the legend, see :meth:`matplotlib.text.Text.set_fontweight`.\nlegend_fontoutline\n    Font outline of the legend, see :class:`matplotlib.patheffects.withStroke`.\nlegend_na\n    Whether to show NA values in the legend.\ncolorbar\n    Whether to show the colorbar, see :func:`matplotlib.pyplot.colorbar`.\nscalebar_dx\n    Size of one pixel in units specified by ``scalebar_units``.\nscalebar_units\n    Units of ``scalebar_dx``.\ntitle\n    Panel titles.\naxis_label\n    Panel axis labels.\nfig\n    Optional :class:`matplotlib.figure.Figure` to use.\nax\n    Optional :class:`matplotlib.axes.Axes` to use.\nreturn_ax\n    Whether to return :class:`matplotlib.axes.Axes` object(s).\nfigsize\n    Size of the figure in inches.\ndpi\n    Dots per inch.\nsave\n    Whether to save the plot.\nscalebar_kwargs\n    Keyword arguments for :meth:`matplotlib_scalebar.ScaleBar`.\nedges_kwargs\n    Keyword arguments for :func:`networkx.draw_networkx_edges`.\nkwargs\n    Keyword arguments for :func:`matplotlib.pyplot.scatter` or :func:`matplotlib.pyplot.imshow`.\n\n\nReturns\n-------\nNothing, just plots the figure and optionally saves the plot.",
        "description": "Plot spatial omics data with segmentation masks on top.Argument ``seg_cell_id`` in :attr:`anndata.AnnData.obs` controls unique segmentation mask's ids to be plotted.\nBy default, ``'segmentation'``, ``seg_key`` for the segmentation and ``'hires'`` for the image is attempted.\n\n    - Use ``seg_key`` to display the image in the background.\n    - Use ``seg_contourpx`` or ``seg_outline`` to control how the segmentation mask is displayed.\n\nUse ``library_id`` to select the image. If multiple ``library_id`` are available, use ``library_key`` in\n:attr:`anndata.AnnData.obs` to plot the subsets.\nUse ``crop_coord`` to crop the spatial plot based on coordinate boundaries.\n\nThis function has few key assumptions about how coordinates and libraries are handled:\n\n    - The arguments ``library_key`` and ``library_id`` control which dataset is plotted.\n      If multiple libraries are present, specifying solely ``library_key`` will suffice, and all unique libraries\n      will be plotted sequentially. To select specific libraries, use the ``library_id`` argument.\n    - The argument ``color`` controls which features in obs/var are plotted. They are plotted for all\n      available/specified libraries. The argument ``groups`` can be used to select categories to be plotted.\n      This is valid only for categorical features in :attr:`anndata.AnnData.obs`.\n    - If multiple ``library_id`` are available, arguments such as ``size`` and ``crop_coord`` accept lists to\n      selectively customize different ``library_id`` plots. This requires that the length of such lists matches\n      the number of unique libraries in the dataset.\n    - Coordinates are in the pixel space of the source image, so an equal aspect ratio is assumed.\n    - The origin *(0, 0)* is on the top left, as is common convention with image data.\n    - The plotted points (dots) do not have a real \"size\" but it is relative to their coordinate/pixel space.\n      This does not hold if no image is plotted, then the size corresponds to points size passed to\n      :meth:`matplotlib.axes.Axes.scatter`.\n\nIf :attr:`anndata.AnnData.uns` ``['spatial']`` is present, use ``img_key``, ``seg_key`` and\n``size_key`` arguments to find values for ``img``, ``seg`` and ``size``.\nAlternatively, these values can be passed directly via ``img``.\n\n.. seealso::\n    - :func:`squidpy.pl.spatial_scatter` on how to plot spatial data with overlayed data on top.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "squidpy.pl.spatial_segment(adata=$, color=@, groups=$, library_id=$, library_key=@, spatial_key=@, img=@, img_res_key=@, img_alpha=@, img_cmap=@, img_channel=@, seg=@, seg_key=@, seg_cell_id=@, seg_contourpx=@, seg_outline=@, use_raw=@, layer=@, alt_var=@, crop_coord=$, cmap=@, palette=$, alpha=@, norm=$, na_color=@, connectivity_key=@, edges_width=@, edges_color=@, library_first=@, frameon=@, wspace=@, hspace=@, ncols=@, outline=@, outline_color=@, outline_width=@, legend_loc=@, legend_fontsize=@, legend_fontweight=@, legend_fontoutline=@, legend_na=@, colorbar=@, scalebar_dx=$, scalebar_units=$, title=$, axis_label=$, fig=$, ax=$, return_ax=@, figsize=@, dpi=@, save=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "squidpy.gr.spatial_autocorr": {
        "Parameters": {
            "adata": {
                "type": "Union[AnnData, SpatialData]",
                "default": null,
                "optional": false,
                "description": "Annotated data object.",
                "optional_value": true
            },
            "connectivity_key": {
                "type": "str",
                "default": "spatial_connectivities",
                "optional": true,
                "description": "Key in :attr:`anndata.AnnData.obsp` where spatial connectivities are stored.\nDefault is: :attr:`anndata.AnnData.obsp` ``['spatial_connectivities']``.",
                "optional_value": false
            },
            "genes": {
                "type": "Optional[Union[str, int, Sequence[str], Sequence[int]]]",
                "default": "None",
                "optional": true,
                "description": "Depending on the ``attr``:\n\n    - if ``attr = 'X'``, it corresponds to genes stored in :attr:`anndata.AnnData.var_names`.\n      If `None`, it's computed :attr:`anndata.AnnData.var` ``['highly_variable']``,\n      if present. Otherwise, it's computed for all genes.\n    - if ``attr = 'obs'``, it corresponds to a list of columns in :attr:`anndata.AnnData.obs`.\n      If `None`, use all numerical columns.\n    - if ``attr = 'obsm'``, it corresponds to indices in :attr:`anndata.AnnData.obsm` ``['{layer}']``.\n      If `None`, all indices are used.",
                "optional_value": false
            },
            "mode": {
                "type": "Literal['moran', 'geary']",
                "default": "moran",
                "optional": true,
                "description": "Mode of score calculation:\n\n    - `'moran'` - `Moran's I autocorrelation <https://en.wikipedia.org/wiki/Moran%27s_I>`_.\n    - `'geary'` - `Geary's C autocorrelation <https://en.wikipedia.org/wiki/Geary%27s_C>`_.",
                "optional_value": true
            },
            "transformation": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "If `True`, weights in :attr:`anndata.AnnData.obsp` ``['spatial_connectivities']`` are row-normalized,\nadvised for analytic p-value calculation.",
                "optional_value": false
            },
            "n_perms": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Number of permutations for the permutation test.\nIf `None`, only p-values under normality assumption are computed.",
                "optional_value": false
            },
            "two_tailed": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If `True`, p-values are two-tailed, otherwise they are one-tailed.",
                "optional_value": false
            },
            "corr_method": {
                "type": "Optional[str]",
                "default": "fdr_bh",
                "optional": true,
                "description": "Correction method for multiple testing. See :func:`statsmodels.stats.multitest.multipletests`\nfor valid options.",
                "optional_value": false
            },
            "attr": {
                "type": "Literal['obs', 'X', 'obsm']",
                "default": "X",
                "optional": true,
                "description": "Which attribute of :class:`~anndata.AnnData` to access. See ``genes`` parameter for more information.",
                "optional_value": true
            },
            "layer": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Depending on ``attr``:\nLayer in :attr:`anndata.AnnData.layers` to use. If `None`, use :attr:`anndata.AnnData.X`.",
                "optional_value": false
            },
            "seed": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Random seed for reproducibility.",
                "optional_value": false
            },
            "use_raw": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to access :attr:`anndata.AnnData.raw`. Only used when ``attr = 'X'``.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If ``True``, return the result, otherwise save it to the ``adata`` object.",
                "optional_value": false
            },
            "n_jobs": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Number of parallel jobs.",
                "optional_value": false
            },
            "backend": {
                "type": "str",
                "default": "loky",
                "optional": true,
                "description": "Parallelization backend to use. See :class:`joblib.Parallel` for available options.",
                "optional_value": false
            },
            "show_progress_bar": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to show the progress bar or not.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[pd.DataFrame]",
            "description": "If ``copy = True``, returns a :class:`pandas.DataFrame` with the following keys:\n- `'I' or 'C'` - Moran's I or Geary's C statistic.\n- `'pval_norm'` - p-value under normality assumption.\n- `'var_norm'` - variance of `'score'` under normality assumption.\n- `'{p_val}_{corr_method}'` - the corrected p-values if ``corr_method != None`` .\nIf ``n_perms != None``, additionally returns the following columns:\n- `'pval_z_sim'` - p-value based on standard normal approximation from permutations.\n- `'pval_sim'` - p-value based on permutations.\n- `'var_sim'` - variance of `'score'` from permutations.\nOtherwise, modifies the ``adata`` with the following key:\n- :attr:`anndata.AnnData.uns` ``['moranI']`` - the above mentioned dataframe, if ``mode = 'moran'``.\n- :attr:`anndata.AnnData.uns` ``['gearyC']`` - the above mentioned dataframe, if ``mode = 'geary'``."
        },
        "Docstring": "Calculate Global Autocorrelation Statistic (Moran\u2019s I  or Geary's C).\n\nSee :cite:`pysal` for reference.\n\nParameters\n----------\nadata\n    Annotated data object.\nconnectivity_key\n    Key in :attr:`anndata.AnnData.obsp` where spatial connectivities are stored.\n    Default is: :attr:`anndata.AnnData.obsp` ``['spatial_connectivities']``.\ngenes\n    Depending on the ``attr``:\n\n        - if ``attr = 'X'``, it corresponds to genes stored in :attr:`anndata.AnnData.var_names`.\n          If `None`, it's computed :attr:`anndata.AnnData.var` ``['highly_variable']``,\n          if present. Otherwise, it's computed for all genes.\n        - if ``attr = 'obs'``, it corresponds to a list of columns in :attr:`anndata.AnnData.obs`.\n          If `None`, use all numerical columns.\n        - if ``attr = 'obsm'``, it corresponds to indices in :attr:`anndata.AnnData.obsm` ``['{layer}']``.\n          If `None`, all indices are used.\n\nmode\n    Mode of score calculation:\n\n        - `'moran'` - `Moran's I autocorrelation <https://en.wikipedia.org/wiki/Moran%27s_I>`_.\n        - `'geary'` - `Geary's C autocorrelation <https://en.wikipedia.org/wiki/Geary%27s_C>`_.\n\ntransformation\n    If `True`, weights in :attr:`anndata.AnnData.obsp` ``['spatial_connectivities']`` are row-normalized,\n    advised for analytic p-value calculation.\nn_perms\n    Number of permutations for the permutation test.\n    If `None`, only p-values under normality assumption are computed.\ntwo_tailed\n    If `True`, p-values are two-tailed, otherwise they are one-tailed.\ncorr_method\n    Correction method for multiple testing. See :func:`statsmodels.stats.multitest.multipletests`\n    for valid options.\nuse_raw\n    Whether to access :attr:`anndata.AnnData.raw`. Only used when ``attr = 'X'``.\nlayer\n    Depending on ``attr``:\n    Layer in :attr:`anndata.AnnData.layers` to use. If `None`, use :attr:`anndata.AnnData.X`.\nattr\n    Which attribute of :class:`~anndata.AnnData` to access. See ``genes`` parameter for more information.\nseed\n    Random seed for reproducibility.\ncopy\n    If ``True``, return the result, otherwise save it to the ``adata`` object.\nn_jobs\n    Number of parallel jobs.\nbackend\n    Parallelization backend to use. See :class:`joblib.Parallel` for available options.\nshow_progress_bar\n    Whether to show the progress bar or not.\n\nReturns\n-------\nIf ``copy = True``, returns a :class:`pandas.DataFrame` with the following keys:\n\n    - `'I' or 'C'` - Moran's I or Geary's C statistic.\n    - `'pval_norm'` - p-value under normality assumption.\n    - `'var_norm'` - variance of `'score'` under normality assumption.\n    - `'{p_val}_{corr_method}'` - the corrected p-values if ``corr_method != None`` .\n\nIf ``n_perms != None``, additionally returns the following columns:\n\n    - `'pval_z_sim'` - p-value based on standard normal approximation from permutations.\n    - `'pval_sim'` - p-value based on permutations.\n    - `'var_sim'` - variance of `'score'` from permutations.\n\nOtherwise, modifies the ``adata`` with the following key:\n\n    - :attr:`anndata.AnnData.uns` ``['moranI']`` - the above mentioned dataframe, if ``mode = 'moran'``.\n    - :attr:`anndata.AnnData.uns` ``['gearyC']`` - the above mentioned dataframe, if ``mode = 'geary'``.",
        "description": "Calculate Global Autocorrelation Statistic (Moran\u2019s I  or Geary's C).See :cite:`pysal` for reference.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "squidpy.gr.spatial_autocorr(adata=$, connectivity_key=@, genes=@, mode=$, transformation=@, n_perms=@, two_tailed=@, corr_method=@, attr=$, layer=@, seed=@, use_raw=@, copy=@, n_jobs=@, backend=@, show_progress_bar=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "squidpy.im.calculate_image_features": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data object.",
                "optional_value": true
            },
            "img": {
                "type": "ImageContainer",
                "default": null,
                "optional": false,
                "description": "High-resolution image.",
                "optional_value": true
            },
            "layer": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Image layer in ``img`` that should be processed. If `None` and only 1 layer is present, it will be selected.",
                "optional_value": false
            },
            "library_id": {
                "type": "Optional[Union[str, Sequence[str]]]",
                "default": "None",
                "optional": true,
                "description": "- If `None`, there should only exist one entry in :attr:`anndata.AnnData.uns` ``['{spatial_key}']``.\n- If a :class:`str`, first search :attr:`anndata.AnnData.obs` ``['{library_id}']`` which contains the mapping\n  from observations to library ids, then search :attr:`anndata.AnnData.uns` ``['{spatial_key}']``.",
                "optional_value": false
            },
            "features": {
                "type": "Union[str, Sequence[str]]",
                "default": "summary",
                "optional": true,
                "description": "Features to be calculated. Valid options are:\n\n- `'texture'` - summary stats based on repeating patterns\n  :meth:`squidpy.im.ImageContainer.features_texture`.\n- `'summary'` - summary stats of each image channel\n  :meth:`squidpy.im.ImageContainer.features_summary`.\n- `'histogram'` - counts in bins of image channel's histogram\n  :meth:`squidpy.im.ImageContainer.features_histogram`.\n- `'segmentation'` - stats of a cell segmentation mask\n  :meth:`squidpy.im.ImageContainer.features_segmentation`.\n- `'custom'` - extract features using a custom function\n  :meth:`squidpy.im.ImageContainer.features_custom`.",
                "optional_value": false
            },
            "key_added": {
                "type": "str",
                "default": "img_features",
                "optional": true,
                "description": "Key in :attr:`anndata.AnnData.obsm` where to store the calculated features.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If ``True``, return the result, otherwise save it to the ``adata`` object.",
                "optional_value": false
            },
            "n_jobs": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Number of parallel jobs.",
                "optional_value": false
            },
            "backend": {
                "type": "str",
                "default": "loky",
                "optional": true,
                "description": "Parallelization backend to use. See :class:`joblib.Parallel` for available options.",
                "optional_value": false
            },
            "show_progress_bar": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to show the progress bar or not.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[pd.DataFrame]",
            "description": "If ``copy = True``, returns a :class:`pandas.DataFrame` where columns correspond to the calculated features.\nOtherwise, modifies the ``adata`` object with the following key:\n- :attr:`anndata.AnnData.uns` ``['{key_added}']`` - the above mentioned dataframe.\nRaises\nValueError\nIf a feature is not known."
        },
        "Docstring": "Calculate image features for all observations in ``adata``.\n\nParameters\n----------\nadata\n    Annotated data object.\nimg\n    High-resolution image.\nlayer\n    Image layer in ``img`` that should be processed. If `None` and only 1 layer is present, it will be selected.\nlibrary_id\n    - If `None`, there should only exist one entry in :attr:`anndata.AnnData.uns` ``['{spatial_key}']``.\n    - If a :class:`str`, first search :attr:`anndata.AnnData.obs` ``['{library_id}']`` which contains the mapping\n      from observations to library ids, then search :attr:`anndata.AnnData.uns` ``['{spatial_key}']``.\nfeatures\n    Features to be calculated. Valid options are:\n\n    - `'texture'` - summary stats based on repeating patterns\n      :meth:`squidpy.im.ImageContainer.features_texture`.\n    - `'summary'` - summary stats of each image channel\n      :meth:`squidpy.im.ImageContainer.features_summary`.\n    - `'histogram'` - counts in bins of image channel's histogram\n      :meth:`squidpy.im.ImageContainer.features_histogram`.\n    - `'segmentation'` - stats of a cell segmentation mask\n      :meth:`squidpy.im.ImageContainer.features_segmentation`.\n    - `'custom'` - extract features using a custom function\n      :meth:`squidpy.im.ImageContainer.features_custom`.\n\nfeatures_kwargs\n    Keyword arguments for the different features that should be generated, such as\n    ``{ 'texture': { ... }, ... }``.\nkey_added\n    Key in :attr:`anndata.AnnData.obsm` where to store the calculated features.\ncopy\n    If ``True``, return the result, otherwise save it to the ``adata`` object.\nn_jobs\n    Number of parallel jobs.\nbackend\n    Parallelization backend to use. See :class:`joblib.Parallel` for available options.\nshow_progress_bar\n    Whether to show the progress bar or not.\nkwargs\n    Keyword arguments for :meth:`squidpy.im.ImageContainer.generate_spot_crops`.\n\nReturns\n-------\nIf ``copy = True``, returns a :class:`pandas.DataFrame` where columns correspond to the calculated features.\n\nOtherwise, modifies the ``adata`` object with the following key:\n\n    - :attr:`anndata.AnnData.uns` ``['{key_added}']`` - the above mentioned dataframe.\n\nRaises\n------\nValueError\n    If a feature is not known.",
        "description": "Calculate image features for all observations in ``adata``.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "squidpy.im.calculate_image_features(adata=$, img=$, layer=@, library_id=@, features=@, key_added=@, copy=@, n_jobs=@, backend=@, show_progress_bar=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "squidpy.im.process": {
        "Parameters": {
            "img": {
                "type": "ImageContainer",
                "default": null,
                "optional": false,
                "description": "High-resolution image.",
                "optional_value": true
            },
            "layer": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Image layer in ``img`` that should be processed. If `None` and only 1 layer is present, it will be selected.",
                "optional_value": false
            },
            "library_id": {
                "type": "Optional[Union[str, Sequence[str]]]",
                "default": "None",
                "optional": true,
                "description": "Name of the Z-dimension(s) that this function should be applied to.\nFor not specified Z-dimensions, the identity function is applied.\nIf `None`, all Z-dimensions are processed at once, treating the image as a 3D volume.",
                "optional_value": false
            },
            "method": {
                "type": "Union[str, Callable[..., ndarray[Any, dtype[Any]]]]",
                "default": "smooth",
                "optional": true,
                "description": "Processing method to use. Valid options are:\n\n    - `'smooth'` - :func:`skimage.filters.gaussian`.\n    - `'gray'` - :func:`skimage.color.rgb2gray`.\n\nAlternatively, any :func:`callable` can be passed as long as it has the following signature:\n:class:`numpy.ndarray` ``(height, width, channels)`` **->** :class:`numpy.ndarray` ``(height, width[, channels])``.",
                "optional_value": false
            },
            "chunks": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Number of chunks for :mod:`dask`. For automatic chunking, use ``chunks = 'auto'``.",
                "optional_value": false
            },
            "lazy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to lazily compute the result or not. Only used when ``chunks != None``.",
                "optional_value": false
            },
            "layer_added": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Layer of new image layer to add into ``img`` object.\nIf `None`, use ``'{layer}_{method}'``.",
                "optional_value": false
            },
            "channel_dim": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Name of the channel dimension of the new image layer. Default is the same as the original, if the\nprocessing function does not change the number of channels, and ``'{channel}_{processing}'`` otherwise.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If ``True``, return the result, otherwise save it to the image container.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[ImageContainer]",
            "description": "If ``copy = True``, returns a new container with the processed image in ``'{layer_added}'``.\nOtherwise, modifies the ``img`` with the following key:\n- :class:`squidpy.im.ImageContainer` ``['{layer_added}']`` - the processed image.\nRaises\nNotImplementedError\nIf ``method`` has not been implemented."
        },
        "Docstring": "Process an image by applying a transformation.\n\nParameters\n----------\nimg\n    High-resolution image.\nlayer\n    Image layer in ``img`` that should be processed. If `None` and only 1 layer is present, it will be selected.\nlibrary_id\n    Name of the Z-dimension(s) that this function should be applied to.\n    For not specified Z-dimensions, the identity function is applied.\n    If `None`, all Z-dimensions are processed at once, treating the image as a 3D volume.\nmethod\n    Processing method to use. Valid options are:\n\n        - `'smooth'` - :func:`skimage.filters.gaussian`.\n        - `'gray'` - :func:`skimage.color.rgb2gray`.\n\n    Alternatively, any :func:`callable` can be passed as long as it has the following signature:\n    :class:`numpy.ndarray` ``(height, width, channels)`` **->** :class:`numpy.ndarray` ``(height, width[, channels])``.\nchunks\n    Number of chunks for :mod:`dask`. For automatic chunking, use ``chunks = 'auto'``.\nlazy\n    Whether to lazily compute the result or not. Only used when ``chunks != None``.\nlayer_added\n    Layer of new image layer to add into ``img`` object.\n    If `None`, use ``'{layer}_{method}'``.\nchannel_dim\n    Name of the channel dimension of the new image layer. Default is the same as the original, if the\n    processing function does not change the number of channels, and ``'{channel}_{processing}'`` otherwise.\ncopy\n    If ``True``, return the result, otherwise save it to the image container.\napply_kwargs\n    Keyword arguments for :meth:`squidpy.im.ImageContainer.apply`.\nkwargs\n    Keyword arguments for ``method``.\n\nReturns\n-------\nIf ``copy = True``, returns a new container with the processed image in ``'{layer_added}'``.\n\nOtherwise, modifies the ``img`` with the following key:\n\n    - :class:`squidpy.im.ImageContainer` ``['{layer_added}']`` - the processed image.\n\nRaises\n------\nNotImplementedError\n    If ``method`` has not been implemented.",
        "description": "Process an image by applying a transformation.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "squidpy.im.process(img=$, layer=@, library_id=@, method=@, chunks=@, lazy=@, layer_added=@, channel_dim=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "squidpy.gr.interaction_matrix": {
        "Parameters": {
            "adata": {
                "type": "Union[AnnData, SpatialData]",
                "default": null,
                "optional": false,
                "description": "Annotated data object.",
                "optional_value": true
            },
            "cluster_key": {
                "type": "str",
                "default": null,
                "optional": false,
                "description": "Key in :attr:`anndata.AnnData.obs` where clustering is stored.",
                "optional_value": false
            },
            "connectivity_key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Key in :attr:`anndata.AnnData.obsp` where spatial connectivities are stored.\nDefault is: :attr:`anndata.AnnData.obsp` ``['spatial_connectivities']``.",
                "optional_value": false
            },
            "normalized": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If `True`, each row is normalized to sum to 1.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If ``True``, return the result, otherwise save it to the ``adata`` object.",
                "optional_value": false
            },
            "weights": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to use edge weights or binarize.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[ndarray[Any, dtype[Any]]]",
            "description": "If ``copy = True``, returns the interaction matrix.\nOtherwise, modifies the ``adata`` with the following key:\n- :attr:`anndata.AnnData.uns` ``['{cluster_key}_interactions']`` - the interaction matrix."
        },
        "Docstring": "Compute interaction matrix for clusters.\n\nParameters\n----------\nadata\n    Annotated data object.\ncluster_key\n    Key in :attr:`anndata.AnnData.obs` where clustering is stored.\nconnectivity_key\n    Key in :attr:`anndata.AnnData.obsp` where spatial connectivities are stored.\n    Default is: :attr:`anndata.AnnData.obsp` ``['spatial_connectivities']``.\nnormalized\n    If `True`, each row is normalized to sum to 1.\ncopy\n    If ``True``, return the result, otherwise save it to the ``adata`` object.\nweights\n    Whether to use edge weights or binarize.\n\nReturns\n-------\nIf ``copy = True``, returns the interaction matrix.\n\nOtherwise, modifies the ``adata`` with the following key:\n\n    - :attr:`anndata.AnnData.uns` ``['{cluster_key}_interactions']`` - the interaction matrix.",
        "description": "Compute interaction matrix for clusters.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "squidpy.gr.interaction_matrix(adata=$, cluster_key=@, connectivity_key=@, normalized=@, copy=@, weights=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "squidpy.pl.nhood_enrichment": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data object.",
                "optional_value": true
            },
            "cluster_key": {
                "type": "str",
                "default": null,
                "optional": false,
                "description": "Key in :attr:`anndata.AnnData.obs` where clustering is stored.",
                "optional_value": false
            },
            "mode": {
                "type": "Literal['zscore', 'count']",
                "default": "zscore",
                "optional": true,
                "description": "Which :func:`squidpy.gr.nhood_enrichment` result to plot. Valid options are:\n\n    - `'zscore'` - z-score values of enrichment statistic.\n    - `'count'` - enrichment count.",
                "optional_value": true
            },
            "annotate": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to annotate the cells of the heatmap.",
                "optional_value": false
            },
            "method": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "The linkage method to be used for dendrogram/clustering, see :func:`scipy.cluster.hierarchy.linkage`.",
                "optional_value": false
            },
            "title": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "The title of the plot.",
                "optional_value": false
            },
            "cmap": {
                "type": "str",
                "default": "viridis",
                "optional": true,
                "description": "Continuous colormap to use.",
                "optional_value": false
            },
            "palette": {
                "type": "Palette_t",
                "default": "None",
                "optional": true,
                "description": "Categorical colormap for the clusters.\nIf `None`, use :attr:`anndata.AnnData.uns` ``['{cluster_key}_colors']``, if available.",
                "optional_value": true
            },
            "figsize": {
                "type": "Optional[tuple[float, float]]",
                "default": "None",
                "optional": true,
                "description": "Size of the figure in inches.",
                "optional_value": false
            },
            "dpi": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Dots per inch.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[str, Path]]",
                "default": "None",
                "optional": true,
                "description": "Whether to save the plot.",
                "optional_value": false
            },
            "ax": {
                "type": "Optional[Axes]",
                "default": "None",
                "optional": true,
                "description": "Axes, :class:`matplotlib.axes.Axes`.",
                "optional_value": true
            }
        },
        "Returns": {
            "type": null,
            "description": "Nothing, just plots the figure and optionally saves the plot."
        },
        "Docstring": "Plot neighborhood enrichment.\n\nThe enrichment is computed by :func:`squidpy.gr.nhood_enrichment`.\n\nParameters\n----------\nadata\n    Annotated data object.\ncluster_key\n    Key in :attr:`anndata.AnnData.obs` where clustering is stored.\nmode\n    Which :func:`squidpy.gr.nhood_enrichment` result to plot. Valid options are:\n\n        - `'zscore'` - z-score values of enrichment statistic.\n        - `'count'` - enrichment count.\n\nannotate\n    Whether to annotate the cells of the heatmap.\nmethod\n    The linkage method to be used for dendrogram/clustering, see :func:`scipy.cluster.hierarchy.linkage`.\ntitle\n    The title of the plot.\ncmap\n    Continuous colormap to use.\ncbar_kwargs\n    Keyword arguments for :meth:`matplotlib.figure.Figure.colorbar`.\npalette\n    Categorical colormap for the clusters.\n    If `None`, use :attr:`anndata.AnnData.uns` ``['{cluster_key}_colors']``, if available.\nfigsize\n    Size of the figure in inches.\ndpi\n    Dots per inch.\nsave\n    Whether to save the plot.\nax\n    Axes, :class:`matplotlib.axes.Axes`.\nkwargs\n    Keyword arguments for :func:`matplotlib.pyplot.text`.\n\nReturns\n-------\nNothing, just plots the figure and optionally saves the plot.",
        "description": "Plot neighborhood enrichment.The enrichment is computed by :func:`squidpy.gr.nhood_enrichment`.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "squidpy.pl.nhood_enrichment(adata=$, cluster_key=@, mode=$, annotate=@, method=@, title=@, cmap=@, palette=$, figsize=@, dpi=@, save=@, ax=$)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "squidpy.datasets.slideseqv2": {
        "Parameters": {
            "path": {
                "type": "Union[PathLike, str]",
                "default": "None",
                "optional": true,
                "description": "Path where to save the dataset.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": "The dataset."
        },
        "Docstring": "Pre-processed SlideseqV2 dataset from `Stickles et al <https://doi.org/10.1038/s41587-020-0739-1>`__.\n\nThe shape of this :class:`anndata.AnnData` object ``(41786, 4000)``.\n\nParameters\n----------\npath\n    Path where to save the dataset.\nkwargs\n    Keyword arguments for :func:`scanpy.read`.\n\nReturns\n-------\nThe dataset.",
        "description": "Pre-processed SlideseqV2 dataset from `Stickles et al <https://doi.org/10.1038/s41587-020-0739-1>`__.The shape of this :class:`anndata.AnnData` object ``(41786, 4000)``.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "squidpy.datasets.slideseqv2(path=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "squidpy.gr.nhood_enrichment": {
        "Parameters": {
            "adata": {
                "type": "Union[AnnData, SpatialData]",
                "default": null,
                "optional": false,
                "description": "Annotated data object.",
                "optional_value": true
            },
            "cluster_key": {
                "type": "str",
                "default": null,
                "optional": false,
                "description": "Key in :attr:`anndata.AnnData.obs` where clustering is stored.",
                "optional_value": false
            },
            "connectivity_key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Key in :attr:`anndata.AnnData.obsp` where spatial connectivities are stored.\nDefault is: :attr:`anndata.AnnData.obsp` ``['spatial_connectivities']``.",
                "optional_value": false
            },
            "n_perms": {
                "type": "int",
                "default": "1000",
                "optional": true,
                "description": "Number of permutations for the permutation test.",
                "optional_value": false
            },
            "numba_parallel": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to use :class:`numba.prange` or not. If `None`, it is determined automatically.\nFor small datasets or small number of interactions, it's recommended to set this to `False`.",
                "optional_value": false
            },
            "seed": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Random seed for reproducibility.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If ``True``, return the result, otherwise save it to the ``adata`` object.",
                "optional_value": false
            },
            "n_jobs": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Number of parallel jobs.",
                "optional_value": false
            },
            "backend": {
                "type": "str",
                "default": "loky",
                "optional": true,
                "description": "Parallelization backend to use. See :class:`joblib.Parallel` for available options.",
                "optional_value": false
            },
            "show_progress_bar": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to show the progress bar or not.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[tuple[ndarray[Any, dtype[Any]], ndarray[Any, dtype[Any]]]]",
            "description": "If ``copy = True``, returns a :class:`tuple` with the z-score and the enrichment count.\nOtherwise, modifies the ``adata`` with the following keys:\n- :attr:`anndata.AnnData.uns` ``['{cluster_key}_nhood_enrichment']['zscore']`` - the enrichment z-score.\n- :attr:`anndata.AnnData.uns` ``['{cluster_key}_nhood_enrichment']['count']`` - the enrichment count."
        },
        "Docstring": "Compute neighborhood enrichment by permutation test.\n\nParameters\n----------\nadata\n    Annotated data object.\ncluster_key\n    Key in :attr:`anndata.AnnData.obs` where clustering is stored.\nconnectivity_key\n    Key in :attr:`anndata.AnnData.obsp` where spatial connectivities are stored.\n    Default is: :attr:`anndata.AnnData.obsp` ``['spatial_connectivities']``.\nn_perms\n    Number of permutations for the permutation test.\nnumba_parallel\n    Whether to use :class:`numba.prange` or not. If `None`, it is determined automatically.\n    For small datasets or small number of interactions, it's recommended to set this to `False`.\nseed\n    Random seed for reproducibility.\ncopy\n    If ``True``, return the result, otherwise save it to the ``adata`` object.\nn_jobs\n    Number of parallel jobs.\nbackend\n    Parallelization backend to use. See :class:`joblib.Parallel` for available options.\nshow_progress_bar\n    Whether to show the progress bar or not.\n\nReturns\n-------\nIf ``copy = True``, returns a :class:`tuple` with the z-score and the enrichment count.\n\nOtherwise, modifies the ``adata`` with the following keys:\n\n    - :attr:`anndata.AnnData.uns` ``['{cluster_key}_nhood_enrichment']['zscore']`` - the enrichment z-score.\n    - :attr:`anndata.AnnData.uns` ``['{cluster_key}_nhood_enrichment']['count']`` - the enrichment count.",
        "description": "Compute neighborhood enrichment by permutation test.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "squidpy.gr.nhood_enrichment(adata=$, cluster_key=@, connectivity_key=@, n_perms=@, numba_parallel=@, seed=@, copy=@, n_jobs=@, backend=@, show_progress_bar=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "squidpy.datasets.sc_mouse_cortex": {
        "Parameters": {
            "path": {
                "type": "Union[PathLike, str]",
                "default": "None",
                "optional": true,
                "description": "Path where to save the dataset.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "AnnData",
            "description": "The dataset."
        },
        "Docstring": "Pre-processed `scRNA-seq mouse cortex <https://doi.org/10.1038/s41586-018-0654-5>`__.\n\nThe shape of this :class:`anndata.AnnData` object ``(21697, 36826)``.\n\nParameters\n----------\npath\n    Path where to save the dataset.\nkwargs\n    Keyword arguments for :func:`scanpy.read`.\n\nReturns\n-------\nThe dataset.",
        "description": "Pre-processed `scRNA-seq mouse cortex <https://doi.org/10.1038/s41586-018-0654-5>`__.The shape of this :class:`anndata.AnnData` object ``(21697, 36826)``.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "squidpy.datasets.sc_mouse_cortex(path=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "squidpy.gr.spatial_neighbors": {
        "Parameters": {
            "adata": {
                "type": "Union[AnnData, SpatialData]",
                "default": null,
                "optional": false,
                "description": "Annotated data object.",
                "optional_value": true
            },
            "spatial_key": {
                "type": "str",
                "default": "spatial",
                "optional": true,
                "description": "Key in :attr:`anndata.AnnData.obsm` where spatial coordinates are stored.",
                "optional_value": false
            },
            "library_key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "If multiple `library_id`, column in :attr:`anndata.AnnData.obs`\nwhich stores mapping between ``library_id`` and obs.",
                "optional_value": false
            },
            "coord_type": {
                "type": "Optional[Union[str, CoordType]]",
                "default": "None",
                "optional": true,
                "description": "Type of coordinate system. Valid options are:\n\n    - `'grid'` - grid coordinates.\n    - `'generic'` - generic coordinates.\n    - `None` - `'grid'` if ``spatial_key`` is in :attr:`anndata.AnnData.uns`\n      with ``n_neighs = 6`` (Visium), otherwise use `'generic'`.",
                "optional_value": false
            },
            "n_neighs": {
                "type": "int",
                "default": "6",
                "optional": true,
                "description": "Depending on the ``coord_type``:\n\n    - `'grid'` - number of neighboring tiles.\n    - `'generic'` - number of neighborhoods for non-grid data. Only used when ``delaunay = False``.",
                "optional_value": false
            },
            "radius": {
                "type": "Optional[Union[float, tuple[float, float]]]",
                "default": "None",
                "optional": true,
                "description": "Only available when ``coord_type = 'generic'``. Depending on the type:\n\n    - :class:`float` - compute the graph based on neighborhood radius.\n    - :class:`tuple` - prune the final graph to only contain edges in interval `[min(radius), max(radius)]`.",
                "optional_value": false
            },
            "delaunay": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to compute the graph from Delaunay triangulation. Only used when ``coord_type = 'generic'``.",
                "optional_value": false
            },
            "n_rings": {
                "type": "int",
                "default": "1",
                "optional": true,
                "description": "Number of rings of neighbors for grid data. Only used when ``coord_type = 'grid'``.",
                "optional_value": false
            },
            "percentile": {
                "type": "Optional[float]",
                "default": "None",
                "optional": true,
                "description": "Percentile of the distances to use as threshold. Only used when ``coord_type = 'generic'``.",
                "optional_value": false
            },
            "transform": {
                "type": "Optional[Union[str, Transform]]",
                "default": "None",
                "optional": true,
                "description": "Type of adjacency matrix transform. Valid options are:\n\n    - `'spectral'` - spectral transformation of the adjacency matrix.\n    - `'cosine'` - cosine transformation of the adjacency matrix.\n    - `None` - no transformation of the adjacency matrix.",
                "optional_value": false
            },
            "set_diag": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to set the diagonal of the spatial connectivities to `1.0`.",
                "optional_value": false
            },
            "key_added": {
                "type": "str",
                "default": "spatial",
                "optional": true,
                "description": "Key which controls where the results are saved if ``copy = False``.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If ``True``, return the result, otherwise save it to the ``adata`` object.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[tuple[csr_matrix, csr_matrix]]",
            "description": "If ``copy = True``, returns a :class:`tuple` with the spatial connectivities and distances matrices.\nOtherwise, modifies the ``adata`` with the following keys:\n- :attr:`anndata.AnnData.obsp` ``['{key_added}_connectivities']`` - the spatial connectivities.\n- :attr:`anndata.AnnData.obsp` ``['{key_added}_distances']`` - the spatial distances.\n- :attr:`anndata.AnnData.uns`  ``['{key_added}']`` - :class:`dict` containing parameters."
        },
        "Docstring": "Create a graph from spatial coordinates.\n\nParameters\n----------\nadata\n    Annotated data object.\nspatial_key\n    Key in :attr:`anndata.AnnData.obsm` where spatial coordinates are stored.\nlibrary_key\n    If multiple `library_id`, column in :attr:`anndata.AnnData.obs`\n    which stores mapping between ``library_id`` and obs.\ncoord_type\n    Type of coordinate system. Valid options are:\n\n        - `'grid'` - grid coordinates.\n        - `'generic'` - generic coordinates.\n        - `None` - `'grid'` if ``spatial_key`` is in :attr:`anndata.AnnData.uns`\n          with ``n_neighs = 6`` (Visium), otherwise use `'generic'`.\nn_neighs\n    Depending on the ``coord_type``:\n\n        - `'grid'` - number of neighboring tiles.\n        - `'generic'` - number of neighborhoods for non-grid data. Only used when ``delaunay = False``.\nradius\n    Only available when ``coord_type = 'generic'``. Depending on the type:\n\n        - :class:`float` - compute the graph based on neighborhood radius.\n        - :class:`tuple` - prune the final graph to only contain edges in interval `[min(radius), max(radius)]`.\ndelaunay\n    Whether to compute the graph from Delaunay triangulation. Only used when ``coord_type = 'generic'``.\nn_rings\n    Number of rings of neighbors for grid data. Only used when ``coord_type = 'grid'``.\npercentile\n    Percentile of the distances to use as threshold. Only used when ``coord_type = 'generic'``.\ntransform\n    Type of adjacency matrix transform. Valid options are:\n\n        - `'spectral'` - spectral transformation of the adjacency matrix.\n        - `'cosine'` - cosine transformation of the adjacency matrix.\n        - `None` - no transformation of the adjacency matrix.\nset_diag\n    Whether to set the diagonal of the spatial connectivities to `1.0`.\nkey_added\n    Key which controls where the results are saved if ``copy = False``.\ncopy\n    If ``True``, return the result, otherwise save it to the ``adata`` object.\n\nReturns\n-------\nIf ``copy = True``, returns a :class:`tuple` with the spatial connectivities and distances matrices.\n\nOtherwise, modifies the ``adata`` with the following keys:\n\n    - :attr:`anndata.AnnData.obsp` ``['{key_added}_connectivities']`` - the spatial connectivities.\n    - :attr:`anndata.AnnData.obsp` ``['{key_added}_distances']`` - the spatial distances.\n    - :attr:`anndata.AnnData.uns`  ``['{key_added}']`` - :class:`dict` containing parameters.",
        "description": "Create a graph from spatial coordinates.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "squidpy.gr.spatial_neighbors(adata=$, spatial_key=@, library_key=@, coord_type=@, n_neighs=@, radius=@, delaunay=@, n_rings=@, percentile=@, transform=@, set_diag=@, key_added=@, copy=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "squidpy.gr.ligrec": {
        "Parameters": {
            "adata": {
                "type": "Union[AnnData, SpatialData]",
                "default": null,
                "optional": false,
                "description": "Annotated data object.",
                "optional_value": true
            },
            "cluster_key": {
                "type": "str",
                "default": null,
                "optional": false,
                "description": "Key in :attr:`anndata.AnnData.obs` where clustering is stored.",
                "optional_value": false
            },
            "interactions": {
                "type": "Optional[Interaction_t]",
                "default": "None",
                "optional": true,
                "description": "Interaction to test. The type can be one of:\n\n    - :class:`pandas.DataFrame` - must contain at least 2 columns named `'source'` and `'target'`.\n    - :class:`dict` - dictionary with at least 2 keys named `'source'` and `'target'`.\n    - :class:`typing.Sequence` - Either a sequence of :class:`str`, in which case all combinations are\n      produced, or a sequence of :class:`tuple` of 2 :class:`str` or a :class:`tuple` of 2 sequences.\n\nIf `None`, the interactions are extracted from :mod:`omnipath`. Protein complexes can be specified by\ndelimiting the components with `'_'`, such as `'alpha_beta_gamma'`.",
                "optional_value": true
            },
            "complex_policy": {
                "type": "Literal['min', 'all']",
                "default": "min",
                "optional": true,
                "description": "Policy on how to handle complexes. Valid options are:\n\n    - `'min'` - select gene with the minimum average expression. This is the same as in\n      :cite:`cellphonedb`.\n    - `'all'` - select all possible combinations between `'source'` and `'target'` complexes.",
                "optional_value": true
            },
            "threshold": {
                "type": "float",
                "default": "0.01",
                "optional": true,
                "description": "Do not perform permutation test if any of the interacting components is being expressed\nin less than ``threshold`` percent of cells within a given cluster.",
                "optional_value": false
            },
            "corr_method": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Correction method for multiple testing. See :func:`statsmodels.stats.multitest.multipletests`\nfor valid options.",
                "optional_value": false
            },
            "corr_axis": {
                "type": "Literal['interactions', 'clusters']",
                "default": "clusters",
                "optional": true,
                "description": "Axis over which to perform the FDR correction. Only used when ``corr_method != None``. Valid options are:\n\n    - `'interactions'` - correct interactions by performing FDR correction across the clusters.\n    - `'clusters'` - correct clusters by performing FDR correction across the interactions.",
                "optional_value": false
            },
            "use_raw": {
                "type": "bool",
                "default": "True",
                "optional": true,
                "description": "Whether to access :attr:`anndata.AnnData.raw`.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If ``True``, return the result, otherwise save it to the ``adata`` object.",
                "optional_value": false
            },
            "key_added": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Key in :attr:`anndata.AnnData.uns` where the result is stored if ``copy = False``.\nIf `None`, ``'{cluster_key}_ligrec'`` will be used.",
                "optional_value": false
            },
            "gene_symbols": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Key in :attr:`anndata.AnnData.var` to use instead of :attr:`anndata.AnnData.var_names`.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[Mapping[str, pd.DataFrame]]",
            "description": "If ``copy = True``, returns a :class:`dict` with following keys:\n- `'means'` - :class:`pandas.DataFrame` containing the mean expression.\n- `'pvalues'` - :class:`pandas.DataFrame` containing the possibly corrected p-values.\n- `'metadata'` - :class:`pandas.DataFrame` containing interaction metadata.\nOtherwise, modifies the ``adata`` object with the following key:\n- :attr:`anndata.AnnData.uns` ``['{key_added}']`` - the above mentioned :class:`dict`.\n`NaN` p-values mark combinations for which the mean expression of one of the interacting components was 0\nor it didn't pass the ``threshold`` percentage of cells being expressed within a given cluster."
        },
        "Docstring": "Perform the permutation test as described in :cite:`cellphonedb`.\n\nParameters\n----------\nadata\n    Annotated data object.\nuse_raw\n    Whether to access :attr:`anndata.AnnData.raw`.\ninteractions\n    Interaction to test. The type can be one of:\n\n        - :class:`pandas.DataFrame` - must contain at least 2 columns named `'source'` and `'target'`.\n        - :class:`dict` - dictionary with at least 2 keys named `'source'` and `'target'`.\n        - :class:`typing.Sequence` - Either a sequence of :class:`str`, in which case all combinations are\n          produced, or a sequence of :class:`tuple` of 2 :class:`str` or a :class:`tuple` of 2 sequences.\n\n    If `None`, the interactions are extracted from :mod:`omnipath`. Protein complexes can be specified by\n    delimiting the components with `'_'`, such as `'alpha_beta_gamma'`.\ncomplex_policy\n    Policy on how to handle complexes. Valid options are:\n\n        - `'min'` - select gene with the minimum average expression. This is the same as in\n          :cite:`cellphonedb`.\n        - `'all'` - select all possible combinations between `'source'` and `'target'` complexes.\ninteractions_params\n    Keyword arguments for :func:`omnipath.interactions.import_intercell_network` defining the interactions.\n    These datasets from :cite:`omnipath` are used by default: `omnipath`, `pathwayextra`, `kinaseextra` and\n    `ligrecextra`.\ntransmitter_params\n    Keyword arguments for :func:`omnipath.interactions.import_intercell_network` defining the transmitter\n    side of intercellular connections.\nreceiver_params\n    Keyword arguments for :func:`omnipath.interactions.import_intercell_network` defining the receiver\n    side of intercellular connections.\ncluster_key\n    Key in :attr:`anndata.AnnData.obs` where clustering is stored.\nclusters\n    Clusters from :attr:`anndata.AnnData.obs` ``['{cluster_key}']``. Can be specified either as a sequence\n    of :class:`tuple` or just a sequence of cluster names, in which case all combinations considered.\nn_perms\n    Number of permutations for the permutation test.\nthreshold\n    Do not perform permutation test if any of the interacting components is being expressed\n    in less than ``threshold`` percent of cells within a given cluster.\nseed\n    Random seed for reproducibility.\ncorr_method\n    Correction method for multiple testing. See :func:`statsmodels.stats.multitest.multipletests`\n    for valid options.\ncorr_axis\n    Axis over which to perform the FDR correction. Only used when ``corr_method != None``. Valid options are:\n\n        - `'interactions'` - correct interactions by performing FDR correction across the clusters.\n        - `'clusters'` - correct clusters by performing FDR correction across the interactions.\nalpha\n    Significance level for FDR correction. Only used when ``corr_method != None``.\ncopy\n    If ``True``, return the result, otherwise save it to the ``adata`` object.\nkey_added\n    Key in :attr:`anndata.AnnData.uns` where the result is stored if ``copy = False``.\n    If `None`, ``'{cluster_key}_ligrec'`` will be used.\nnumba_parallel\n    Whether to use :class:`numba.prange` or not. If `None`, it is determined automatically.\n    For small datasets or small number of interactions, it's recommended to set this to `False`.\nn_jobs\n    Number of parallel jobs.\nbackend\n    Parallelization backend to use. See :class:`joblib.Parallel` for available options.\nshow_progress_bar\n    Whether to show the progress bar or not.\ngene_symbols\n    Key in :attr:`anndata.AnnData.var` to use instead of :attr:`anndata.AnnData.var_names`.\n\nReturns\n-------\nIf ``copy = True``, returns a :class:`dict` with following keys:\n\n    - `'means'` - :class:`pandas.DataFrame` containing the mean expression.\n    - `'pvalues'` - :class:`pandas.DataFrame` containing the possibly corrected p-values.\n    - `'metadata'` - :class:`pandas.DataFrame` containing interaction metadata.\n\nOtherwise, modifies the ``adata`` object with the following key:\n\n    - :attr:`anndata.AnnData.uns` ``['{key_added}']`` - the above mentioned :class:`dict`.\n\n`NaN` p-values mark combinations for which the mean expression of one of the interacting components was 0\nor it didn't pass the ``threshold`` percentage of cells being expressed within a given cluster.",
        "description": "Perform the permutation test as described in :cite:`cellphonedb`.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "squidpy.gr.ligrec(adata=$, cluster_key=@, interactions=$, complex_policy=$, threshold=@, corr_method=@, corr_axis=@, use_raw=@, copy=@, key_added=@, gene_symbols=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "squidpy.pl.centrality_scores": {
        "Parameters": {
            "adata": {
                "type": "AnnData",
                "default": null,
                "optional": false,
                "description": "Annotated data object.",
                "optional_value": true
            },
            "cluster_key": {
                "type": "str",
                "default": null,
                "optional": false,
                "description": "Key in :attr:`anndata.AnnData.obs` where clustering is stored.",
                "optional_value": false
            },
            "score": {
                "type": "Optional[Union[str, Sequence[str]]]",
                "default": "None",
                "optional": true,
                "description": "Whether to plot all scores or only selected ones.",
                "optional_value": false
            },
            "palette": {
                "type": "Palette_t",
                "default": "None",
                "optional": true,
                "description": "Categorical colormap for the clusters.\nIf ``None``, use :attr:`anndata.AnnData.uns` ``['{cluster_key}_colors']``, if available.",
                "optional_value": true
            },
            "figsize": {
                "type": "Optional[tuple[float, float]]",
                "default": "None",
                "optional": true,
                "description": "Size of the figure in inches.",
                "optional_value": false
            },
            "dpi": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Dots per inch.",
                "optional_value": false
            },
            "save": {
                "type": "Optional[Union[str, Path]]",
                "default": "None",
                "optional": true,
                "description": "Whether to save the plot.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": "Nothing, just plots the figure and optionally saves the plot."
        },
        "Docstring": "Plot centrality scores.\n\nThe centrality scores are computed by :func:`squidpy.gr.centrality_scores`.\n\nParameters\n----------\nadata\n    Annotated data object.\ncluster_key\n    Key in :attr:`anndata.AnnData.obs` where clustering is stored.\nscore\n    Whether to plot all scores or only selected ones.\nlegend_kwargs\n    Keyword arguments for :func:`matplotlib.pyplot.legend`.\npalette\n    Categorical colormap for the clusters.\n    If ``None``, use :attr:`anndata.AnnData.uns` ``['{cluster_key}_colors']``, if available.\nfigsize\n    Size of the figure in inches.\ndpi\n    Dots per inch.\nsave\n    Whether to save the plot.\nscalebar_kwargs\n    Keyword arguments for :meth:`matplotlib_scalebar.ScaleBar`.\nedges_kwargs\n    Keyword arguments for :func:`networkx.draw_networkx_edges`.\nkwargs\n    Keyword arguments for :func:`matplotlib.pyplot.scatter` or :func:`matplotlib.pyplot.imshow`.\n\n\nReturns\n-------\nNothing, just plots the figure and optionally saves the plot.",
        "description": "Plot centrality scores.The centrality scores are computed by :func:`squidpy.gr.centrality_scores`.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "squidpy.pl.centrality_scores(adata=$, cluster_key=@, score=@, palette=$, figsize=@, dpi=@, save=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "squidpy.gr.centrality_scores": {
        "Parameters": {
            "adata": {
                "type": "Union[AnnData, SpatialData]",
                "default": null,
                "optional": false,
                "description": "Annotated data object.",
                "optional_value": true
            },
            "cluster_key": {
                "type": "str",
                "default": null,
                "optional": false,
                "description": "Key in :attr:`anndata.AnnData.obs` where clustering is stored.",
                "optional_value": false
            },
            "score": {
                "type": "Optional[Union[str, Iterable[str]]]",
                "default": "None",
                "optional": true,
                "description": "Centrality measures as described in :mod:`networkx.algorithms.centrality` :cite:`networkx`.\nIf `None`, use all the options below. Valid options are:\n\n    - `'closeness_centrality'` - measure of how close the group is to other nodes.\n    - `'average_clustering'` - measure of the degree to which nodes cluster together.\n    - `'degree_centrality'` - fraction of non-group members connected to group members.",
                "optional_value": false
            },
            "connectivity_key": {
                "type": "Optional[str]",
                "default": "None",
                "optional": true,
                "description": "Key in :attr:`anndata.AnnData.obsp` where spatial connectivities are stored.\nDefault is: :attr:`anndata.AnnData.obsp` ``['spatial_connectivities']``.",
                "optional_value": false
            },
            "copy": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "If ``True``, return the result, otherwise save it to the ``adata`` object.",
                "optional_value": false
            },
            "n_jobs": {
                "type": "Optional[int]",
                "default": "None",
                "optional": true,
                "description": "Number of parallel jobs.",
                "optional_value": false
            },
            "backend": {
                "type": "str",
                "default": "loky",
                "optional": true,
                "description": "Parallelization backend to use. See :class:`joblib.Parallel` for available options.",
                "optional_value": false
            },
            "show_progress_bar": {
                "type": "bool",
                "default": "False",
                "optional": true,
                "description": "Whether to show the progress bar or not.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": "Optional[pd.DataFrame]",
            "description": "If ``copy = True``, returns a :class:`pandas.DataFrame`. Otherwise, modifies the ``adata`` with the following key:\n- :attr:`anndata.AnnData.uns` ``['{cluster_key}_centrality_scores']`` - the centrality scores,\nas mentioned above."
        },
        "Docstring": "Compute centrality scores per cluster or cell type.\n\nInspired by usage in Gene Regulatory Networks (GRNs) in :cite:`celloracle`.\n\nParameters\n----------\nadata\n    Annotated data object.\ncluster_key\n    Key in :attr:`anndata.AnnData.obs` where clustering is stored.\nscore\n    Centrality measures as described in :mod:`networkx.algorithms.centrality` :cite:`networkx`.\n    If `None`, use all the options below. Valid options are:\n\n        - `'closeness_centrality'` - measure of how close the group is to other nodes.\n        - `'average_clustering'` - measure of the degree to which nodes cluster together.\n        - `'degree_centrality'` - fraction of non-group members connected to group members.\n\nconnectivity_key\n    Key in :attr:`anndata.AnnData.obsp` where spatial connectivities are stored.\n    Default is: :attr:`anndata.AnnData.obsp` ``['spatial_connectivities']``.\ncopy\n    If ``True``, return the result, otherwise save it to the ``adata`` object.\nn_jobs\n    Number of parallel jobs.\nbackend\n    Parallelization backend to use. See :class:`joblib.Parallel` for available options.\nshow_progress_bar\n    Whether to show the progress bar or not.\n\nReturns\n-------\nIf ``copy = True``, returns a :class:`pandas.DataFrame`. Otherwise, modifies the ``adata`` with the following key:\n\n    - :attr:`anndata.AnnData.uns` ``['{cluster_key}_centrality_scores']`` - the centrality scores,\n      as mentioned above.",
        "description": "Compute centrality scores per cluster or cell type.Inspired by usage in Gene Regulatory Networks (GRNs) in :cite:`celloracle`.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "squidpy.gr.centrality_scores(adata=$, cluster_key=@, score=@, connectivity_key=@, copy=@, n_jobs=@, backend=@, show_progress_bar=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "squidpy.datasets.visium_fluo_image_crop": {
        "Parameters": {
            "path": {
                "type": "Union[PathLike, str]",
                "default": "None",
                "optional": true,
                "description": "Path where to save the .tiff image.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ":class:`squidpy.im.ImageContainer` The image data."
        },
        "Docstring": "Cropped Fluorescent image from `10x Genomics Visium dataset <https://support.10xgenomics.com/spatial-gene-expression/datasets/1.1.0/V1_Adult_Mouse_Brain_Coronal_Section_2>`__.\n\nThe shape of this image is ``(7272, 7272)``.\n\nParameters\n----------\npath\n    Path where to save the .tiff image.\nkwargs\n    Keyword arguments for :meth:`squidpy.im.ImageContainer.add_img`.\n\nReturns\n-------\n:class:`squidpy.im.ImageContainer` The image data.",
        "description": "Cropped Fluorescent image from `10x Genomics Visium dataset <https://support.10xgenomics.com/spatial-gene-expression/datasets/1.1.0/V1_Adult_Mouse_Brain_Coronal_Section_2>`__.The shape of this image is ``(7272, 7272)``.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "squidpy.datasets.visium_fluo_image_crop(path=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    },
    "squidpy.datasets.visium_hne_image_crop": {
        "Parameters": {
            "path": {
                "type": "Union[PathLike, str]",
                "default": "None",
                "optional": true,
                "description": "Path where to save the .tiff image.",
                "optional_value": false
            }
        },
        "Returns": {
            "type": null,
            "description": ":class:`squidpy.im.ImageContainer` The image data."
        },
        "Docstring": "Cropped H&E image from `10x Genomics Visium dataset <https://support.10xgenomics.com/spatial-gene-expression/datasets/1.1.0/V1_Adult_Mouse_Brain>`__.\n\nThe shape of this image is ``(3527, 3527)``.\n\nParameters\n----------\npath\n    Path where to save the .tiff image.\nkwargs\n    Keyword arguments for :meth:`squidpy.im.ImageContainer.add_img`.\n\nReturns\n-------\n:class:`squidpy.im.ImageContainer` The image data.",
        "description": "Cropped H&E image from `10x Genomics Visium dataset <https://support.10xgenomics.com/spatial-gene-expression/datasets/1.1.0/V1_Adult_Mouse_Brain>`__.The shape of this image is ``(3527, 3527)``.",
        "example": "",
        "api_type": "function",
        "api_calling": [
            "squidpy.datasets.visium_hne_image_crop(path=@)"
        ],
        "relevant APIs": [],
        "type": "singleAPI"
    }
}